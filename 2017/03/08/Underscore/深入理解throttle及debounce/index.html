<!DOCTYPE html>
<html lang="">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="深入理解underscore中的throttle与debounce"/>




  <meta name="keywords" content="js, underscore, throttle, debounce," />




  <link rel="alternate" href="/atom.xml" title="吴小蛆的巣">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.4.x" />



<link rel="canonical" href="http://yoyoyohamapi.me/2017/03/08/Underscore/深入理解throttle及debounce/"/>


<meta name="description" content="在谈论这两个函数之前，先来看一个前端开发中经常遇到的场景：  在页面中，我们有一个“查询”按钮，单击该按钮，会通过 ajax 异步查询一些数据  假设这个查询是耗时的， 并且会给后端造成一定压力，那么如果短时间内我们频繁点击该按钮，ajax 请求就会不断发出，这样给后端造成的压力是难以想象的。因此，我们会想到控制我们的查询速率，为此，我们可能会这样做： 独占性提交通过设置一个 flag 来标识当前">
<meta name="keywords" content="js, underscore, throttle, debounce">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解underscore中的throttle与debounce">
<meta property="og:url" content="http://yoyoyohamapi.me/2017/03/08/Underscore/深入理解throttle及debounce/index.html">
<meta property="og:site_name" content="吴小蛆的巣">
<meta property="og:description" content="在谈论这两个函数之前，先来看一个前端开发中经常遇到的场景：  在页面中，我们有一个“查询”按钮，单击该按钮，会通过 ajax 异步查询一些数据  假设这个查询是耗时的， 并且会给后端造成一定压力，那么如果短时间内我们频繁点击该按钮，ajax 请求就会不断发出，这样给后端造成的压力是难以想象的。因此，我们会想到控制我们的查询速率，为此，我们可能会这样做： 独占性提交通过设置一个 flag 来标识当前">
<meta property="og:updated_time" content="2017-03-08T02:17:57.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="深入理解underscore中的throttle与debounce">
<meta name="twitter:description" content="在谈论这两个函数之前，先来看一个前端开发中经常遇到的场景：  在页面中，我们有一个“查询”按钮，单击该按钮，会通过 ajax 异步查询一些数据  假设这个查询是耗时的， 并且会给后端造成一定压力，那么如果短时间内我们频繁点击该按钮，ajax 请求就会不断发出，这样给后端造成的压力是难以想象的。因此，我们会想到控制我们的查询速率，为此，我们可能会这样做： 独占性提交通过设置一个 flag 来标识当前">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.4.x" />







<script>
  var CONFIG = {
    search: false,
    searchPath: "/search.xml",
    fancybox: false,
    toc: true,
  }
</script>




  



    <title> 深入理解underscore中的throttle与debounce · 吴小蛆的巣 </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">吴小蛆的巣</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            Home
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            Archives
          
        </li>
      </a>
    
      <a href="/tags">
        <li class="mobile-menu-item">
          
          
            Tags
          
        </li>
      </a>
    
      <a href="/categories">
        <li class="mobile-menu-item">
          
          
            Categories
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">吴小蛆的巣</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              Home
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              Archives
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            
            
              Tags
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/categories">
            
            
              Categories
            
          </a>
        </li>
      
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          深入理解underscore中的throttle与debounce
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Mar 8, 2017
        </span>
      </div>
    </header>

    
    
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#独占性提交"><span class="toc-text">独占性提交</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#节制型提交"><span class="toc-text">节制型提交</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#underscore中的throttle"><span class="toc-text">underscore中的throttle</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#leading-edge与trailing-edge"><span class="toc-text">leading edge与trailing edge</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#debounce"><span class="toc-text">debounce</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#应用场景"><span class="toc-text">应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#debounce的应用场景"><span class="toc-text">debounce的应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#throttle的应用场景"><span class="toc-text">throttle的应用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参考资料"><span class="toc-text">参考资料</span></a>
    </div>
  </div>


    <div class="post-content">
      
        <p>在谈论这两个函数之前，先来看一个前端开发中经常遇到的场景：</p>
<blockquote>
<p>在页面中，我们有一个“查询”按钮，单击该按钮，会通过 <code>ajax</code> 异步查询一些数据</p>
</blockquote>
<p>假设这个查询是耗时的， 并且会给后端造成一定压力，那么如果短时间内我们频繁点击该按钮，<code>ajax</code> 请求就会不断发出，这样给后端造成的压力是难以想象的。因此，我们会想到控制我们的查询速率，为此，我们可能会这样做：</p>
<h4 id="独占性提交"><a href="#独占性提交" class="headerlink" title="独占性提交"></a>独占性提交</h4><p>通过设置一个 <code>flag</code> 来标识当前正在请求中，如果已在请求中，则不允许再次请求，请求完成，刷新该 <code>flag</code> 来允许新的请求提交</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> isQuerying = <span class="literal">false</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> sendQuery = <span class="function"><span class="keyword">function</span>(<span class="params">complete</span>) </span>&#123;</div><div class="line">  <span class="comment">// 如果已经在查询了，那么需要等待</span></div><div class="line">  <span class="keyword">if</span>(isQuerying)&#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">"waiting"</span>);</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"send query"</span>);</div><div class="line">  <span class="comment">// 标识当前正在查询中</span></div><div class="line">  isQuerying = <span class="literal">true</span>;</div><div class="line">  <span class="comment">// 我们模拟一个耗时操作</span></div><div class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">   complete &amp;&amp; complete();    </div><div class="line">  &#125;,<span class="number">2000</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> complete = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">   <span class="comment">// 在回调中， 我们刷新标记量</span></div><div class="line">   isQuerying = <span class="literal">false</span>;</div><div class="line">   <span class="built_in">console</span>.log(<span class="string">"completed"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">$(<span class="string">"#queryBtn"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;sendQuery(complete);&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 测试一下， 可以看到新的请求不再立即被送出</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++) &#123;</div><div class="line">  $(<span class="string">"#queryBtn"</span>).click();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h4 id="节制型提交"><a href="#节制型提交" class="headerlink" title="节制型提交"></a>节制型提交</h4><p>在独占型提交中，如果一个请求已经在进行中，那么再多的点击都会被废弃。那么如果我们只是想限制请求速率，而不想废弃掉之后的点击，那我们得考虑新的提交方式。先来开限制提交的问题本质：</p>
<blockquote>
<p>控制回调发生的速率, 不需要回调发生那么快</p>
</blockquote>
<p>由于我们的对查询按钮绑定的 <code>click</code> 事件必然会在按钮点击是发生，如下，<code>sendQuery</code> 函数必然会在 <code>click</code> 后被调用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">$(<span class="string">"#queryBtn"</span>).click(sendQuery);</div></pre></td></tr></table></figure>
<p>但是，如果我们新建一个 <code>func</code> 来包裹一下 <code>sendQuery</code> 业务，那么在 <code>click</code> 事件后，<code>func</code> 被调用，在其执行过程中，我们有选择的考虑是否执行 <code>sendQuery</code>，亦即控制住 <code>sendQuery</code> 的调用频率。</p>
<p>假设我们想至少等待1s才能发出一次新的查询请求（及请求的调用频次不能超过<strong>1次/秒</strong>）， 那么应该这样设计：</p>
<ol>
<li>开始：<code>click</code> 事件到来， <code>func</code> 函数被调用</li>
<li>获得当前时间，比较当前时间距上次 <code>sendQuery</code> 执行的时间是否已经足够 <code>1s</code> 。</li>
<li>如果已经足够，那么这次查询请求可以立即被执行，否则计算应该等待的时间，延后执行该请求。</li>
</ol>
<p>看代码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> previous = <span class="number">0</span>； <span class="comment">// 记录上次执行的时间点</span></div><div class="line"><span class="keyword">var</span> waiting = <span class="number">1000</span>; <span class="comment">// 需要等待的时间</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> sendQuery = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 执行的时候， 刷新previous</span></div><div class="line">  previous = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();	</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"sending query"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 获得当前时间</span></div><div class="line">  <span class="keyword">var</span> now = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();</div><div class="line">  <span class="comment">// 获得需要等待的时间</span></div><div class="line">  <span class="keyword">var</span> remain = waiting-(now-previous);</div><div class="line">  <span class="comment">// 判断是否立即执行</span></div><div class="line">  <span class="keyword">if</span>(remain&lt;=<span class="number">0</span>) &#123;</div><div class="line">    sendQuery();		</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    setTimeout(sendQuery, remain);</div><div class="line">  &#125;		</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了防止变量的全局污染， 我们再用一个立即执行函数包裹下作用域：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> delayedQuery = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> previous = <span class="number">0</span>; <span class="comment">// 记录上次执行的时间点</span></div><div class="line">  <span class="keyword">var</span> waiting = <span class="number">1000</span>; <span class="comment">// 需要等待的时间</span></div><div class="line"></div><div class="line">  <span class="keyword">var</span> sendQuery = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 执行的时候， 刷新previous</span></div><div class="line">    previous = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"sending query"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 获得当前时间</span></div><div class="line">    <span class="keyword">var</span> now = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();</div><div class="line">    <span class="comment">// 获得需要等待的时间</span></div><div class="line">    <span class="keyword">var</span> remain = waiting - (now - previous);</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"need waiting "</span> + remain + <span class="string">" ms"</span>);</div><div class="line">    <span class="comment">// 判断是否立即执行</span></div><div class="line">    <span class="keyword">if</span> (remain &lt;= <span class="number">0</span>) &#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">"immediately"</span>);</div><div class="line">      sendQuery();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">"delayed"</span>);</div><div class="line">      setTimeout(sendQuery, remain);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line">$(<span class="string">"#queryBtn"</span>).click(delayedQuery);</div></pre></td></tr></table></figure>
<p>但是，我们的业务代码 <code>sendQuery</code> 还是去耦合了刷新 <code>previous</code> 的逻辑，并且，每个延迟执行的诉求都要去做这样一个包裹，样板代码就显得太多了。现在我们撰写一个通用函数，我们将（1）<code>需要控制调用频度的函数</code> 和（2）<code>对调用频度的限制</code> 传递给他，他能够返回一个限制了执行频率的函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * throttle</div><div class="line"> * @param &#123;Function&#125; func 待控制频率的函数</div><div class="line"> * @param &#123;Number&#125; waiting 每次调用的最小等待周期</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func,waiting</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> previous = <span class="number">0</span>;</div><div class="line">  </div><div class="line">  <span class="comment">// 创建一个func的wrapper，如要是解耦func与previous等变量</span></div><div class="line">  <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 刷新previous</span></div><div class="line">    previous = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();</div><div class="line">    <span class="comment">// 执行调用</span></div><div class="line">    func();	</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 返回一个被控制了调用频率的</span></div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 获得当前时间</span></div><div class="line">      <span class="keyword">var</span> now = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();</div><div class="line">      <span class="comment">// 获得需要等待的时间</span></div><div class="line">      <span class="keyword">var</span> remain = waiting - (now - previous);</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">"need waiting "</span> + remain + <span class="string">" ms"</span>);</div><div class="line">      <span class="comment">// 判断是否立即执行</span></div><div class="line">      <span class="keyword">if</span> (remain &lt;= <span class="number">0</span>) &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"immediately"</span>);</div><div class="line">        later();</div><div class="line"> 	    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"delayed"</span>);</div><div class="line">        setTimeout(later, remain);</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 现在，刷新previous不再需要耦合到sendQuery中</span></div><div class="line"><span class="keyword">var</span> sendQuery = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"sending query"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">delayedQuery = throttle(sendQuery,<span class="number">1000</span>);</div></pre></td></tr></table></figure>
<p><a href="https://jsfiddle.net/softshot/r6uh3xug/2/" target="_blank" rel="external">查看演示</a></p>
<hr>
<h3 id="underscore中的throttle"><a href="#underscore中的throttle" class="headerlink" title="underscore中的throttle"></a>underscore中的throttle</h3><p>可以看出来， 这里我已经用了 <code>throttle</code> 来命名我们的函数了，<code>throttle</code>，也就是节流阀的意思，很形象是吧，通过这样一个阀门，我们限制函数的执行频次。</p>
<p>但是在上面的演示中，还有一点小问题，一些点击的查询回调虽然被延迟执行了，但是在某个时间点，他们好像一起执行了，这是因为 <code>setTimeout(func, wait)</code> 并不能保证 <code>func</code> 的执行开始时间，只能保证 <code>func</code> 在不早于从现在起到 <code>wait</code> 毫秒后发生。所以被延后执行的那些查询在某个相近的时间点同时发生了。</p>
<p>出现这个错误的原因就是：</p>
<blockquote>
<p>我们只保障了第一次回调和接下来所有回调的间隔执行，而没有保障到各个回调间相互的间隔执行。</p>
</blockquote>
<p>下面可以看一下underscore中 <code>throttle</code> 的实现，比刚才我们写的throttle函数健壮许多。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">_.throttle = <span class="function"><span class="keyword">function</span> (<span class="params">func, wait, options</span>) </span>&#123;</div><div class="line">        <span class="comment">// timeout标识最近一次被追踪的调用</span></div><div class="line">        <span class="comment">// context和args缓存func执行时需要的上下文，result缓存func执行结果</span></div><div class="line">        <span class="keyword">var</span> timeout, context, args, result;</div><div class="line">        <span class="comment">// 最近一次func被调用的时间点</span></div><div class="line">        <span class="keyword">var</span> previous = <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span> (!options) options = &#123;&#125;;</div><div class="line"></div><div class="line">        <span class="comment">// 创建一个延后执行的函数包裹住func的执行过程</span></div><div class="line">        <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="comment">// 执行时，刷新最近一次调用时间</span></div><div class="line">            previous = options.leading === <span class="literal">false</span> ? <span class="number">0</span> : _.now();</div><div class="line">            <span class="comment">// 清空为此次执行设置的定时器</span></div><div class="line">            timeout = <span class="literal">null</span>;</div><div class="line">            result = func.apply(context, args);</div><div class="line">            <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        <span class="comment">// 返回一个throttle化的函数</span></div><div class="line">        <span class="keyword">var</span> throttled = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="comment">// 我们尝试调用func时，会首先记录当前时间戳</span></div><div class="line">            <span class="keyword">var</span> now = _.now();</div><div class="line">            <span class="comment">// 是否是第一次调用</span></div><div class="line">            <span class="keyword">if</span> (!previous &amp;&amp; options.leading === <span class="literal">false</span>) previous = now;</div><div class="line">            <span class="comment">// func还要等待多久才能被调用 = 预设的最小等待期-（当前时间-上一次调用的时间）</span></div><div class="line">            <span class="keyword">var</span> remaining = wait - (now - previous);</div><div class="line">            <span class="comment">// 记录执行时需要的上下文和参数</span></div><div class="line">            context = <span class="keyword">this</span>;</div><div class="line">            args = <span class="built_in">arguments</span>;</div><div class="line">            <span class="comment">// 如果计算后能被立即执行</span></div><div class="line">            <span class="keyword">if</span> (remaining &lt;= <span class="number">0</span> || remaining &gt; wait) &#123;</div><div class="line">                <span class="comment">// 清除之前的设置的延时执行，就不存在某些回调一同发生的情况了</span></div><div class="line">                <span class="keyword">if</span> (timeout) &#123;</div><div class="line">                    clearTimeout(timeout);</div><div class="line">                    timeout = <span class="literal">null</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// 刷新最近一次func调用的时间点</span></div><div class="line">                previous = now;</div><div class="line">                <span class="comment">// 执行func调用</span></div><div class="line">                result = func.apply(context, args);</div><div class="line">                <span class="comment">// 再次检查timeout，因为func执行期间可能有新的timeout被设置，如果timeout被清空了，代表不再有等待执行的func，也清空context和args</span></div><div class="line">                <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!timeout &amp;&amp; options.trailing !== <span class="literal">false</span>) &#123;</div><div class="line">                <span class="comment">// 如果设置了trailing edge，那么暂缓此次调用尝试的执行</span></div><div class="line">                timeout = setTimeout(later, remaining);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        <span class="comment">// 不再控制函数执行调用频率</span></div><div class="line">        throttled.cancel = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            clearTimeout(timeout);</div><div class="line">            previous = <span class="number">0</span>;</div><div class="line">            timeout = context = args = <span class="literal">null</span>;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> throttled;</div><div class="line">    &#125;;</div></pre></td></tr></table></figure>
<blockquote>
<p>与我们所写的 <code>throttle</code> 不同的是，underscore中的 <code>throttle</code> 并不需要为每次回调都设置一个定时器来延后执行。他的定时器只记录最新一次的调用尝试。比如 <code>waiting</code> 为 <code>1s</code>，在 <code>1.5s</code> 内我们单击了查询按钮 <code>20</code> 次，真正会被送出的查询只有至多两次，分别是第一次和最后一次。这就不会出现上面延时中出现的“某时刻一些延时函数同时发生”的情况了。</p>
</blockquote>
<p>在underscore的实现中，有个令人疑惑的判断条件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> (remaining &lt;= <span class="number">0</span> || remaining &gt; wait)</div></pre></td></tr></table></figure>
<p>当该条件成立时， 可以立即执行 <code>func</code>，<code>remaining&lt;=0</code> 的条件很容易理解，就是<strong>不再需要等待时</strong>，那么如何理解 <code>remaining &gt; wait</code> 呢?</p>
<p>显然，<code>remaining&gt;wait</code> 等同于 <code>now&lt;previous</code>， 亦即：<code>previous</code> 的被刷新晚于 <code>now</code> 的被设置。</p>
<p>这种情况就发生在我们当前尝试调用时，并且设置了当前时间点 <code>now</code> 之后，上次延时的函数 <code>later</code> 开始了执行， 并刷新了 <code>previous</code>，此时出现了 <code>now</code> 早于 <code>previous</code> 的情况。举个栗子：</p>
<ol>
<li>开始时，我们 <code>click</code> 了一次查询按钮，我们将之命名为 <code>click1</code>，此时 <code>previous==0</code></li>
<li>在 <code>0.4s</code> 时我们 <code>click</code> 了一次查询按钮 <code>click2</code>，<code>now==0.4</code>, <code>previous==0</code>, 则这次点击的查询会至少等待 <code>0.6s</code> 才送出，也就是最快要在 <code>1s</code> 的时候 <code>click2</code> 的查询请求才送出。（由于 <code>setTimeout(func, wait)</code> 并不能保证 <code>func</code> 的执行开始时间，只能保证 <code>func</code> 不早于从现在起到 <code>wait</code> 毫秒后发生， 所以 <code>click2</code> 的查询请求并不一定在 <code>1s</code> 时就能够被送出）</li>
<li>在 <code>1.2s</code> 时，产生 <code>click3</code>，<code>now==1.2</code></li>
</ol>
<p>则存在如下两种情况</p>
<ul>
<li><code>click2</code> 的查询先于 <code>click3</code> 发生，比如在 <code>1.1s</code> 时 <code>click2</code> 的回调被执行，那么 <code>click3</code> 的回调要等 <code>1-(1.2-1.1)==0.9s</code> 才发生</li>
<li><code>1.3s</code> 时 <code>click2</code> 的查询请求开始执行，<code>previous==1.3</code>，<code>remaining=1-(1.2-1.3)==1.1&gt;1</code>，此时，underscore会让 <code>click3</code> 的查询请求也开始执行（既不会停止 <code>click</code> 的查询请求，也不会停止 <code>click3</code> 的查询请求），<code>click3</code> 和 <code>click2</code> 的返回结果取最近一次。（这样做的目的暂时揣摩不到）</li>
</ul>
<h4 id="leading-edge与trailing-edge"><a href="#leading-edge与trailing-edge" class="headerlink" title="leading edge与trailing edge"></a>leading edge与trailing edge</h4><p>underscore中的 <code>throttle</code> 函数提供了第三个参数 <code>options</code> 来进行选项配置，并且支持如下两个参数：</p>
<ol>
<li><p><code>leading</code>：是否设置 <code>节流前缘--leading edge</code> ，前缘的作用是保证第一次尝试调用的 <code>func</code> 会被立即执行，否则第一次调用也必须等待 <code>wait</code> 时间，默认为 <code>true</code>。</p>
</li>
<li><p><code>trailing</code>：是否设置 <code>节流后缘--trailing edge</code> ，后缘的作用是：当最近一次尝试调用 <code>func</code> 时，如果 <code>func</code> 不能立即执行，会延后 <code>func</code> 的执行，默认为 <code>true</code>。</p>
</li>
</ol>
<p>这两个配置会带来总共四种组合，通过<a href="https://jsfiddle.net/softshot/Lakgk99q/9/" target="_blank" rel="external">这个演示</a>，观察不同组合的效果。</p>
<hr>
<h3 id="debounce"><a href="#debounce" class="headerlink" title="debounce"></a>debounce</h3><p>在实际项目中，我们还有一种需求，就是如果过于频繁的尝试调用某个函数时，只允许一次调用成功执行。仍然以点击查询按钮异步查询为例，假设我们每次点击的时间间隔都在 <code>1s</code> 内，那么所有的点击只有一次能送出请求，要么是第一次，要么是最后一次。显然，<code>throttle</code> 是做不到这点的，<code>throttle</code> 会至少送出两次请求。针对于此，underscore又撰写了 <code>debounce</code> 函数。</p>
<p>顾名思义， <code>debounce</code> –防反跳，就是不再跳起，不再响应的意思。</p>
<blockquote>
<p><code>throttle</code> 和 <code>debounce</code> 并非underscore独有，他们不仅仅是函数，也是解决问题的方式，诸如jquery，lodash等知名库都提供了这两个方法。</p>
</blockquote>
<p>从下面的 <code>debounce</code> 实现我们可以看到，不同于 <code>throttle</code>，<code>debounce</code> 不再计算 <code>remain</code> 时间，其提供的 <code>immediate</code> 参数类似于 <code>throttle</code> 中的对于 <code>leading-edge</code> 和 <code>trailing-edge</code> 的控制：</p>
<ul>
<li><code>immediate === true</code>，开启 <code>leading-edge</code>，当可以执行时立即执行</li>
<li><code>immediate === false</code>（默认）开启 <code>trailing-edge</code>，当可以执行时也必须延后至少 <code>wait</code> 个时间才能执行。</li>
</ul>
<p>因此，<code>debounce</code> 后的 <code>func</code> 要么立即获得响应，要么延迟一段时间才响应，<a href="https://jsfiddle.net/softshot/gamLjgcn/" target="_blank" rel="external">查看演示</a>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">_.debounce = <span class="function"><span class="keyword">function</span> (<span class="params">func, wait, immediate</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> timeout, result;</div><div class="line"></div><div class="line">        <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span> (<span class="params">context, args</span>) </span>&#123;</div><div class="line">            timeout = <span class="literal">null</span>;</div><div class="line">            <span class="keyword">if</span> (args) result = func.apply(context, args);</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        <span class="keyword">var</span> debounced = restArgs(<span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</div><div class="line">            <span class="comment">// 每次新的尝试调用func，会使抛弃之前等待的func</span></div><div class="line">            <span class="keyword">if</span> (timeout) clearTimeout(timeout);</div><div class="line">            <span class="comment">// 如果允许新的调用尝试立即执行，</span></div><div class="line">            <span class="keyword">if</span> (immediate) &#123;</div><div class="line">                <span class="comment">// 如果之前尚没有调用尝试，那么此次调用可以立马执行，否则就需要等待</span></div><div class="line">                <span class="keyword">var</span> callNow = !timeout;</div><div class="line">                <span class="comment">// 刷新timeout</span></div><div class="line">                timeout = setTimeout(later, wait);</div><div class="line">                <span class="comment">// 如果能被立即执行，立即执行</span></div><div class="line">                <span class="keyword">if</span> (callNow) result = func.apply(<span class="keyword">this</span>, args);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 否则，这次尝试调用会延时wait个时间</span></div><div class="line">                timeout = _.delay(later, wait, <span class="keyword">this</span>, args);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        debounced.cancel = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            clearTimeout(timeout);</div><div class="line">            timeout = <span class="literal">null</span>;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> debounced;</div><div class="line">    &#125;;</div></pre></td></tr></table></figure>
<hr>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><h4 id="debounce的应用场景"><a href="#debounce的应用场景" class="headerlink" title="debounce的应用场景"></a>debounce的应用场景</h4><p>一定要记住，<code>debounce</code> 满足的是：</p>
<blockquote>
<p>高频下只响应一次</p>
</blockquote>
<ol>
<li>遇上疯狂打字员，在输入框快速输入文字（高频），但是我们只想在其完全停止输入时再对输入文字做出处理（一次）。</li>
<li>AJAX，多数场景下，每个异步请求在短时间只能响应一次。比如下拉刷新，不停的到底（高频），但只发送一次ajax请求（一次）。</li>
</ol>
<h4 id="throttle的应用场景"><a href="#throttle的应用场景" class="headerlink" title="throttle的应用场景"></a>throttle的应用场景</h4><p>相比 <code>debounce</code>，<code>throttle</code> 要更加宽松一些，其目的在于:</p>
<blockquote>
<p>按频率执行调用。</p>
</blockquote>
<ol>
<li>游戏中的按键响应，比如格斗，比如射击，需要控制出拳和射击的速率。</li>
<li>自动完成，按照一定频率分析输入，提示自动完成。</li>
<li>鼠标移动和窗口滚动，鼠标稍微移动一下，窗口稍微滚动一下会带来大量的事件，因而需要控制回调的发生频率。</li>
</ol>
<hr>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="http://drupalmotion.com/article/debounce-and-throttle-visual-explanation" target="_blank" rel="external">Debounce and Throttle: a visual explanation</a></li>
<li><a href="https://www.zhihu.com/question/19805411" target="_blank" rel="external">知乎@长天之云的回答</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setTimeout" target="_blank" rel="external">MDN setTimeout</a></li>
<li><a href="https://blog.coding.net/blog/the-difference-between-throttle-and-debounce-in-underscorejs" target="_blank" rel="external">浅谈 Underscore.js 中 <em>.throttle 和 </em>.debounce 的差异</a></li>
<li><a href="http://www.easyui.info/archives/1853.html" target="_blank" rel="external">Underscore之throttle函数源码分析以及使用注意事项</a></li>
</ul>

      
    </div>

    
      
      

  <div class="post-copyright">
    <p class="copyright-item">
      <span>作者: </span>
      <span>吴晓军</span>
    </p>
    <p class="copyright-item">
      <span>来源: </span>
      <a href="http://yoyoyohamapi.me">http://yoyoyohamapi.me</a>
    </p>
    <p class="copyright-item">
      <span>链接: </span>
      <a href="http://yoyoyohamapi.me/2017/03/08/Underscore/深入理解throttle及debounce/">http://yoyoyohamapi.me/2017/03/08/Underscore/深入理解throttle及debounce/</a>
    </p>

    <p class="copyright-item lincese">
      
      本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可
    </p>
  </div>



      
      
    

    
      <footer class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/js-underscore-throttle-debounce/">js, underscore, throttle, debounce</a>
            
          </div>
        
        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2017/03/08/Sails_Tutorial/利用sails.js+mongodb开发博客系统(3)--登录注册/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">利用Sails.js+MongoDB开发博客系统(3)--账户模块</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    
    
      <a class="next" href="/2017/03/08/Web/RMM Level -- 对于REST的层级划分模型/">
        <span class="next-text nav-default">RMM Level -- 对于REST的层级划分模型</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

      </footer>
    

  </article>


          </div>
          
  <div class="comments" id="comments">
    
  </div>


        </div>  
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:softshot37@gmail.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
        
          <a href="https://github.com/yoyoyohamapi" class="iconfont icon-github" title="github"></a>
        
      
    
      
    
      
        
          <a href="https://www.zhihu.com/people/wu-xiao-jun-64-55/activities" class="iconfont icon-zhihu" title="zhihu"></a>
        
      
    
      
    
    
    
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>


<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://hexo.io/">Hexo</a>
  </span>
  
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2015 - 
    
    2017

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">吴晓军</span>
  </span>
</div>
      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    
  

  
  




    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  


    <script type="text/javascript" src="/js/src/even.js?v=2.4.x"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.4.x"></script>

    
  <!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</body>
</html>
