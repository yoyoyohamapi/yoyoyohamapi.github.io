<!DOCTYPE html>
<html lang="">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="更好用的 Redux"/>




  <meta name="keywords" content="React, Redux, RxJS, 吴小蛆的巣" />










  <link rel="alternate" href="/atom.xml" title="吴小蛆的巣">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.9.0" />



<link rel="canonical" href="http://yoyoyohamapi.me/2018/09/04/更好用的_Redux/"/>



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />




  <link rel="stylesheet" type="text/css" href="/lib/nprogress/nprogress.min.css" />



<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.9.0" />



  



  <script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>








<script>
  window.config = {"title":"吴小蛆的巣","subtitle":null,"description":"只要努力，蛆虫也能变成苍蝇翱翔于天际","author":"吴晓军","language":null,"timezone":null,"url":"http://yoyoyohamapi.me","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":true,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":true,"line_number":false,"tab_replace":"  "},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"page","theme":"even","deploy":{"type":"git","repo":"https://github.com/yoyoyohamapi/yoyoyohamapi.github.io.git","branch":"master"},"ignore":[],"math":{"engine":"mathjax"},"sitemap":{"path":"sitemap.xml"},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"index_generator":{"per_page":10},"feed":{"type":"atom","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"atom.xml"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"sanitize":false,"tables":true,"breaks":true,"smartLists":true,"smartypants":true},"server":{"log":false,"ip":"0.0.0.0"},"since":2015,"favicon":"/favicon.ico","rss":"default","menu":{"Home":"/","Archives":"/archives/","Tags":"/tags","Categories":"/categories"},"color":"Default","toc":true,"fancybox":true,"pjax":true,"copyright":{"enable":true,"origin":"http://yoyoyohamapi.me","license":"本文采用<a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc/4.0/\" target=\"_blank\">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可"},"reward":{"enable":true,"qrCode":{"wechat":null,"alipay":null}},"social":{"email":"softshot37@gmail.com","stack-overflow":null,"twitter":null,"facebook":null,"linkedin":null,"google":null,"github":"https://github.com/yoyoyohamapi","weibo":null,"zhihu":"https://www.zhihu.com/people/wu-xiao-jun-64-55/activities","pocket":null,"tumblr":null,"instagram":null},"leancloud":{"app_id":null,"app_key":null},"baidu_analytics":null,"baidu_verification":null,"google_analytics":null,"google_verification":null,"disqus_shortname":"yoyoyohamapi","version":"2.9.0"};
</script>

    <title> 更好用的 Redux - 吴小蛆的巣 </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">吴小蛆的巣</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            首页
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            归档
          
        </li>
      </a>
    
      <a href="/tags">
        <li class="mobile-menu-item">
          
          
            标签
          
        </li>
      </a>
    
      <a href="/categories">
        <li class="mobile-menu-item">
          
          
            分类
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">吴小蛆的巣</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              首页
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              归档
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            
            
              标签
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/categories">
            
            
              分类
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          更好用的 Redux
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-09-04
        </span>
        
          <div class="post-category">
            
              <a href="/categories/React/">React</a>
            
          </div>
        
        
      </div>
    </header>

    
    
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么我们需要-Redux？"><span class="toc-text">为什么我们需要 Redux？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不完美的-Redux"><span class="toc-text">不完美的 Redux</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#怎么用好-Redux"><span class="toc-text">怎么用好 Redux</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#组件的样子"><span class="toc-text">组件的样子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#应用的样子"><span class="toc-text">应用的样子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#应用划分"><span class="toc-text">应用划分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#约定-——-打掉样板代码"><span class="toc-text">约定 —— 打掉样板代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#异步任务的组织"><span class="toc-text">异步任务的组织</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#处理加载态与错误态"><span class="toc-text">处理加载态与错误态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#响应式的服务治理"><span class="toc-text">响应式的服务治理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#reobservable"><span class="toc-text">reobservable</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考资料"><span class="toc-text">参考资料</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#关于本系列"><span class="toc-text">关于本系列</span></a></li></ol>
    </div>
  </div>



    <div class="post-content">
      
        <p><img src="/2018/09/04/更好用的_Redux/cover.png" alt="cover"></p>
<blockquote>
<p>本文是 《使用 RxJS + Redux 管理应用状态》系列第三篇文章，将介绍我们在使用 Redux 时的困惑，如何重新思考 Redux 定下的范式，以及我们能为此做出的努力。返回第一篇：<a href="http://yoyoyohamapi.me/2018/08/18/%E4%BD%BF%E7%94%A8_redux-observable_%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6%E8%87%AA%E6%B2%BB/">使用 redux-observable 实现组件自治</a></p>
<p>本系列的文章地址汇总：</p>
<ul>
<li><a href="http://yoyoyohamapi.me/2018/08/18/%E4%BD%BF%E7%94%A8_redux-observable_%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6%E8%87%AA%E6%B2%BB/">使用 redux-observable 实现组件自治</a></li>
<li><a href="http://yoyoyohamapi.me/2018/08/21/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA_redux-observable/">如何实现一个 redux-observable</a></li>
<li><a href="http://yoyoyohamapi.me/2018/09/04/%E6%9B%B4%E5%A5%BD%E7%94%A8%E7%9A%84_Redux/">更好用的 Redux</a></li>
</ul>
</blockquote>
<a id="more"></a>
<h2 id="为什么我们需要-Redux？"><a href="#为什么我们需要-Redux？" class="headerlink" title="为什么我们需要 Redux？"></a>为什么我们需要 Redux？</h2><p>首先要明确的是，Redux 并不是 React 独有的一个插件，它是顺应前端组件化开发潮流而诞生的一种状态管理模型，你在 Vue 或者 Angular 中也可以使用这个模型。</p>
<p>目前，大家都比较认可的是，某一时刻的应用或者组件状态，将对应此时应用或者组件的 UI：</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">UI = f(<span class="keyword">state</span>)</span><br></pre></td></tr></table></figure>
<p>那么，在前端组件化开发的时候，就需要思考两个问题：</p>
<ol>
<li><strong> 状态来源 </strong></li>
<li><strong> 状态管理 </strong></li>
</ol>
<p>组件所具有的状态，一搬来源于两个方面：</p>
<ol>
<li><strong> 自身具有的状态 </strong>：例如一个 Button 组件自身含有一个计数状态 count，表示自己被点击的次数。</li>
<li><strong> 外部注入的状态 </strong>：例如一个 Modal 组件，就需要由外部注入一个是否显示的状态 visible。React 将外部注入的状态称为 <strong>props</strong>。</li>
</ol>
<p>状态源为组件输送了其需要的状态，进而，组件的外观形态也得到了确认。在简单工程和简单组件中，我们思考了状态来源也就行了，如果引入额外的状态管理方案（例如我们为一个使用 Redux 管理一个按钮组件的状态），反而会加重每个组件的负担，造成了多余的抽象和依赖。</p>
<p>而对于 <strong> 大型前端工程 </strong> 和复杂组件来说，其往往具有如下特点：</p>
<ol>
<li><strong> 数据复杂 </strong></li>
<li><strong> 组件丰富 </strong></li>
</ol>
<p>在这种场景下，朴素的状态管理就显得捉襟见肘了，主要体现在下面几个方面：</p>
<ol>
<li>当组件 <strong> 层级过深 </strong> 时，如何优雅得呈递组件需要的状态，或者说组件如何更方便取得自己需要的状态</li>
<li>如何 <strong> 回溯 </strong> 到某个状态</li>
<li>如何更好的 <strong> 测试 </strong> 状态管理</li>
</ol>
<p>Redux 正是要去解决这些问题，从而让大型前端工程的状态更加可控。Redux 提出了一套约定模型，让状态的更新和派发都集中了：</p>
<p><img src="/2018/09/04/更好用的_Redux/redux.png" alt="redux"></p>
<p>Redux 所使用的模型是受到了 Elm 的启发：</p>
<p><img src="/2018/09/04/更好用的_Redux/elm.png" alt="Elm 架构"></p>
<p>在 Elm 中，流动于应用中的是 <strong> 消息（msg）</strong> ：一个由 <strong> 消息类型（type）</strong> 所标识，并且携带了 <strong> 内容（payload）</strong> 的数据结构。消息决定了数据模型（<strong>model</strong>）怎么更新，而数据又决定了 UI 形态。</p>
<p>而在 Redux 中，消息被称替代为 <strong> 动作（action）</strong>，并且使用 <strong>reducer</strong> 来描述状态随行为的变迁。另外，与 Elm 不同的是，Redux 专注于状态管理，而不再处理视图（View），因此 ，Redux 也不是分型的（关于分型架构的介绍，可以看 的 <a href="https://staltz.com/unidirectional-user-interface-architectures.html" target="_blank" rel="noopener">博文</a>）。</p>
<p>在了解到 Redux 的利好，或者被 Redux 的流行所吸引后，我们引入 Redux 作为应用的状态管理器，这让整个应用的状态变动都变得无比清晰，状态在一条链路上涌动，我们甚至可以回到或者前进到某个状态。然而，Redux 就真的完美无缺吗？</p>
<h2 id="不完美的-Redux"><a href="#不完美的-Redux" class="headerlink" title="不完美的 Redux"></a>不完美的 Redux</h2><p>Redux 当然不完美，它最困扰我们的就是下面两个方面：</p>
<ol>
<li>啰嗦的样板代码</li>
<li>低下的异步任务处理能力</li>
</ol>
<p>假定前端需要从服务端拉取一些数据并进行展示，在 Redux 的模式下，完成从数据拉取到状态更新，就需要经历：</p>
<p>（1）定义若干的 <strong>action type</strong>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> FETCH_START = <span class="string">'FETCH_START'</span></span><br><span class="line"><span class="keyword">const</span> FETCH_SUCCESS = <span class="string">'FETCH_SUCCESSE'</span></span><br><span class="line"><span class="keyword">const</span> FETCH_ERROR = <span class="string">'FETCH_ERROR'</span></span><br></pre></td></tr></table></figure>
<p>（2）定义若干 <strong>action creator</strong>，这里假定我们使用 redux-thunk 驱动异步任务：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fetchSuccess = <span class="function"><span class="params">data</span> =&gt;</span> (&#123;</span><br><span class="line">  type: FETCH_START,</span><br><span class="line">  payload: &#123; data &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fetchError = <span class="function"><span class="params">error</span> =&gt;</span> (&#123;</span><br><span class="line">  type: FETCH_ERROR,</span><br><span class="line">  payload: &#123; error &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fetchData = <span class="function">(<span class="params">params</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">dispatch, getState</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> api.fetch(params)</span><br><span class="line">      .then(fetchSuccess)</span><br><span class="line">    	.catch(fetchError)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（3）在 <strong>reducer</strong> 中，对不同 action type，通过 switch-case 声明不同的状态更新方式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state = initialState, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; type, payload &#125; = action</span><br><span class="line">  <span class="keyword">switch</span>(action.type)&#123;</span><br><span class="line">    <span class="keyword">case</span> FETCH_START: &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, <span class="attr">loading</span>: <span class="literal">true</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> FETCH_SUCCESS: &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, <span class="attr">loading</span>: <span class="literal">false</span>, <span class="attr">data</span>: payload.data &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> FETCH_ERROR: &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, <span class="attr">loading</span>: <span class="literal">false</span>, <span class="attr">data</span>: <span class="literal">null</span>, <span class="attr">error</span>: payload.error&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个流程带来的问题是：</p>
<ol>
<li><strong> 个人开发不够专注 </strong>：工程中，我们是 <strong> 分散管理 </strong> action type、action 及 reducer 的，走完一套流程，需要在当中不停的跳跃，思路不够集中。</li>
<li><strong> 多人协作不够高效 </strong>：同样是因为 action type、action 及 reducer 的分散，多人协作时就会出现名字冲突，相似业务的流程重复等问题。这对我们的应用状态设计提出了比较高的要求。优秀的设计是状态易于定位，变迁流程清晰，无冗余状态，而低下的设计就会让状态膨胀难于定位，变迁流程错综复杂，冗余状态随处可见。</li>
</ol>
<h2 id="怎么用好-Redux"><a href="#怎么用好-Redux" class="headerlink" title="怎么用好 Redux"></a>怎么用好 Redux</h2><p>当我们受困于 Redux 的负面影响时，切到其他的状态管理方案（例如 <a href="https://github.com/mobxjs/mobx" target="_blank" rel="noopener">mobx</a> 或者 <a href="https://github.com/mobxjs/mobx-state-tree" target="_blank" rel="noopener">mobx-state-stree）</a>，也不太现实，一方面是迁移成本大，一方面你也不知道新的状态管理方案是否就是银弹。但是，对 Redux 的负面影响无动于衷或者忍气吞声，也只会让问题越滚越大，直到失控。</p>
<p>在开始讨论如何更好地 Redux 之前，我们需要明确一点，样板代码和异步能力的缺乏，<strong> 是 Redux 自身设计的结果，而非目的 </strong>，换句话说，Redux 设计出来，并不是要让开发者去撰写样本代码，或者去纠结怎么处理异步状态更新。</p>
<p>我们需要再定义一个角色，让他来代替我们去写样板代码，让他给予我们最优秀的异步任务处理能力，让他负责一切 Redux 中恶心的事儿。因此，这个角色就是一个让 Redux 变得更加优雅的框架，至于如何创建这个角色，需要我们从单个组件开始，重新梳理下应用形态，并着眼于：</p>
<ol>
<li>如何打掉 Redux 的样板代码</li>
<li>如何更优雅地处理异步任务</li>
</ol>
<h3 id="组件的样子"><a href="#组件的样子" class="headerlink" title="组件的样子"></a>组件的样子</h3><p>一个组件的生态大概是这样的：</p>
<p><img src="/2018/09/04/更好用的_Redux/component.png" alt=""></p>
<p>即：<strong> 数据经处理形成页面状态，页面状态决定  UI 渲染 </strong>。</p>
<h3 id="应用的样子"><a href="#应用的样子" class="headerlink" title="应用的样子"></a>应用的样子</h3><p>而组件生态（UI + 状态 + 状态管理方式）的组合就构成了我们应用：</p>
<p><img src="/2018/09/04/更好用的_Redux/components.png" alt="生态组合"></p>
<p>这里组件生态特意只展示了 <strong> 数据到状态 </strong> 这一步，因为 Redux 处理的正是这个部分。我们暂且可以定义数据到状态的过程为 <strong>flow</strong>，即一个业务流的意思。</p>
<h3 id="应用划分"><a href="#应用划分" class="headerlink" title="应用划分"></a>应用划分</h3><p>借鉴于 Elm，我们可以按数据模型对应用进行划分：</p>
<p><img src="/2018/09/04/更好用的_Redux/architecture.png" alt="应用划分"></p>
<p>其中，模型具有的属性有：</p>
<ul>
<li><code>name</code>: 模型名称</li>
<li><code>state</code>：模型的初始状态</li>
<li><code>reducers</code>：处理当前模型状态的 state</li>
<li><code>selectors</code>：服务于当前模型的 state selectors</li>
<li><code>flows</code>：当前模型涉及的业务流（副作用）</li>
</ul>
<blockquote>
<p>这个经典的划分模型正是 <a href="https://github.com/dvajs/dva" target="_blank" rel="noopener">Dva</a> 的应用划分手段，只是模型属性略有不同。</p>
</blockquote>
<p>假定我们创建了 user 模型和 post 模型，那么框架将挂载他们的状态到 user 和 post 状态子树下：</p>
<p><img src="/2018/09/04/更好用的_Redux/model_state_tree.png" alt=""></p>
<h3 id="约定-——-打掉样板代码"><a href="#约定-——-打掉样板代码" class="headerlink" title="约定 —— 打掉样板代码"></a>约定 —— 打掉样板代码</h3><p>有了模型这个概念后，框架就能定义一系列的约定去减少样板代码的书写。首先，我们回顾下以前我们是怎么定义的一个 action type 的：</p>
<ul>
<li>action 名称</li>
<li>指定一个 namespace 防止名字冲突</li>
</ul>
<p>例如，我们这样定义用户数据拉取相关的 action type：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> FETCH = <span class="string">'USRE/FETCH'</span></span><br><span class="line"><span class="keyword">const</span> FETCH_SUCCESS = <span class="string">'USER/FETCH_SUCCESSE'</span></span><br><span class="line"><span class="keyword">const</span> FETCH_ERROR = <span class="string">'USER/FETCH_ERROR'</span></span><br></pre></td></tr></table></figure>
<p>其中， <code>FETCH</code> 对应的是一个 <strong> 异步 </strong> 拉取数据的 action，<code>FETCH_SUCCESS</code> 和 <code>FETCH_ERROR</code> 则对应两个 <strong> 同步 </strong> 修改状态的 action。</p>
<p><strong> 同步 action 约定 </strong></p>
<p>对于同步的、不包含副作用的 action，我们直接将其呈递到 reducer，是不会破坏 reducer 纯度的。 因此，我们不妨约定： model 下 reducer 的 <strong> 名字 </strong> 映射一个直接对状态操作的 action type：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">SYNC_ACTION_TYPE</span> = MODEL_NAME/REDUCER_NAME</span><br></pre></td></tr></table></figure>
<p>例如下面这个 user model：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> userModel = &#123;</span><br><span class="line">  name: <span class="string">'user'</span>,</span><br><span class="line">  state: &#123;</span><br><span class="line">    list: [],</span><br><span class="line">    total: <span class="number">0</span>,</span><br><span class="line">    loading: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  reducers: &#123;</span><br><span class="line">    fetchStart(state, payload) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, <span class="attr">loading</span>:<span class="literal">true</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们派发了一个类型为 <code>user/fetchStart</code> 的 action 之后，action 就带着其 payload 进入到 <code>user.fetchStart</code> 这个 reducer 下，进行状态变更。</p>
<p><strong> 异步 action 约定 </strong></p>
<p>对于异步的 action，我们就不能直接在 reducer 进行异步任务处理，而 model 中的 flow 就是异步任务的集装箱：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ASYNC_ACTION_TYPE = MODEL_NAME/FLOW_NAME</span><br></pre></td></tr></table></figure>
<p>例如下面这个 model：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  name: <span class="string">'user'</span>,</span><br><span class="line">  state: &#123;</span><br><span class="line">    list: [],</span><br><span class="line">    total: <span class="number">0</span>,</span><br><span class="line">    loading: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  flows: &#123;</span><br><span class="line">    fetch() &#123;</span><br><span class="line">      <span class="comment">// ... 处理一些异步任务 </span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们在 UI 里面发出了个 <code>user/fetch</code>，由于 user model 中存在一个名为 fetch 的 flow，那么就进入到这个 flow 中进行异步任务的处理。</p>
<p><strong> 状态的覆盖与更新 </strong></p>
<p>如果每个状态的更新都去撰写一个对应的 reducer 就太累了，因此，我们可以考虑为每个模型定义一个 change reducer，用于 <strong> 直接 </strong> 更新状态：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> userModel = &#123;</span><br><span class="line">  name: <span class="string">'user'</span>,</span><br><span class="line">  state: &#123;</span><br><span class="line">    list: [],</span><br><span class="line">    pagination: &#123;</span><br><span class="line">      page: <span class="number">1</span>,</span><br><span class="line">      total: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    loading: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  reducers: &#123;</span><br><span class="line">    change(state, action) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, ...action.payload &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，当我们派发了下面的一个 action，就将能够将 <code>loading</code> 状态置为 true：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">dispatch(&#123;</span><br><span class="line">  type: <span class="string">'user/change'</span>,</span><br><span class="line">  payload: &#123;</span><br><span class="line">    loading: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>但是，这种更新是 <strong> 覆盖式 </strong> 的，假定我们想要更新状态中的当前页面信息：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">dispatch(&#123;</span><br><span class="line">  type: <span class="string">'user/change'</span>,</span><br><span class="line">  payload: &#123;</span><br><span class="line">    pagination: &#123; <span class="attr">page</span>: <span class="number">1</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>状态就会变为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  list: [],</span><br><span class="line">  pagination: &#123;</span><br><span class="line">  	page: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  loading: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>pagination</code> 状态被整个覆盖掉了，其中的总数状态 <code>total</code> 就丢失了。</p>
<p>因此，我们还要定义一个 patch reducer，意为对状态的 <strong> 补丁更新 </strong>，它只会影响到 action payload 中声明的子状态：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; merge &#125; <span class="keyword">from</span> <span class="string">'lodash.merge'</span></span><br><span class="line"><span class="keyword">const</span> userModel = &#123;</span><br><span class="line">  name: <span class="string">'user'</span>,</span><br><span class="line">  state: &#123;</span><br><span class="line">    list: [],</span><br><span class="line">    pagination: &#123;</span><br><span class="line">      page: <span class="number">1</span>,</span><br><span class="line">      total: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    loading: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  reducers: &#123;</span><br><span class="line">    change(state, action) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        &#123; ...state, ...action.payload &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    patch(state, action) &#123;</span><br><span class="line">      <span class="keyword">return</span> deepMerge(state, action.payload)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们尝试只更新分页：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">dispatch(&#123;</span><br><span class="line">  type: <span class="string">'user/patch'</span>,</span><br><span class="line">  payload: &#123;</span><br><span class="line">    pagination: &#123; <span class="attr">page</span>: <span class="number">1</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>新的状态就是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  list: [],</span><br><span class="line">  pagination: &#123;</span><br><span class="line">  	page: <span class="number">1</span>,</span><br><span class="line">    total: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  loading: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：这里的实现不是生产环境的实现，直接使用 lodash 的 merge 是不够的，实际项目中还要进行一定改造。</p>
</blockquote>
<h3 id="异步任务的组织"><a href="#异步任务的组织" class="headerlink" title="异步任务的组织"></a>异步任务的组织</h3><p>Dva 使用了 redux-saga 进行副作用（主要是异步任务）的组织，Rematch 则使用了 async/await 进行组织。从长期的实践来看，我更偏向于使用 redux-observable，尤其是在其 1.0 版本的发布之后，更是带来了可观察的 <code>state$</code>，使得我们能更加透彻地实践响应式编程。我们回顾下前文中提到的该模式的好处：</p>
<ul>
<li>统一数据源，observable 之间可组合</li>
<li>声明式编程，代码直爽简洁</li>
<li>优秀的竞态处理能力</li>
<li>测试友好</li>
<li>便于实现组件自治</li>
</ul>
<p>因此，对于模型异步任务的处理，我们选择 redux-observable：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> user:Model&lt;UserState&gt; = &#123;</span><br><span class="line">  name: <span class="string">'user'</span>,</span><br><span class="line">  state: &#123;</span><br><span class="line">    list: [],</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  reducers: &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  flows: &#123;</span><br><span class="line">    fetch(flow$, action$, state$) &#123;</span><br><span class="line">      <span class="comment">// ....</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与 epic 的函数签名略有不同的是，每个 flow 多了一个 <code>flow$</code> 参数，以上例来说，它就相当于：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">action$.ofType(<span class="string">'user/fetch'</span>)</span><br></pre></td></tr></table></figure>
<p>这个参数便于我们更快的取到需要的 action。</p>
<h3 id="处理加载态与错误态"><a href="#处理加载态与错误态" class="headerlink" title="处理加载态与错误态"></a>处理加载态与错误态</h3><p>前端工程中经常会有错误展示和加载展示的需求，</p>
<p><img src="/2018/09/04/更好用的_Redux/loading&amp;error.png" alt="loading 与 error"></p>
<p>如果我们手动管理每个模型的加载态和错误态就太麻烦了，因此在根状态下，单独划分两棵状态子树用于处理加载态与错误态，这样，便于框架去治理加载与错误，开发者直接在状态树上取用即可：</p>
<ul>
<li>loading </li>
<li>error</li>
</ul>
<p><img src="/2018/09/04/更好用的_Redux/state_tree.png" alt=""></p>
<p>如图，加载态和错误态还需要根据粒度进行划分，有大粒度的 flow 级别，用于标识一个 flow 是否正在进行中；也有小粒度的 service 级别，用于标识某个异步服务是否在进行中。</p>
<p>例如，若：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">loading.flows[<span class="string">'user/fetch'</span>] === <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>即表示 user model 下的 <code>fetch</code> flow 正在进行中。</p>
<p>若：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">loading.services[<span class="string">'/api/fetchUser'</span>] === <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>即表示 <code>/api/fetchUser</code> 这个服务正在进行中。</p>
<h3 id="响应式的服务治理"><a href="#响应式的服务治理" class="headerlink" title="响应式的服务治理"></a>响应式的服务治理</h3><p>前端调用后端服务操纵数据是一个广泛的需求，因此，我们还希望所谓的中间角色（框架）能够在我们的业务流中注入服务，完成服务和应用状态的交互：观察调用状况，自动捕获调用异常，适时地修改应用 loading 态和 error 态，方便用户直接在顶层状态取用服务运行状况。</p>
<p>另外，在响应式编程的范式下，框架提供的服务治理，在处理服务的成功和错误时应该也是响应式的，即成功和错误将是预定义的流（observable 对象），从而让开发者能更好的利用到响应式编程的能力：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> user:Model&lt;UserState&gt; = &#123;</span><br><span class="line">  name: <span class="string">'user'</span>,</span><br><span class="line">  state: &#123;</span><br><span class="line">    list: [],</span><br><span class="line">    total: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  reducers: &#123;</span><br><span class="line">    fetchSuccess(state, payload) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, list: payload.list, total: payload.total &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    fetchError(state, payload) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, list:&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  flows: &#123;</span><br><span class="line">    fetch(flow$, action$, state$, dependencies) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; service &#125; = dependencies</span><br><span class="line">      <span class="keyword">return</span> flow$.pipe(</span><br><span class="line">        withLatestFrom(state$, <span class="function">(<span class="params">action, state</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 拼装请求参数 </span></span><br><span class="line">          <span class="keyword">return</span> params</span><br><span class="line">        &#125;),</span><br><span class="line">        switchMap(<span class="function"><span class="params">params</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> [success$, error$] = service(getUsers(params))</span><br><span class="line">          <span class="keyword">return</span> merge(</span><br><span class="line">            success$.pipe(</span><br><span class="line">              map(<span class="function"><span class="params">resp</span> =&gt;</span> (&#123;</span><br><span class="line">                <span class="keyword">type</span>: <span class="string">'user/fetchSuccess'</span>,</span><br><span class="line">                payload: &#123;</span><br><span class="line">                  list: resp.list,</span><br><span class="line">                  total: resp.total</span><br><span class="line">                &#125;</span><br><span class="line">            	&#125;))</span><br><span class="line">            ),</span><br><span class="line">            error$.pipe(</span><br><span class="line">              map(<span class="function"><span class="params">error</span> =&gt;</span> (&#123;</span><br><span class="line">              	<span class="keyword">type</span>: <span class="string">'user/fetchError'</span></span><br><span class="line">            	&#125;))</span><br><span class="line">            )</span><br><span class="line">          )</span><br><span class="line">        &#125;)</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="reobservable"><a href="#reobservable" class="headerlink" title="reobservable"></a>reobservable</h2><p>上面的种种思考，概括下来其实就是 Dva architecture + redux-observable，前者能够打掉 Redux 冗长啰嗦的样板代码，后者则负责异步任务治理。</p>
<p>比较遗憾的是，Dva 没有使用 redux-observable 进行副作用管理，也没有相关插件实现使用 redux-observable 或者 RxJS 进行副作用管理，并且，通过 Dva 暴露的 hook 去实现一个 redux-observable 的 Dva 中间件也颇为不畅，因此，笔者尝试撰写了一个 <a href="https://github.com/reobservable/reobservable" target="_blank" rel="noopener">reobservable</a> 来实现上面提到框架，它与 Dva 不同的是：</p>
<ol>
<li>只关注应用状态，不涉及组件路由的其他生态</li>
<li>集成 loading 和 error 处理</li>
<li>使用 redux-observable 而不是 redux-saga 处理副作用</li>
<li>响应式的服务处理，支持应用自定义服务细节</li>
</ol>
<p>如果你的应用使用了 Redux，你苦于 Redux 种种负面影响，并且你还是一个响应式编程和 RxJS 的爱好者，你可以尝试下 reobservable。但是如果你偏爱 saga，或者 async await，你还是应该选择 Dva 或者 Rematch，术业有专攻。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://hackernoon.com/redesigning-redux-b2baee8b8a38" target="_blank" rel="noopener">Redesigning Redux</a></li>
<li><a href="https://guide.elm-lang.org/architecture/" target="_blank" rel="noopener">The Elm Architecture</a></li>
<li><a href="https://staltz.com/unidirectional-user-interface-architectures.html" target="_blank" rel="noopener">UNIDIRECTIONAL USER INTERFACE ARCHITECTURES</a></li>
</ul>
<h2 id="关于本系列"><a href="#关于本系列" class="headerlink" title="关于本系列"></a>关于本系列</h2><ul>
<li>本系列将从介绍 redux-observable 1.0 开始，阐述自己在结合 RxJS 到 Redux 中的心得体会。涉及内容会有 redux-observable 实践介绍，redux-observable 实现原理探究，最后会介绍下自己当前基于 redux-observble + dva architecture 的一个 state 管理框架 reobservable。</li>
<li>本系列不是 RxJS 或者 Redux 入门，不再讲述他们的基础概念，宣扬他们的核心优势。如果你搜索 RxJS 不小心进到了这个系列，对 RxJS 和 FRP 程序设计产生了兴趣，那么入门我会推荐：<ul>
<li><a href="https://www.learnrxjs.io/" target="_blank" rel="noopener">learnrxjs.io</a></li>
<li>Andre Staltz 在 <a href="https://egghead.io/courses/introduction-to-reactive-programming" target="_blank" rel="noopener">egghead.io</a> 上的一系列课程</li>
<li>程墨的 <a href="https://item.jd.com/12336101.html" target="_blank" rel="noopener">《深入浅出 RxJS》</a></li>
</ul>
</li>
<li>本系列更不是教程，只是介绍自己在 Redux 中应用 RxJS 的一些思路，希望更多人能指出当中存在的误区，或者交流更优雅的实践。</li>
<li>由衷的感谢实践路上一些师兄的帮助，尤其感谢腾讯云的 questguo 学长在模式上的指导。reobservable 脱胎于腾讯云 questguo 主导的 React 框架 —— TCFF，期待未来 TCFF 的开源。</li>
<li>感谢小雨的设计支援。</li>
</ul>

      
    </div>

    
      
      

  <div class="post-copyright">
    <p class="copyright-item">
      <span>原文作者: </span>
      <a href="http://yoyoyohamapi.me">吴晓军</a>
    </p>
    <p class="copyright-item">
      <span>原文链接: </span>
      <a href="http://yoyoyohamapi.me/2018/09/04/更好用的_Redux/">http://yoyoyohamapi.me/2018/09/04/更好用的_Redux/</a>
    </p>
    <p class="copyright-item">
      <span>许可协议: </span>
      
      本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可
    </p>
  </div>



      
      
  <div class="post-reward">
    <input type="checkbox" name="reward" id="reward" hidden />
    <label class="reward-button" for="reward">赞赏支持</label>
    <div class="qr-code">
      
      
      
    </div>
  </div>

    

    
      <footer class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/React/">React</a>
            
              <a href="/tags/Redux/">Redux</a>
            
              <a href="/tags/RxJS/">RxJS</a>
            
          </div>
        
        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2018/12/16/Cycle.js_的状态管理模型/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">Cycle.js 状态管理模型</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/2018/08/21/实现一个_redux-observable/">
        <span class="next-text nav-default">如何实现一个 redux-observable</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

      </footer>
    

  </article>


          </div>
          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:softshot37@gmail.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
        
          <a href="https://github.com/yoyoyohamapi" class="iconfont icon-github" title="github"></a>
        
      
    
      
    
      
        
          <a href="https://www.zhihu.com/people/wu-xiao-jun-64-55/activities" class="iconfont icon-zhihu" title="zhihu"></a>
        
      
    
      
    
      
    
      
    
    
    
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>


<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2015 - 
    
    2019

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">吴晓军</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    
  
  <script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://yoyoyohamapi.me/2018/09/04/更好用的_Redux/';
        this.page.identifier = '2018/09/04/更好用的_Redux/';
        this.page.title = '更好用的 Redux';
    };
    (function() {
    var d = document, s = d.createElement('script');

    s.src = '//yoyoyohamapi.disqus.com/embed.js';

    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();  
  </script>

  

  



    
  



  
  





  
    <script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  

  
    <script type="text/javascript" src="/lib/pjax/jquery.pjax.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/nprogress/nprogress.min.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.9.0"></script>

  <!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</body>
</html>
