<!DOCTYPE html>
<html lang="">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="Cycle.js 状态管理模型"/>




  <meta name="keywords" content="JavaScript, 函数式编程, Cycle.js, 吴小蛆的巣" />










  <link rel="alternate" href="/atom.xml" title="吴小蛆的巣">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.9.0" />



<link rel="canonical" href="http://yoyoyohamapi.me/2018/12/16/Cycle.js_的状态管理模型/"/>



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />




  <link rel="stylesheet" type="text/css" href="/lib/nprogress/nprogress.min.css" />



<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.9.0" />



  



  <script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>








<script>
  window.config = {"title":"吴小蛆的巣","subtitle":null,"description":"只要努力，蛆虫也能变成苍蝇翱翔于天际","author":"吴晓军","language":null,"timezone":null,"url":"http://yoyoyohamapi.me","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":true,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":true,"line_number":false,"tab_replace":"  "},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"page","theme":"even","deploy":{"type":"git","repo":"https://github.com/yoyoyohamapi/yoyoyohamapi.github.io.git","branch":"master"},"ignore":[],"math":{"engine":"mathjax"},"sitemap":{"path":"sitemap.xml"},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"feed":{"type":"atom","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"atom.xml"},"index_generator":{"per_page":10},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"sanitize":false,"tables":true,"breaks":true,"smartLists":true,"smartypants":true},"server":{"log":false,"ip":"0.0.0.0"},"since":2015,"favicon":"/favicon.ico","rss":"default","menu":{"Home":"/","Archives":"/archives/","Tags":"/tags","Categories":"/categories"},"color":"Default","toc":true,"fancybox":true,"pjax":true,"copyright":{"enable":true,"origin":"http://yoyoyohamapi.me","license":"本文采用<a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc/4.0/\" target=\"_blank\">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可"},"reward":{"enable":true,"qrCode":{"wechat":null,"alipay":null}},"social":{"email":"softshot37@gmail.com","stack-overflow":null,"twitter":null,"facebook":null,"linkedin":null,"google":null,"github":"https://github.com/yoyoyohamapi","weibo":null,"zhihu":"https://www.zhihu.com/people/wu-xiao-jun-64-55/activities","pocket":null,"tumblr":null,"instagram":null},"leancloud":{"app_id":null,"app_key":null},"baidu_analytics":null,"baidu_verification":null,"google_analytics":null,"google_verification":null,"disqus_shortname":"yoyoyohamapi","version":"2.9.0"};
</script>

    <title> Cycle.js 状态管理模型 - 吴小蛆的巣 </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">吴小蛆的巣</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            首页
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            归档
          
        </li>
      </a>
    
      <a href="/tags">
        <li class="mobile-menu-item">
          
          
            标签
          
        </li>
      </a>
    
      <a href="/categories">
        <li class="mobile-menu-item">
          
          
            分类
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">吴小蛆的巣</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              首页
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              归档
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            
            
              标签
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/categories">
            
            
              分类
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          Cycle.js 状态管理模型
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-12-16
        </span>
        
          <div class="post-category">
            
              <a href="/categories/Cycle-js/">Cycle.js</a>
            
          </div>
        
        
      </div>
    </header>

    
    
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#分形（fractal）"><span class="toc-text">分形（fractal）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cycle-js"><span class="toc-text">Cycle.js</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cycle-js-的状态管理"><span class="toc-text">Cycle.js 的状态管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#响应式"><span class="toc-text">响应式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#初始化状态"><span class="toc-text">初始化状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用洋葱模型传递状态"><span class="toc-text">使用洋葱模型传递状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用-Lens-机制传递状态"><span class="toc-text">使用 Lens 机制传递状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#处理动态列表"><span class="toc-text">处理动态列表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考资料"><span class="toc-text">参考资料</span></a></li></ol>
    </div>
  </div>



    <div class="post-content">
      
        <h2 id="分形（fractal）"><a href="#分形（fractal）" class="headerlink" title="分形（fractal）"></a>分形（fractal）</h2><p>当今前端领域，最流行的状态管理模型毫无疑问是 redux，但遗憾的是，redux 并不是一个分形架构。什么是分形架构：</p>
<blockquote>
<p>如果子组件能够以同样的结构，作为一个应用使用，这样的结构就是分形架构。</p>
</blockquote>
<a id="more"></a>
<p>在分形架构下，每个应用都组成为更大的应用使用，而在非分形架构下，应用往往依赖于一个统揽全局的 <strong> 协调器（orchestrators）</strong>，各个组件并不能以同样的结构当做应用使用，而是统一接收这个协调器协调。例如，redux 只是聚焦于状态管理，而不涉及组件的视图实现，无法构成一个完整的应用闭环，因此 redux 不是一个分形架构，在 redux 中，协调器就是全局 <code>Store</code> 。</p>
<p><img src="https://staltz.com/img/redux-unidir-ui-arch.jpg" alt="Redux diagram"></p>
<p>我们再看下 redux 灵感来源 —— Elm：</p>
<p><img src="https://staltz.com/img/mvu-unidir-ui-arch.jpg" alt="Model-View-Update diagram"></p>
<p>在 Elm 架构下，每个组件都有一个完整的应用闭环：</p>
<ul>
<li>一个 Model 类型</li>
<li>一个 Model 的初始实例</li>
<li>一个 View 函数</li>
<li>一个 Action type 以及对应的更新函数</li>
</ul>
<p>因此，Elm 就是分形架构的，每个 Elm 组件也是一个 Elm 应用。</p>
<h2 id="Cycle-js"><a href="#Cycle-js" class="headerlink" title="Cycle.js"></a>Cycle.js</h2><p>分形架构的好处显而易见，就是复用容易，组合方便，Cycle.js 推崇的也是分形架构。其将应用抽象为了一个纯函数 <code>main(sources)</code>，该函数接收一个 <code>sources</code> 参数，用来从外部环境获得诸如 DOM、HTTP 这样的副作用，再输出对应的 <code>sinks</code> 去影响外部环境。</p>
<p><img src="https://cycle.js.org/img/cycle-nested-frontpage.svg" alt="img"></p>
<p>基于这种简单而直接的抽象，Cycle.js 容易做到分形，即每个 Cycle.js 应用（每个 <code>main</code> 函数）可以组合为更大的 Cycle.js 应用：</p>
<p><img src="https://cycle.js.org/img/nested-components.svg" alt="nested components"> 在分形体系下，通过 <code>run</code> API，能驱动任何 Cycle.js 应用运行，无论它是一个简单的 Cycle.js 应用，还是一个嵌套复合的 Cycle.js 应用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;run&#125; <span class="keyword">from</span> <span class="string">'@cycle/run'</span></span><br><span class="line"><span class="keyword">import</span> &#123;div, label, input, hr, h1, makeDOMDriver&#125; <span class="keyword">from</span> <span class="string">'@cycle/dom'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params">sources</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> input$ = sources.DOM.select(<span class="string">'.field'</span>).events(<span class="string">'input'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> name$ = input$.map(<span class="function"><span class="params">ev</span> =&gt;</span> ev.target.value).startWith(<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> vdom$ = name$.map(<span class="function"><span class="params">name</span> =&gt;</span></span><br><span class="line">    div([</span><br><span class="line">      label(<span class="string">'Name:'</span>),</span><br><span class="line">      input(<span class="string">'.field'</span>, &#123;<span class="attr">attrs</span>: &#123;<span class="attr">type</span>: <span class="string">'text'</span>&#125;&#125;),</span><br><span class="line">      hr(),</span><br><span class="line">      h1(<span class="string">'Hello '</span> + name),</span><br><span class="line">    ])</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">DOM</span>: vdom$ &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(main, &#123; <span class="attr">DOM</span>: makeDOMDriver(<span class="string">'#app-container'</span>) &#125;)</span><br></pre></td></tr></table></figure>
<h2 id="Cycle-js-的状态管理"><a href="#Cycle-js-的状态管理" class="headerlink" title="Cycle.js 的状态管理"></a>Cycle.js 的状态管理</h2><h3 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h3><p>上面我们提到，Cycle.js 推崇的是分形应用结构，因此，redux 这样的状态管理器就不是 Cycle.js 愿意使用的，它会让全局只有一个 redux 应用，而不是多个可拆卸的 Cycle.js 分形应用。基于此，若要引入状态管理模型，其设计应当不改变 Cycle.js 应用的基本结构：从外部世界接收 <code>sources</code>，输出 <code>sinks</code> 到外部世界。</p>
<p>另外，由于 Cycle.js 是一个响应式前端框架，那么状态管理仍然保持是响应式的，即以 stream/observable 为基础。如果你熟悉响应式编程，基于 Elm 的理念，以 RxJs 为例，我们可以很轻松的实现一个状态管理模型：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> action$ = <span class="keyword">new</span> Subject()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> incrReducer$ = action$.pipe(</span><br><span class="line">  filter(<span class="function">(<span class="params">&#123;type&#125;</span>) =&gt;</span> type === <span class="string">'INCR'</span>),</span><br><span class="line">  mapTo(<span class="function"><span class="keyword">function</span> <span class="title">incrReducer</span>(<span class="params">state</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> state + <span class="number">1</span></span><br><span class="line">  &#125;)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> decrReducer$ = action$.pipe(</span><br><span class="line">  filter(<span class="function">(<span class="params">&#123;type&#125;</span>) =&gt;</span> type === <span class="string">'DECR'</span>),</span><br><span class="line">  mapTo(<span class="function"><span class="keyword">function</span> <span class="title">decrReducer</span>(<span class="params">state</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> state - <span class="number">1</span></span><br><span class="line">  &#125;)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reducer$ = merge(incrReducer$, decrReducer$)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> state$ = reducer$.pipe(</span><br><span class="line">  scan(<span class="function">(<span class="params">state, reducer</span>) =&gt;</span> reducer(state), initState),</span><br><span class="line">  startWith(initState),</span><br><span class="line">  shareReplay(<span class="number">1</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>基于上述的前提，Cycle.sj 状态管理模型的基础设计也跃然纸上：</p>
<ul>
<li>将状态源 <code>state$</code> 放入 <code>sources</code> 中，输入给 Cycle.js 应用</li>
<li>Cycle.js 应用则将 <strong>reducer$</strong> 放入 <code>sinks</code> 中，输出到外部世界</li>
</ul>
<blockquote>
<p>参看 <a href="https://github.com/cyclejs/cyclejs/blob/master/state/src/withState.ts" target="_blank" rel="noopener"><code>@cycle/state</code> 的 <code>withState</code> 的源码</a>，其响应式状态管理模型实现亦大致如上。</p>
</blockquote>
<p>在实际实现中，Cycle.js 通过 <code>@cycle/state</code> 暴露的 <code>withState</code>  来为 Cycle.js 注入状态管理模型：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;withState&#125; <span class="keyword">from</span> <span class="string">'@cycle/state'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params">sources</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> state$ = sources.state.stream</span><br><span class="line">  <span class="keyword">const</span> vdom$ = state$.map(<span class="function"><span class="params">state</span> =&gt;</span> <span class="comment">/*render virtual DOM*/</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> reducer$ = xs.periodic(<span class="number">1000</span>)</span><br><span class="line">  .mapTo(<span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">prevState</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// return new state</span></span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> sinks = &#123;</span><br><span class="line">    DOM: vdom$,</span><br><span class="line">    state: reducer$</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sinks</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wrappedMain = withState(main)</span><br><span class="line"></span><br><span class="line">run(wrappedMain, drivers)</span><br></pre></td></tr></table></figure>
<p>在思考了如何让 Cycle.js 引入状态管理模型后仍然保持分形后，我们还要再状态管理模型中解决下面这些问题：</p>
<ul>
<li>如何声明应用初始状态</li>
<li>应用如何读取以及修改某个状态</li>
</ul>
<h3 id="初始化状态"><a href="#初始化状态" class="headerlink" title="初始化状态"></a>初始化状态</h3><p>为了遵循响应式，我们可以声明一个 <code>initReducer$</code>，其默认发出一个 <code>initReducer</code>，在这个 reducer 中，直接返回组件的初始状态：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> initReducer$ = xs.of(<span class="function"><span class="keyword">function</span> <span class="title">initReducer</span>(<span class="params">prevState</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">count</span>:<span class="number">0</span> &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reducer$ = xs.merge(initReducer$, someOtherReducer$);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sinks = &#123;</span><br><span class="line">  state: reducer$,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="使用洋葱模型传递状态"><a href="#使用洋葱模型传递状态" class="headerlink" title="使用洋葱模型传递状态"></a>使用洋葱模型传递状态</h3><p>实际项目中，应用总是由多个组件组成，并且组件间还会存在层级关系，因此，还需要思考：</p>
<ol>
<li>怎么传递状态到组件</li>
<li>怎么传递 reducer 到外部</li>
</ol>
<p>假定我们的状态树是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">  visitors: &#123;</span><br><span class="line">    count: <span class="number">300</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假定我们的组件需要 <code>count</code> 状态，就有两种设计思路：</p>
<p>（1）在组件中直接声明要摘取的状态，如何处理子状态变动：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params">sources</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> count$ = sources.state.visitors.count</span><br><span class="line">  <span class="keyword">const</span> reducer$ = incrAction$.mapTo(<span class="function"><span class="keyword">function</span> <span class="title">incr</span>(<span class="params">prevState</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> prevState + <span class="number">1</span></span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">      visitors: &#123;</span><br><span class="line">        count: reducer$</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）保持组件的纯净，其获得的 <code>state$</code> ，输出的 <code>reducer$</code> 不用考虑当前状态树形态，二者都只相对于组件自己：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params">sources</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> state$ = sources.state</span><br><span class="line">  <span class="keyword">const</span> reducer$ = incrAction$.mapTo(<span class="function"><span class="keyword">function</span> <span class="title">incr</span>(<span class="params">prevState</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> prevState + <span class="number">1</span></span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    state: reducer$</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两种方式各有好处，第一种方式更加灵活，适合层级嵌套较深的场景。第二种则让组件逻辑更加内聚，拥有更高的组件自治能力，在简单场景下可能表现得更加直接。这里我们首先探讨第二种传递状态方式。</p>
<p>在第二种状态传递方式下，我们要将 <code>count</code> 传递给对应的组件，就需要 <strong> 从外到内 </strong> 逐层的剥开状态，直到拿到组件需要的状态：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">stateA$ <span class="comment">// Emits object `&#123;visitors: &#123;count: 300&#125;&#125;&#125;`</span></span><br><span class="line">stateB$ <span class="comment">// Emits object `&#123;count: 300&#125;`</span></span><br><span class="line">stateC$ <span class="comment">// Emits object `300`</span></span><br></pre></td></tr></table></figure>
<p>而组件输出 reducer 时，则需要 <strong> 由内到外 </strong> 进行 reduce：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">reducerC$ <span class="comment">// Emits function `count =&gt; count + 1`</span></span><br><span class="line">reducerB$ <span class="comment">// Emits function `visitors =&gt; (&#123;count: reducerC(visitors.count)&#125;)`</span></span><br><span class="line">reducerA$ <span class="comment">// Emits function `appState =&gt; (&#123;visitors: reducerB(appState.visitors)&#125;)`</span></span><br></pre></td></tr></table></figure>
<p>这形成了一个类似 <strong> 洋葱 </strong>（cycle state 的前身正是 cycle-onionify）的状态管理模型：我们由外部世界开始，层层剥开外衣，拿到状态；在逐层进行 reduce 操作，由内到外进行状态更新：</p>
<p><img src="https://github.com/staltz/cycle-onionify/raw/master/diagram.png" alt="Diagram"></p>
<p>具体看一个例子，假定父组件获得如下的状态：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  foo: string,</span><br><span class="line">  bar: number,</span><br><span class="line">  child: &#123;</span><br><span class="line">    count: number,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>child</code> 子状态是其子组件需要的状态，此时，洋葱模型下就要考虑：</p>
<ul>
<li>将 <code>child</code> 从状态树中剥离，传递给子组件</li>
<li>收集子组件输出的 <code>reducer$</code>，合并后继续向外输出</li>
</ul>
<p>首先，我们需要使用 <code>@cycle/isolate</code> 隔离子组件，其暴露了一个 <code>isolate(component, scope)</code> 函数，该函数接受两个参数：</p>
<ul>
<li><code>component</code>：需要隔离的组件，即一个接受 <code>sources</code> 并返回 <code>sinks</code> 的函数</li>
<li><code>scope</code>：组件被隔离到的 scope。scope 决定了 DOM，state 等外部环境如何划分其资源到组件</li>
</ul>
<p>该函数最终将返回隔离组件输出的 <code>sinks</code>。获得了子组件的 <code>reducer$</code> 之后，还要与父组件的 <code>reducer$</code> 进行合并，继续向外抛出。</p>
<p>例如下面的代码中，<code>isolate(Child, &#39;child&#39;)(sources)</code> 将 <code>Child</code> 组件隔离到了名为 <code>child</code> 的 scope 下，因此， <code>@cycle/state</code> 能够知道，要从状态树上选出名为 <code>child</code> 的状态子树给 <code>Child</code> 组件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">sources</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> state$ = sources.state.stream; <span class="comment">// emits &#123; foo, bar, child &#125;</span></span><br><span class="line">  <span class="keyword">const</span> childSinks = isolate(Child, <span class="string">'child'</span>)(sources);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> parentReducer$ = xs.merge(initReducer$, someOtherReducer$);</span><br><span class="line">  <span class="keyword">const</span> childReducer$ = childSinks.state;</span><br><span class="line">  <span class="keyword">const</span> reducer$ = xs.merge(parentReducer$, childReducer$);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    state: reducer$</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，为了保证父组件不存在时，子组件能够独立运行的能力，需要在子组件中进行识别这种场景（<code>prevState === undefined</code>），并返回对应状态：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">sources</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> state$ = sources.state.stream; <span class="comment">// emits &#123; count &#125; </span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> defaultReducer$ = xs.of(<span class="function"><span class="keyword">function</span> <span class="title">defaultReducer</span>(<span class="params">prevState</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> prevState === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: <span class="number">0</span>&#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> prevState</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 这里，reducer 将处理 &#123; count &#125; state</span></span><br><span class="line">  <span class="keyword">const</span> reducer$ = xs.merge(defaultReducer$, someOtherReducer$);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    state: reducer$</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好的习惯是，每个组件我们都声明一个 <code>defaultReducer$</code>，用来照顾其单独使用时的场景，以及存在父组件时的场景。</p>
<blockquote>
<p>关于组件隔离的来由，可以参看：<a href="https://cycle.js.org/components.html#components" target="_blank" rel="noopener">Cycle.js Components 一节</a></p>
</blockquote>
<h3 id="使用-Lens-机制传递状态"><a href="#使用-Lens-机制传递状态" class="headerlink" title="使用 Lens 机制传递状态"></a>使用 Lens 机制传递状态</h3><p>在洋葱模型中，数据通过父组件传递到子组件，这里父组件仅仅能够从自身的状态树摘取一棵子树给子组件，因此，这个模型在灵活性上受到了一些限制：</p>
<ul>
<li><strong> 个数上 </strong>：只能传递一个子状态</li>
<li><strong> 规模上 </strong>：不能传递整个状态</li>
<li><strong>I/O 上 </strong>：只能读取，不能修改状态</li>
</ul>
<p>如果你有下面的需求，这种模式就难以胜任：</p>
<ul>
<li>组件需要多个状态，例如需要获得 <code>state.foo</code> 及 <code>state.status</code></li>
<li>父子组件需要访问同一部分状态，例如父组件和子组件需要获得 <code>state.foo</code> </li>
<li>当子组件的状态变动后，需要联动修改状态树，而不只是通过 <code>reducer$</code> 修改其自身状态</li>
</ul>
<p>为此，就需要考虑使用上文中我们提到的第一种状态共享方式。我们给到的多少有些粗糙，Cycle.js 则是引入了 lens 机制来处理洋葱模型无法照顾到的这些场景，顾名思义，这能让组件拥有 <strong> 洞察（读取）</strong> 并且 <strong> 更改（写入）</strong> 状态的能力。</p>
<p>简单来说，lens 通过 getter/setter 定义了对某个数据的读写。</p>
<p>为了实现这个机制，Cycle.js 让 <code>isolate</code> 在隔离组件实例时，接受组件自定义的 lens 作为 scope selector，以让 <code>@cycle/state</code> 组件要如何读取以及修改状态。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fooLens = &#123;</span><br><span class="line">  get: <span class="function"><span class="params">state</span> =&gt;</span> state.foo,</span><br><span class="line">  set: <span class="function">(<span class="params">state, childState</span>) =&gt;</span> (&#123;...state, <span class="attr">foo</span>: childState&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fooSinks = isolate(Foo, &#123;<span class="attr">state</span>: fooLens&#125;)(sources);</span><br></pre></td></tr></table></figure>
<p>上面代码中，通过自定义 lens，组件 <code>Foo</code> 能够获得状态树上的 <code>foo</code> 状态，而当 <code>Foo</code> 修改了 <code>foo</code> 后，将联动修改状态树上的 <code>foo</code> 状态。</p>
<h3 id="处理动态列表"><a href="#处理动态列表" class="headerlink" title="处理动态列表"></a>处理动态列表</h3><p>渲染动态列表是前端最常见的需求之一，在 Cycle.js 引入状态管理之前，这一直是 Cycle.js 做不好的一个点，甚至 André Staltz 还专门开了一篇 <a href="https://github.com/cyclejs/cyclejs/issues/312" target="_blank" rel="noopener">issue</a> 来讨论如何更在 Cycle.js 中更优雅的处理动态列表。</p>
<p>现在，基于上述的状态管理模型，只需要一个 <code>makeCollection</code> API，即可在 Cycle.js 中，创建一个动态列表：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">sources</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> array$ = sources.state.stream;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> List = makeCollection(&#123;</span><br><span class="line">    item: Child,</span><br><span class="line">    itemKey: <span class="function">(<span class="params">childState, index</span>) =&gt;</span> <span class="built_in">String</span>(index),</span><br><span class="line">    itemScope: <span class="function"><span class="params">key</span> =&gt;</span> key,</span><br><span class="line">    collectSinks: <span class="function"><span class="params">instances</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        state: instances.pickMerge(<span class="string">'state'</span>),</span><br><span class="line">        DOM: instances.pickCombine(<span class="string">'DOM'</span>)</span><br><span class="line">        .map(<span class="function"><span class="params">itemVNodes</span> =&gt;</span> ul(itemVNodes))</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> listSinks = List(sources);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> reducer$ = xs.merge(listSinks.state, parentReducer$);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    state: reducer$</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到上面的代码，基于 <code>@cylce/state</code> 创建一个动态列表，我们需要告诉 <code>@cycle/state</code>：</p>
<ul>
<li>列表元素是什么</li>
<li>每个元素在状态中的位置</li>
<li><p>每个元素的 scope</p>
</li>
<li><p>列表的 <code>reducer$</code>：<code>instances.pickMerge(&#39;state&#39;)</code>，其约等于:</p>
<ul>
<li><code>xs.merge(instances.map(sink =&gt; sink.state))</code></li>
</ul>
</li>
<li>列表的 <code>vdom$</code>：<code>instances.pickCombine(&#39;DOM&#39;)</code>，其约等于：<ul>
<li><code>xs.combine(instances.map(sink =&gt; sink.DOM))</code></li>
</ul>
</li>
</ul>
<p><strong> 新增列表元素 </strong> 只需要在列表容器的 <code>reducer$</code> 中，为数组新增一个元素即可：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reducer$ = xs.periodic(<span class="number">1000</span>).map(<span class="function"><span class="params">i</span> =&gt;</span> <span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">prevArray</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> prevArray.concat(&#123;<span class="attr">count</span>: i&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong> 删除元素 </strong> 则需要子组件在删除行为触发时，将其状态标识为 <code>undefiend</code>，Cycle.js 内部会据此从列表数组中删除该状态，进而删除子组件及其输出的 sinks：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">sources</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> deleteReducer$ = deleteAction$.mapTo(<span class="function"><span class="keyword">function</span> <span class="title">deleteReducer</span>(<span class="params">prevState</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> reducer$ = xs.merge(deleteReducer$, someOtherReducer$)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    state: reducer$</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Cycle.js 相比较于前端三大框架（Angular/React/Vue）来说，算是小众的不能再小众的框架，学习这样的框架并不是为了 <strong> 标新立异 </strong>，考虑到你的团队，你也很难在大型工程中将它作为支持框架。但是，这不妨碍我们从 Cycle.js 的设计中获得启发和灵感，它多少能让你感受到：</p>
<ul>
<li>也许我们的应用就是一个和外部世界打交道的环</li>
<li>什么是分形</li>
<li>响应式程序设计的魅力</li>
<li>什么是 lens 机制？如何在 JavaScript 应用中使用 lens</li>
<li>…</li>
</ul>
<p>另外，Cycle.js 的作者 André Staltz 也是一个颇具个人魅力和表达能力的开发者，推荐你关注他的：</p>
<ul>
<li>André Staltz 的博客：<a href="https://staltz.com/" target="_blank" rel="noopener">https://staltz.com/</a></li>
<li>André Staltz 在 egghead.io 上的 RxJs 和 Cycle.js 教程，你不仅能学到 API，还能学到框架设计思路：<a href="https://egghead.io/instructors/andre-staltz" target="_blank" rel="noopener">https://egghead.io/instructors/andre-staltz</a></li>
<li>André Staltz 参加并演讲的一系列会议：<a href="https://www.youtube.com/results?search_query=andre+staltz" target="_blank" rel="noopener">https://www.youtube.com/results?search_query=andre+staltz</a></li>
</ul>
<p>最后，不要盲目崇拜，只要疯狂学习和探索。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><p><a href="https://staltz.com/unidirectional-user-interface-architectures.html" target="_blank" rel="noopener">UNIDIRECTIONAL USER INTERFACE ARCHITECTURES</a></p>
</li>
<li><p><a href="https://cycle.js.org/api/state.html" target="_blank" rel="noopener">Cycle State</a></p>
</li>
<li><p><a href="https://medium.com/javascript-inside/an-introduction-into-lenses-in-javascript-e494948d1ea5" target="_blank" rel="noopener">An Introduction Into Lenses In JavaScript</a></p>
</li>
</ul>

      
    </div>

    
      
      

  <div class="post-copyright">
    <p class="copyright-item">
      <span>原文作者: </span>
      <a href="http://yoyoyohamapi.me">吴晓军</a>
    </p>
    <p class="copyright-item">
      <span>原文链接: </span>
      <a href="http://yoyoyohamapi.me/2018/12/16/Cycle.js_的状态管理模型/">http://yoyoyohamapi.me/2018/12/16/Cycle.js_的状态管理模型/</a>
    </p>
    <p class="copyright-item">
      <span>许可协议: </span>
      
      本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可
    </p>
  </div>



      
      
  <div class="post-reward">
    <input type="checkbox" name="reward" id="reward" hidden />
    <label class="reward-button" for="reward">赞赏支持</label>
    <div class="qr-code">
      
      
      
    </div>
  </div>

    

    
      <footer class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/JavaScript/">JavaScript</a>
            
              <a href="/tags/函数式编程/">函数式编程</a>
            
              <a href="/tags/Cycle-js/">Cycle.js</a>
            
          </div>
        
        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2019/04/08/使用_Hooks_创建异步组件/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">使用 Hooks 创建异步组件</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/2018/09/04/更好用的_Redux/">
        <span class="next-text nav-default">更好用的 Redux</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

      </footer>
    

  </article>


          </div>
          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:softshot37@gmail.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
        
          <a href="https://github.com/yoyoyohamapi" class="iconfont icon-github" title="github"></a>
        
      
    
      
    
      
        
          <a href="https://www.zhihu.com/people/wu-xiao-jun-64-55/activities" class="iconfont icon-zhihu" title="zhihu"></a>
        
      
    
      
    
      
    
      
    
    
    
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>


<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2015 - 
    
    2019

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">吴晓军</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    
  
  <script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://yoyoyohamapi.me/2018/12/16/Cycle.js_的状态管理模型/';
        this.page.identifier = '2018/12/16/Cycle.js_的状态管理模型/';
        this.page.title = 'Cycle.js 状态管理模型';
    };
    (function() {
    var d = document, s = d.createElement('script');

    s.src = '//yoyoyohamapi.disqus.com/embed.js';

    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();  
  </script>

  

  



    
  



  
  





  
    <script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  

  
    <script type="text/javascript" src="/lib/pjax/jquery.pjax.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/nprogress/nprogress.min.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.9.0"></script>

  <!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</body>
</html>
