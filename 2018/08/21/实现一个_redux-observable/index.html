<!DOCTYPE html>
<html lang="">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="如何实现一个 redux-observable"/>




  <meta name="keywords" content="React, Redux, RxJS, 吴小蛆的巣" />










  <link rel="alternate" href="/atom.xml" title="吴小蛆的巣">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.9.0" />



<link rel="canonical" href="http://yoyoyohamapi.me/2018/08/21/实现一个_redux-observable/"/>



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />




  <link rel="stylesheet" type="text/css" href="/lib/nprogress/nprogress.min.css" />



<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.9.0" />



  



  <script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>








<script>
  window.config = {"title":"吴小蛆的巣","subtitle":null,"description":"只要努力，蛆虫也能变成苍蝇翱翔于天际","author":"吴晓军","language":null,"timezone":null,"url":"http://yoyoyohamapi.me","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":true,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":true,"line_number":false,"tab_replace":"  "},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"page","theme":"even","deploy":{"type":"git","repo":"https://github.com/yoyoyohamapi/yoyoyohamapi.github.io.git","branch":"master"},"ignore":[],"math":{"engine":"mathjax"},"sitemap":{"path":"sitemap.xml"},"category_generator":{"per_page":10},"feed":{"type":"atom","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"atom.xml"},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"index_generator":{"per_page":10},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"sanitize":false,"tables":true,"breaks":true,"smartLists":true,"smartypants":true},"server":{"log":false,"ip":"0.0.0.0"},"since":2015,"favicon":"/favicon.ico","rss":"default","menu":{"Home":"/","Archives":"/archives/","Tags":"/tags","Categories":"/categories"},"color":"Default","toc":true,"fancybox":true,"pjax":true,"copyright":{"enable":true,"origin":"http://yoyoyohamapi.me","license":"本文采用<a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc/4.0/\" target=\"_blank\">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可"},"reward":{"enable":true,"qrCode":{"wechat":null,"alipay":null}},"social":{"email":"softshot37@gmail.com","stack-overflow":null,"twitter":null,"facebook":null,"linkedin":null,"google":null,"github":"https://github.com/yoyoyohamapi","weibo":null,"zhihu":"https://www.zhihu.com/people/wu-xiao-jun-64-55/activities","pocket":null,"tumblr":null,"instagram":null},"leancloud":{"app_id":null,"app_key":null},"baidu_analytics":null,"baidu_verification":null,"google_analytics":null,"google_verification":null,"disqus_shortname":"yoyoyohamapi","version":"2.9.0"};
</script>

    <title> 如何实现一个 redux-observable - 吴小蛆的巣 </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">吴小蛆的巣</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            首页
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            归档
          
        </li>
      </a>
    
      <a href="/tags">
        <li class="mobile-menu-item">
          
          
            标签
          
        </li>
      </a>
    
      <a href="/categories">
        <li class="mobile-menu-item">
          
          
            分类
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">吴小蛆的巣</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              首页
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              归档
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            
            
              标签
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/categories">
            
            
              分类
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          如何实现一个 redux-observable
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-08-21
        </span>
        
          <div class="post-category">
            
              <a href="/categories/React/">React</a>
            
          </div>
        
        
      </div>
    </header>

    
    
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Redux"><span class="toc-text">Redux</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#用-observable-管理副作用"><span class="toc-text">用 observable 管理副作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构建中间件"><span class="toc-text">构建中间件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#流的转换器"><span class="toc-text">流的转换器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#优化：ofType-operator"><span class="toc-text">优化：ofType operator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#优化：获得-state"><span class="toc-text">优化：获得 state</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#优化：观察状态"><span class="toc-text">优化：观察状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#优化：响应初始状态"><span class="toc-text">优化：响应初始状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#优化：相互关联的-transformer"><span class="toc-text">优化：相互关联的 transformer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考资料"><span class="toc-text">参考资料</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#关于本系列"><span class="toc-text">关于本系列</span></a></li></ol>
    </div>
  </div>



    <div class="post-content">
      
        <p><img src="/2018/08/21/实现一个_redux-observable/cover.png" alt=""></p>
<blockquote>
<p>本文是 《使用 RxJS + Redux 管理应用状态》系列第二篇文章，将会介绍 redux-observable 的设计哲学和实现思路。返回第一篇：<a href="http://yoyoyohamapi.me/2018/08/18/%E4%BD%BF%E7%94%A8_redux-observable_%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6%E8%87%AA%E6%B2%BB/">使用 redux-observable 实现组件自治</a></p>
<p>本系列的文章地址汇总：</p>
<ul>
<li><a href="http://yoyoyohamapi.me/2018/08/18/%E4%BD%BF%E7%94%A8_redux-observable_%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6%E8%87%AA%E6%B2%BB/">使用 redux-observable 实现组件自治</a></li>
<li><a href="http://yoyoyohamapi.me/2018/08/21/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA_redux-observable/">如何实现一个 redux-observable</a></li>
</ul>
</blockquote>
<a id="more"></a>
<h2 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h2><p>Redux 脱胎于 Elm 架构，其状态管理视角和流程非常清晰和明确：</p>
<p><img src="/2018/08/21/实现一个_redux-observable/redux.png" alt=""></p>
<ol>
<li>dispatch 了一个 action</li>
<li>reducer 俘获 action，并根据 action 类型进行不同的状态更新逻辑</li>
<li>周而复始地进行这个过程</li>
</ol>
<p>这个过程是同步的，Redux 为了保护 reducer 的纯度是不推荐在 reducer 中处理副作用的（如 HTTP 请求）。因此，就出现了 redux-thunk、redux-saga 这样的 Redux 中间件去处理副作用。</p>
<p>这些中间件本质都是俘获 dispatch 的内容，并在这个过程中进行副作用处理，最终 dispatch 一个新的 action 给 reducer，让 reducer 专心做一个纯的状态机。</p>
<h2 id="用-observable-管理副作用"><a href="#用-observable-管理副作用" class="headerlink" title="用 observable 管理副作用"></a>用 observable 管理副作用</h2><p>假定我们在 UI 层能派发出一个数据拉取的 <code>FETCH</code> action，拉取数据后，将派发拉取成功的 <code>FETCH_SUCCESS</code> action 或者是数据拉取失败的 <code>FETCH_ERROR</code> action 到 reducer。</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">          FETCH</span><br><span class="line">            <span class="string">|</span></span><br><span class="line">      fetching data...</span><br><span class="line">            <span class="string">|</span></span><br><span class="line">           / \</span><br><span class="line">          /   \</span><br><span class="line">FETCH_SUCCESS FETCH_ERROR</span><br></pre></td></tr></table></figure>
<p>如果我们用 FRP 模式来思考这个过程，FETCH 就不是一个独立的个体，而是存在于一条会派发 FETCH action 的流上（observable）：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span><span class="meta">---</span> <span class="string">FETCH</span> <span class="bullet">----</span> <span class="string">FETCH</span> <span class="bullet">----</span> </span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span><span class="meta">---</span> <span class="string">FETCH_SUCCESS</span> <span class="bullet">----</span> <span class="string">FETCH_SUCCESS</span> <span class="bullet">----</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span><span class="meta">---</span> <span class="string">FETCH_ERROR</span> <span class="bullet">----</span> <span class="string">FETCH_ERROR</span> <span class="bullet">----</span></span><br></pre></td></tr></table></figure>
<p>若我们将 FETCH 流定义为 <code>fetch$</code>，则 FETCH_SUCCESS 和 FETCH_ERROR 都将来自于 <code>fetch$</code>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fetch$: Observable&lt;FetchAction&gt; = <span class="comment">//....</span></span><br><span class="line">fetch$.pipe(</span><br><span class="line">  switchMap(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">from</span>(api.fetch).pipe(</span><br><span class="line">    <span class="comment">// 拉取数据成功 </span></span><br><span class="line">    switchMap(<span class="function"><span class="params">resp</span> =&gt;</span> (&#123;</span><br><span class="line">      <span class="keyword">type</span>: FETCH_SUCCESS,</span><br><span class="line">      payload: &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// 拉取数据失败 </span></span><br><span class="line">    catchError(<span class="function"><span class="params">error</span> =&gt;</span> of(&#123;</span><br><span class="line">      <span class="keyword">type</span>: FETCH_ERROR,</span><br><span class="line">      payload: &#123;</span><br><span class="line">        <span class="comment">// ....</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;))</span><br><span class="line">  ))</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>除此之外，我们可以用一个流来承载页面所有的 action：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> action$: Observable&lt;Action&gt;</span><br></pre></td></tr></table></figure>
<p>那么， <code>fetch$</code> 亦可以由 <code>action$</code> 流转得到：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fetch$ = action$.pipe(</span><br><span class="line">  filter(<span class="function">(<span class="params">&#123;<span class="keyword">type</span>&#125;</span>) =&gt;</span> <span class="keyword">type</span> === FETCH)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这样，我们就形成了使用 observable 流转 action 的模式：</p>
<p><img src="/2018/08/21/实现一个_redux-observable/使用 observable 流转 action.png" alt="使用 observable 流转 action"></p>
<p>接下来，我们尝试讲这个模式整合到 Redux 中，让 observable 来负责应用的 action 流转和副作用处理。</p>
<h2 id="构建中间件"><a href="#构建中间件" class="headerlink" title="构建中间件"></a>构建中间件</h2><p>Redux 提供的中间件机制能让我们干预每个到来的 action， 借此处理一些业务逻辑，然后再返还一个 action 给 reducer：</p>
<p><img src="/2018/08/21/实现一个_redux-observable/middleware.png" alt="middleware"></p>
<p>中间件的函数构成如下：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> middleware: Middleware = <span class="function"><span class="params">store</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 初始化中间件 </span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">next</span> =&gt;</span> action =&gt; &#123; </span><br><span class="line">  	<span class="comment">// do something</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(</span><br><span class="line">  rootReducer,</span><br><span class="line">  applyMiddleware(middleware)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>现在，当中间件初始化时，我们进行 <code>action$</code> 。当新的 action 到来时：</p>
<ol>
<li>将 action 交给 reducer 处理</li>
<li>想 <code>action$</code> 中放入 action</li>
<li><code>action$</code> 可以转化另一个的 action 流</li>
</ol>
<p>因此，<code>action$</code> 既是观察者又是可观察对象，是一个 Subject 对象：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> createMiddleware = (): <span class="function"><span class="params">Middleware</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> action$ = <span class="keyword">new</span> Subject()</span><br><span class="line">  <span class="keyword">const</span> middleware: Middleware = <span class="function"><span class="params">store</span> =&gt;</span> next =&gt; <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 将 action 交给 reducer 处理 </span></span><br><span class="line">    <span class="keyword">const</span> result = next(action)</span><br><span class="line">    <span class="comment">// 将 action 放到 action$ 中进行流转 </span></span><br><span class="line">    action$.next(action)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> middleware</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="流的转换器"><a href="#流的转换器" class="headerlink" title="流的转换器"></a>流的转换器</h2><p>现在，在中间件中，我们初始化了 <code>action$</code>，但是如何得到 <code>fetch$</code> 这些由 <code>action$</code> 派生的流呢？因此，我们还需要告知中间件如果通过 <code>action$</code> 生成更多的流，不妨定义一个转换器，由它负责 <code>action$</code> 的流转，并在当中处理副作用：</p>
<p><img src="/2018/08/21/实现一个_redux-observable/transformer.png" alt=""></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Transformer &#123;</span><br><span class="line">  (action$: Observable&lt;Action&gt;): Observable&lt;Action&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fetchTransformer: Transformer = <span class="function">(<span class="params">action$</span>) =&gt;</span> &#123;</span><br><span class="line">  action$.pipe(</span><br><span class="line">    filter(<span class="function">(<span class="params">&#123;<span class="keyword">type</span>&#125;</span>) =&gt;</span> <span class="keyword">type</span> === FETCH),</span><br><span class="line">    switchMap(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">from</span>(api.fetch).pipe(</span><br><span class="line">      switchMap(<span class="function"><span class="params">resp</span> =&gt;</span> (&#123;</span><br><span class="line">        <span class="keyword">type</span>: FETCH_SUCCESS,</span><br><span class="line">        payload: &#123;</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;),</span><br><span class="line">      catchError(<span class="function"><span class="params">error</span> =&gt;</span> of(&#123;</span><br><span class="line">        <span class="keyword">type</span>: FETCH_ERROR,</span><br><span class="line">        payload: &#123;</span><br><span class="line">          <span class="comment">// ....</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;))</span><br><span class="line">    ))</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应用中，我们可能定义不同的转换器，从而得到派发不同 action 的流：</p>
<p><img src="/2018/08/21/实现一个_redux-observable/transformers.png" alt="多个 transformer "></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> newActionsStreams: Observable&lt;Action&gt;[] = transformers.map(<span class="function"><span class="params">transformer</span> =&gt;</span> transformer(action$))</span><br></pre></td></tr></table></figure>
<p>由于这些 action 还具有一致的数据结构，因此我们可以将这些流进行合并，由合并后的流负责派发 action 到 reducer：</p>
<p><img src="/2018/08/21/实现一个_redux-observable/merge.png" alt="合并多个流"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> newAction$ = merge(newActionStreams)</span><br></pre></td></tr></table></figure>
<p>那么，修改我们的中间件实现：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> createMiddleware = (...transformers): <span class="function"><span class="params">Middleware</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> action$ = <span class="keyword">new</span> Subject()</span><br><span class="line">  <span class="comment">// 运行各个 transformer，并将转换的流进行合并 </span></span><br><span class="line">  <span class="keyword">const</span> newAction$ = merge(tramsformer.map(<span class="function"><span class="params">transformer</span> =&gt;</span> transformer(action$)))</span><br><span class="line">  <span class="keyword">const</span> middleware: Middleware = <span class="function"><span class="params">store</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 订阅 newAction$</span></span><br><span class="line">    newAction$.subscribe(<span class="function"><span class="params">action</span> =&gt;</span> store.dispatch(action))</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">next</span> =&gt;</span> action =&gt; &#123;</span><br><span class="line">      <span class="comment">// 将 action 交给 reducer 处理 </span></span><br><span class="line">      <span class="keyword">const</span> result = next(action)</span><br><span class="line">      <span class="comment">// 将 action 放到 action$ 中进行流转 </span></span><br><span class="line">      action$.next(action)</span><br><span class="line">      <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> middleware</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="优化：ofType-operator"><a href="#优化：ofType-operator" class="headerlink" title="优化：ofType operator"></a>优化：<code>ofType</code> operator</h2><p>由于我们总是需要 <code>filter(action =&gt; action.type === SOME_TYPE)</code> 来过滤 action，因此可以封装一个 operator 来优化这个过程：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ofType: OperatorFunction&lt;Observable&lt;Action&gt;, Observable&lt;Action&gt;&gt; = <span class="function">(<span class="params"><span class="keyword">type</span>: <span class="built_in">String</span></span>) =&gt;</span> pipe(</span><br><span class="line">  filter(<span class="function"><span class="params">action</span> =&gt;</span> action.type === <span class="keyword">type</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fetchTransformer: Transformer = (action$) &#123;</span><br><span class="line">  <span class="keyword">return</span> action$.pipe(</span><br><span class="line">    filter(<span class="function">(<span class="params">&#123;<span class="keyword">type</span>&#125;</span>) =&gt;</span> <span class="keyword">type</span> === FETCH),</span><br><span class="line">    switchMap(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">from</span>(api.fetch)),</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再考虑到我们可能不只过滤一个 action type，因此可以优化我们的 <code>ofType</code> operator 为：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ofType: OperatorFunction&lt;Observable&lt;Action&gt;, Observable&lt;Action&gt;&gt; = </span><br><span class="line">  (...types: <span class="built_in">String</span>[]) =&gt; pipe(</span><br><span class="line">    filter(<span class="function">(<span class="params">action: Action</span>) =&gt;</span> types.indexOf(action.type) &gt; <span class="number">-1</span>)</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> counterTransformer: Transformer = (action$) &#123;</span><br><span class="line">  <span class="keyword">return</span> action$.pipe(</span><br><span class="line">    ofType(INCREMENT, DECREMENT),</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面这个测试用例将用来测试我们的中间件是否能够工作了：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'should transform action'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">const</span> reducer: Reducer = <span class="function">(<span class="params">state = 0, action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span>(action.type) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'PONG'</span>:</span><br><span class="line">        <span class="keyword">return</span> state + <span class="number">1</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> state</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> transformer: Transformer = <span class="function">(<span class="params">action$</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> action$.pipe(</span><br><span class="line">        ofType(<span class="string">'PING'</span>),</span><br><span class="line">        mapTo(&#123;<span class="keyword">type</span>: <span class="string">'PONG'</span>&#125;)</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> middleware = createMiddleware(transformer)</span><br><span class="line">  <span class="keyword">const</span> store = createStore(reducer, applyMiddleware(middleware))</span><br><span class="line">  store.dispatch(&#123;<span class="keyword">type</span>: <span class="string">'PING'</span>&#125;)</span><br><span class="line">  expect(store.getState()).to.be.equal(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="优化：获得-state"><a href="#优化：获得-state" class="headerlink" title="优化：获得 state"></a>优化：获得 state</h2><p>在 action 的流转过程可能还需要获得应用状态，例如，<code>fetch$</code> 中获取数据前，需要封装请求参数，部分参数可能来自于应用状态。因此，我们可以考虑为每个 transformer 再传递当前的 store 对象，使它能拿到当前的应用状态：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Transformer &#123;</span><br><span class="line">  (action$: Observable&lt;Action&gt;, store: Store): Observable&lt;Action&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> createMiddleware = (...transformers): <span class="function"><span class="params">Middleware</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> action$ = <span class="keyword">new</span> Subject()</span><br><span class="line">  <span class="keyword">const</span> middleware: Middleware = <span class="function"><span class="params">store</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 将 store 也传递给 transformer</span></span><br><span class="line">    <span class="keyword">const</span> newAction$ = merge(tramsformer.map(<span class="function"><span class="params">transformer</span> =&gt;</span> transformer(action$, store)))</span><br><span class="line">    newAction$.subscribe(<span class="function"><span class="params">action</span> =&gt;</span> store.dispatch(action))</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">next</span> =&gt;</span> action =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> result = next(action)</span><br><span class="line">      action$.next(action)</span><br><span class="line">      <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> middleware</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，当需要取用状态的时候，就通过 <code>store.getState()</code> 拿取：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fetchTransformer: Transformer = (action$, store) &#123;</span><br><span class="line">  <span class="keyword">return</span> action$.pipe(</span><br><span class="line">    filter(<span class="function">(<span class="params">&#123;<span class="keyword">type</span>&#125;</span>) =&gt;</span> <span class="keyword">type</span> === FETCH),</span><br><span class="line">    switchMap(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; query, page, pageSize &#125; = store.getState()</span><br><span class="line">      <span class="keyword">const</span> params = &#123; query, page, pageSize &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">from</span>(api.fetch, params)</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="优化：观察状态"><a href="#优化：观察状态" class="headerlink" title="优化：观察状态"></a>优化：观察状态</h2><p>在响应式编程体系下，一切数据源都应当是可被观察的，而上面我们对状态的取值确是主动的（proactive）的，正确的方式是应当观察状态的变化，并在变化时作出决策：</p>
<p><img src="/2018/08/21/实现一个_redux-observable/state$.png" alt="state$"></p>
<p>为此，类似 <code>action$</code>，我们也将 state 流化，使得应用状态成为一个可观察对象，并将 <code>state$</code> 传递给 transformer：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Transformer &#123;</span><br><span class="line">  (action$: Observable&lt;Action&gt;, state$: Observable&lt;State&gt;): Observable&lt;Action&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> createMiddleware = (...transformers): <span class="function"><span class="params">Middleware</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> action$ = <span class="keyword">new</span> Subject()</span><br><span class="line">  <span class="keyword">const</span> state$ = <span class="keyword">new</span> Subject()</span><br><span class="line">  <span class="keyword">const</span> middleware: Middleware = <span class="function"><span class="params">store</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 由各个 transformer 获得应用的 action$</span></span><br><span class="line">    <span class="keyword">const</span> newAction$ = merge(tramsformer.map(<span class="function"><span class="params">transformer</span> =&gt;</span> transformer(action$, state$)))</span><br><span class="line">    <span class="comment">// 新的 action 到来时，将其又 dispatch 到 Redux 生态 </span></span><br><span class="line">    newAction$.subscribe(<span class="function"><span class="params">action</span> =&gt;</span> store.dispatch(action))</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">next</span> =&gt;</span> action =&gt; &#123;</span><br><span class="line">      <span class="comment">// 将 action 交给 reducer</span></span><br><span class="line">      <span class="keyword">const</span> result = next(action)</span><br><span class="line">      <span class="comment">// 获得 reducer 处理后的新状态 </span></span><br><span class="line">      state$.next(state)</span><br><span class="line">      <span class="comment">// 将 action 放入 action$</span></span><br><span class="line">      action$.next(action)</span><br><span class="line">      <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> middleware</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当业务流程需要状态时，就可以自由组合 <code>state$</code> 得到：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fetchTransformer: Transformer = (action$, state$) &#123;</span><br><span class="line">  <span class="keyword">return</span> action$.pipe(</span><br><span class="line">    filter(<span class="function">(<span class="params">&#123;<span class="keyword">type</span>&#125;</span>) =&gt;</span> <span class="keyword">type</span> === FETCH),</span><br><span class="line">    withLatestFrom(state$),</span><br><span class="line">    switchMap(<span class="function">(<span class="params">[action, state]</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; query, page, pageSize &#125; = state</span><br><span class="line">      <span class="keyword">const</span> params = &#123; query, page, pageSize &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">from</span>(api.fetch, params)</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>乍看之下，似乎不如 <code>store.getState()</code> 来的方便，为了获得当前状态，我们还额外引入了一个 operator <code>withLatestFrom</code>。但是，要注意到，我们引入 <code>state$</code> 不只为了获得状态和统一模式，更重要是为了 <strong> 观察 </strong> 状态。</p>
<p>举个例子，我们有一个备忘录组件，每次内容变动时，我们就存储一下草稿。如果我们能观察状态变动，通过响应式编程模式，当状态变动时，自动形成草稿存储的业务：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> saveDraft$: Observable&lt;Action&gt; = state$.pipe(</span><br><span class="line">  <span class="comment">// 选出当前 </span></span><br><span class="line">  pluck(<span class="string">'content'</span>),</span><br><span class="line">  <span class="comment">// 只有当内容变动时才考虑存储草稿 </span></span><br><span class="line">  distinctUntilChanged(),</span><br><span class="line">  <span class="comment">// 只在 1 s 内保存一次 </span></span><br><span class="line">  throttleTime(<span class="number">1000</span>),</span><br><span class="line">  <span class="comment">// 调用服务存储草稿 </span></span><br><span class="line">  switchMap(<span class="function"><span class="params">content</span> =&gt;</span> <span class="keyword">from</span>(api.saveDraft(content)))</span><br><span class="line">  <span class="comment">// ....</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>大家也可以在回顾系列第一篇所介绍的内容，正是由于 redux-observable 在 1.0 版本引入了 <code>state$</code>，我们才得以解耦组件的业务关系，实现单个组件的自治。</p>
<h2 id="优化：响应初始状态"><a href="#优化：响应初始状态" class="headerlink" title="优化：响应初始状态"></a>优化：响应初始状态</h2><p>现在，我们可以测试一下现在的中间件，看能否观察应用状态了：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'should observe state'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">const</span> reducer: Reducer = <span class="function">(<span class="params">state = &#123;step: 10, counter: 0&#125;, action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span>(action.type) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'PONG'</span>:</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          ...state,</span><br><span class="line">          counter: action.counter</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> state</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> transformer: Transformer = <span class="function">(<span class="params">action$, state$</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> action$.pipe(</span><br><span class="line">        ofType(<span class="string">'PING'</span>),</span><br><span class="line">      	withLatestFrom(state$, <span class="function">(<span class="params">action, state</span>) =&gt;</span> state.step + state.counter),</span><br><span class="line">        map(<span class="function"><span class="params">counter</span> =&gt;</span> (&#123;<span class="keyword">type</span>: <span class="string">'PONG'</span>, counter&#125;))</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> middleware = createMiddleware(transformer)</span><br><span class="line">  <span class="keyword">const</span> store = createStore(reducer, applyMiddleware(middleware))</span><br><span class="line">  store.dispatch(&#123;<span class="keyword">type</span>: <span class="string">'PING'</span>&#125;)</span><br><span class="line">  expect(store.getState().counter).to.be.equal(<span class="number">10</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>遗憾的是，这个测试用例将不会通过，通过调试发现，当我们 dispatch 了 PING action 后，<code>withLatestFrom</code> 没有拿到最近一次的 state。这是为什么呢？原来是因为 Redux 的 init action 并没有暴露给中间件进行拦截，因此，应用的初始状态没能被送入 <code>state$</code> 中，观察者无法观察到初始状态。</p>
<p>为了解决这个问题，在创建了 store 后，我们可以尝试 dispatch 一个无意义的 action 给中间件，强制将初始状态先送入 <code>state$</code> 中：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> middleware = createMiddleware(transformer)</span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer, applyMiddleware(middleware))</span><br><span class="line"><span class="comment">// 派发一个 action 去获得初始状态 </span></span><br><span class="line">store.dispatch(&#123;<span class="keyword">type</span>: <span class="string">'@@INIT_STATE'</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>这个方式虽然能让测试通过，但缺不是很优雅，我们让用户手动去派发一个无意义的 action，这会让用户感觉很困惑。因此，我们考虑为中间件单独设置一个 API，用以在 store 创建后，完成一些任务：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置一个 store 副本 </span></span><br><span class="line"><span class="keyword">let</span> cachedStore: Store</span><br><span class="line"><span class="keyword">const</span> createMiddleware = (...transformers): <span class="function"><span class="params">Middleware</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> action$ = <span class="keyword">new</span> Subject()</span><br><span class="line">  <span class="keyword">const</span> state$ = <span class="keyword">new</span> Subject()</span><br><span class="line">  <span class="keyword">const</span> newAction$ = merge(transformers.map(<span class="function"><span class="params">transformer</span> =&gt;</span> transformer(action$, state$)))</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> middleware: Middleware = <span class="function"><span class="params">store</span> =&gt;</span> &#123;</span><br><span class="line">    cachedStore = store</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">next</span> =&gt;</span> action =&gt; &#123;</span><br><span class="line">      <span class="comment">// 将 action 交给 reducer</span></span><br><span class="line">      <span class="keyword">const</span> result = next(action)</span><br><span class="line">      <span class="comment">// 获得 reducer 处理后的新状态 </span></span><br><span class="line">      state$.next(state)</span><br><span class="line">      <span class="comment">// 将 action 放入 action$</span></span><br><span class="line">      action$.next(action)</span><br><span class="line">      <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  middleware.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 开始对 action 的订阅 </span></span><br><span class="line">    newAction$.subscribe(cachedStore.dispatch)</span><br><span class="line">    <span class="comment">// 2. 将初始状态传递给 state$</span></span><br><span class="line">    state$.next(cachedStore.getState())</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> middleware</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们为中间件提供了一个 <code>run</code> 方法，来让中间件在 store 创建以后完成一些工作。当我们创建好 store 后，运行 <code>run</code> 方法来运行中间件：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> middleware = createMiddleware(transformer)</span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer, applyMiddleware(middleware))</span><br><span class="line"><span class="comment">// 运行我们的中间件 </span></span><br><span class="line">middleware.run()</span><br></pre></td></tr></table></figure>
<h2 id="优化：相互关联的-transformer"><a href="#优化：相互关联的-transformer" class="headerlink" title="优化：相互关联的 transformer"></a>优化：相互关联的 transformer</h2><p>再考虑一个更加场景，各个 transformer 之间可能存在关联，各个 trasformer 也可能直接发出 action，而不需要依赖于 <code>action$</code>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'should queue synchronous actions'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> reducer = <span class="function">(<span class="params">state = [], action</span>) =&gt;</span> state.concat(action)</span><br><span class="line">    <span class="keyword">const</span> transformer1 = <span class="function">(<span class="params">action$, state$</span>) =&gt;</span> action$.pipe(</span><br><span class="line">      ofType(<span class="string">'FIRST'</span>),</span><br><span class="line">      mergeMap(<span class="function"><span class="params">()</span> =&gt;</span> of(&#123; <span class="keyword">type</span>: <span class="string">'SECOND'</span> &#125;, &#123; <span class="keyword">type</span>: <span class="string">'THIRD'</span>&#125; ))</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">const</span> transformer2 = <span class="function">(<span class="params">action$, state$</span>) =&gt;</span> action$.pipe(</span><br><span class="line">        ofType(<span class="string">'SECOND'</span>),</span><br><span class="line">        mapTo(&#123;<span class="keyword">type</span>: <span class="string">'FORTH'</span>&#125;)</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> middleware = createMiddleware(transformer1, transformer2)</span><br><span class="line">    <span class="keyword">const</span> store = createStore(reducer, applyMiddleware(middleware))</span><br><span class="line">    middleware.run()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> actions = store.getState()</span><br><span class="line">    actions.shift() <span class="comment">// remove redux init action</span></span><br><span class="line">    expect(actions).to.deep.equal([</span><br><span class="line">      &#123; <span class="keyword">type</span>: <span class="string">'FIRST'</span> &#125;,</span><br><span class="line">      &#123; <span class="keyword">type</span>: <span class="string">'SECOND'</span> &#125;,</span><br><span class="line">      &#123; <span class="keyword">type</span>: <span class="string">'THIRD'</span> &#125;,</span><br><span class="line">      &#123; <span class="keyword">type</span>: <span class="string">'FORTH'</span> &#125;</span><br><span class="line">    ])</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在这个测试用例中，我们看到的 action 序列是：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">FIRST</span></span><br><span class="line"><span class="attribute">SECOND</span></span><br><span class="line"><span class="attribute">THIRD</span></span><br><span class="line"><span class="attribute">FORTH</span></span><br></pre></td></tr></table></figure>
<p>但是，在当前的实现中，你将得到：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">FIRST</span></span><br><span class="line"><span class="attribute">SECOND</span></span><br><span class="line"><span class="attribute">FORTH</span></span><br><span class="line"><span class="attribute">THIRD</span></span><br></pre></td></tr></table></figure>
<p>这并不符合预期。但是，问题又出在哪里呢？我们分析下程序执行过程：</p>
<ol>
<li>发出 first action</li>
<li>调度 first action，派生出 second action 及 third action 的 observable</li>
<li>调度 second action，派生出 forth action 的 observable</li>
<li>调度 forth action</li>
<li>调度 third action</li>
</ol>
<p>问题显然就出在第 2、3 步，如果第 2 步中，我们控制 observable <strong> 吐出值 </strong> 的速度，将同时到来的 second 和 third action 缓存到队列，并依次执行，就能得到我们期望的输出。</p>
<p>幸运的是，RxJS 中提供了 <a href="http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-observeOn" target="_blank" rel="noopener"> <code>observeOn</code></a> 这个 operator 来控制 <strong> 数据源发出值的节奏 </strong>。其第一个参数接收一个调度器，用于告知数据源以怎样的速录调度任务，这里我们将使用 <a href="https://rxjs-dev.firebaseapp.com/api/index/const/queueScheduler" target="_blank" rel="noopener"><strong>Queue Scheduler</strong></a> 将各个 action 缓存到队列，当此时再无 action 时，各个 action 出队并被调度：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createEpicMiddleware = <span class="function">(<span class="params">...epics</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> action$ = <span class="keyword">new</span> Subject().pipe(observeOn(queueScheduler)) <span class="keyword">as</span> Subject&lt;Action&gt;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> middleware</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，再次运行测试用例，你讲看到符合期望的 action 序列：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">FIRST</span><br><span class="line">SECOND</span><br><span class="line">THIRD</span><br><span class="line">FORTH</span><br></pre></td></tr></table></figure>
<p>这是因为：</p>
<ol>
<li>发出 first action</li>
<li>调度 first action，入队</li>
<li>此时没有 action，first action 出队，<code>store.dispatch(first)</code>，派生出 second action 及 third action 的 observable</li>
<li>second action 入队，third action 入队</li>
<li>此时没有等待的 action，则 second action 出队，<code>store.dispatch(second)</code>，派生出 forth action 的 observable</li>
<li>forth action 入队</li>
<li>此时没有等待的 action，队首元素 third action 出队，<code>store.dispatch(third)</code></li>
<li>forth action 出队，<code>store.dispatch(forth)</code></li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>截止目前，我们的中间件已经允许我们通过 FRP 模式梳理应用状态了，这个中间件的实现已经非常类似于 redux-observable 的实现了。当然，大家生产环境还是用更流行，更稳定的 redux-observable，本文旨在帮助大家更好的理解如何在 Redux 中集成 RxJS 更好的管理状态，通过一步一步对中间件的优化，也让大家理解了了 redux-observable 的设计哲学和实现原理。本文实现的 mini redux-observable 我也放到了我的 <a href="https://github.com/yoyoyohamapi/toys/tree/master/redux-observable" target="_blank" rel="noopener">github</a> 上，包含了一些测试用例和一个小的 demo。</p>
<p>接下来，我们将探索将 redux-observable 以及 FRP 这套模式集成到 dva 架构的前端框架中，dva 架构帮助砍掉 Redux 冗长的样板代码，而 redux-observable 则专注于副作用处理。</p>
<hr>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html" target="_blank" rel="noopener">RxJS API document</a></li>
<li><a href="https://staltz.com/primer-on-rxjs-schedulers.html" target="_blank" rel="noopener">PRIMER ON RXJS SCHEDULERS</a></li>
<li><a href="https://github.com/redux-observable/redux-observable/pull/493" target="_blank" rel="noopener">redux-observable #493 pull request</a></li>
<li><a href="https://www.youtube.com/watch?v=AL8dG1tuH40&amp;t=2366s" target="_blank" rel="noopener">Gerard Sans — Bending time with Schedulers and RxJS 5</a></li>
</ul>
<h2 id="关于本系列"><a href="#关于本系列" class="headerlink" title="关于本系列"></a>关于本系列</h2><ul>
<li>本系列将从介绍 redux-observable 1.0 开始，阐述自己在结合 RxJS 到 Redux 中的心得体会。涉及内容会有 redux-observable 实践介绍，redux-observable 实现原理探究，最后会介绍下自己当前基于 redux-observble + dva architecture 的一个 state 管理框架 reobservable。</li>
<li>本系列不是 RxJS 或者 Redux 入门，不再讲述他们的基础概念，宣扬他们的核心优势。如果你搜索 RxJS 不小心进到了这个系列，对 RxJS 和 FRP 程序设计产生了兴趣，那么入门我会推荐：<ul>
<li><a href="https://www.learnrxjs.io/" target="_blank" rel="noopener">learnrxjs.io</a></li>
<li>Andre Staltz 在 <a href="https://egghead.io/courses/introduction-to-reactive-programming" target="_blank" rel="noopener">egghead.io</a> 上的一系列课程</li>
<li>程墨的 <a href="https://item.jd.com/12336101.html" target="_blank" rel="noopener">《深入浅出 RxJS》</a></li>
</ul>
</li>
<li>本系列更不是教程，只是介绍自己在 Redux 中应用 RxJS 的一些思路，希望更多人能指出当中存在的误区，或者交流更优雅的实践。</li>
<li>由衷的感谢实践路上一些师兄的帮助，尤其感谢腾讯云的 questguo 学长在模式上的指导。reobservable 脱胎于腾讯云 questguo 主导的 React 框架 —— TCFF，期待未来 TCFF 的开源。</li>
<li>感谢小雨的设计支援。</li>
</ul>

      
    </div>

    
      
      

  <div class="post-copyright">
    <p class="copyright-item">
      <span>原文作者: </span>
      <a href="http://yoyoyohamapi.me">吴晓军</a>
    </p>
    <p class="copyright-item">
      <span>原文链接: </span>
      <a href="http://yoyoyohamapi.me/2018/08/21/实现一个_redux-observable/">http://yoyoyohamapi.me/2018/08/21/实现一个_redux-observable/</a>
    </p>
    <p class="copyright-item">
      <span>许可协议: </span>
      
      本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可
    </p>
  </div>



      
      
  <div class="post-reward">
    <input type="checkbox" name="reward" id="reward" hidden />
    <label class="reward-button" for="reward">赞赏支持</label>
    <div class="qr-code">
      
      
      
    </div>
  </div>

    

    
      <footer class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/React/">React</a>
            
              <a href="/tags/Redux/">Redux</a>
            
              <a href="/tags/RxJS/">RxJS</a>
            
          </div>
        
        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2018/09/04/更好用的_Redux/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">更好用的 Redux</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/2018/08/18/使用_redux-observable_实现组件自治/">
        <span class="next-text nav-default">使用 redux-observable 实现组件自治</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

      </footer>
    

  </article>


          </div>
          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:softshot37@gmail.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
        
          <a href="https://github.com/yoyoyohamapi" class="iconfont icon-github" title="github"></a>
        
      
    
      
    
      
        
          <a href="https://www.zhihu.com/people/wu-xiao-jun-64-55/activities" class="iconfont icon-zhihu" title="zhihu"></a>
        
      
    
      
    
      
    
      
    
    
    
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>


<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2015 - 
    
    2020

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">吴晓军</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    
  
  <script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://yoyoyohamapi.me/2018/08/21/实现一个_redux-observable/';
        this.page.identifier = '2018/08/21/实现一个_redux-observable/';
        this.page.title = '如何实现一个 redux-observable';
    };
    (function() {
    var d = document, s = d.createElement('script');

    s.src = '//yoyoyohamapi.disqus.com/embed.js';

    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();  
  </script>

  

  



    
  



  
  





  
    <script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  

  
    <script type="text/javascript" src="/lib/pjax/jquery.pjax.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/nprogress/nprogress.min.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.9.0"></script>

  <!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</body>
</html>
