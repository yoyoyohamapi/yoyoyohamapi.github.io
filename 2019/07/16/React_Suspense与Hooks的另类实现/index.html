<!DOCTYPE html>
<html lang="">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="React Suspense 与 Hooks 的另类实现"/>




  <meta name="keywords" content="函数式编程, React, Hooks, 吴小蛆的巣" />










  <link rel="alternate" href="/atom.xml" title="吴小蛆的巣">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.9.0" />



<link rel="canonical" href="http://yoyoyohamapi.me/2019/07/16/React_Suspense与Hooks的另类实现/"/>



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />




  <link rel="stylesheet" type="text/css" href="/lib/nprogress/nprogress.min.css" />



<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.9.0" />



  



  <script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>








<script>
  window.config = {"title":"吴小蛆的巣","subtitle":null,"description":"只要努力，蛆虫也能变成苍蝇翱翔于天际","author":"吴晓军","language":null,"timezone":null,"url":"http://yoyoyohamapi.me","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":true,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":true,"line_number":false,"tab_replace":"  "},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"page","theme":"even","deploy":{"type":"git","repo":"https://github.com/yoyoyohamapi/yoyoyohamapi.github.io.git","branch":"master"},"ignore":[],"math":{"engine":"mathjax"},"sitemap":{"path":"sitemap.xml"},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"feed":{"type":"atom","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"atom.xml"},"index_generator":{"per_page":10},"category_generator":{"per_page":10},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"sanitize":false,"tables":true,"breaks":true,"smartLists":true,"smartypants":true},"server":{"log":false,"ip":"0.0.0.0"},"since":2015,"favicon":"/favicon.ico","rss":"default","menu":{"Home":"/","Archives":"/archives/","Tags":"/tags","Categories":"/categories"},"color":"Default","toc":true,"fancybox":true,"pjax":true,"copyright":{"enable":true,"origin":"http://yoyoyohamapi.me","license":"本文采用<a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc/4.0/\" target=\"_blank\">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可"},"reward":{"enable":true,"qrCode":{"wechat":null,"alipay":null}},"social":{"email":"softshot37@gmail.com","stack-overflow":null,"twitter":null,"facebook":null,"linkedin":null,"google":null,"github":"https://github.com/yoyoyohamapi","weibo":null,"zhihu":"https://www.zhihu.com/people/wu-xiao-jun-64-55/activities","pocket":null,"tumblr":null,"instagram":null},"leancloud":{"app_id":null,"app_key":null},"baidu_analytics":null,"baidu_verification":null,"google_analytics":null,"google_verification":null,"disqus_shortname":"yoyoyohamapi","version":"2.9.0"};
</script>

    <title> React Suspense 与 Hooks 的另类实现 - 吴小蛆的巣 </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">吴小蛆的巣</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            首页
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            归档
          
        </li>
      </a>
    
      <a href="/tags">
        <li class="mobile-menu-item">
          
          
            标签
          
        </li>
      </a>
    
      <a href="/categories">
        <li class="mobile-menu-item">
          
          
            分类
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">吴小蛆的巣</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              首页
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              归档
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            
            
              标签
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/categories">
            
            
              分类
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          React Suspense 与 Hooks 的另类实现
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-07-16
        </span>
        
          <div class="post-category">
            
              <a href="/categories/React/">React</a>
            
          </div>
        
        
      </div>
    </header>

    
    
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#怎么让函数组件处理异步任务？"><span class="toc-text">怎么让函数组件处理异步任务？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#怎样控制业务流程的暂停与继续？"><span class="toc-text">怎样控制业务流程的暂停与继续？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实现-React-Suspense"><span class="toc-text">实现 React Suspense</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#竞态优化"><span class="toc-text">竞态优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hook-useState"><span class="toc-text">Hook: useState</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#了不起的-Monad"><span class="toc-text">了不起的 Monad</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考资料"><span class="toc-text">参考资料</span></a></li></ol>
    </div>
  </div>



    <div class="post-content">
      
        <p><img src="/2019/07/16/React_Suspense与Hooks的另类实现/cover.png" alt=""></p>
<a id="more"></a>
<p>React 16 算的是 React 最大的一次变革，不仅底层实现基于 Fiber 重写，带来了更好的任务调度能力和性能表现，也为开发者提供了诸如 new Context、Suspense 、Hooks 等等强大的 API。</p>
<p>作为 React 16 新特性拥趸之一，笔者偶然读到 <a href="https://medium.freecodecamp.org/when-to-use-react-suspense-vs-react-hooks-f66ef94cb54f" target="_blank" rel="noopener">《When to use React Suspense vs React Hooks》</a> 这篇文章，千万别被其标题所迷惑，它并不是介绍怎么用 Suspense 和 Hooks 的。</p>
<p>与笔者之前读过的 Hooks 或者 Suspense 的原理分析不同，该文另辟蹊径，讨论了如何通过 <a href="https://www.wikiwand.com/en/Monad_(functional_programming" target="_blank" rel="noopener">Monad</a>&gt;) 来实现 Suspense 和 Hooks。但是文章 “开门见山”，在没有铺垫的情况下，直接介绍了基于 Monad 的 Suspense 和 Hooks 实现，这就会让读者觉得十分唐突，读起来十分吃力。</p>
<p>本文基于这篇文章，以思考怎么在函数组件中处理异步任务为引，循序渐进的铺陈 Suspense 和 Hooks 的简单实现，最后引出 Monad，构建一个二者都适用的实现机制。借此，一方面希望读者更加熟悉 Suspense 和 Hooks 的设计来由和方式，一方面也让读者感受到统一数据类型及函数式编程对业务抽象的帮助。</p>
<blockquote>
<p>由于笔者能力所限，本文不会对 Monad 和函数式编程做进一步的严肃介绍，感兴趣的读者可以阅读 <strong> 参考资料 </strong> 中的延伸阅读。</p>
</blockquote>
<h2 id="怎么让函数组件处理异步任务？"><a href="#怎么让函数组件处理异步任务？" class="headerlink" title="怎么让函数组件处理异步任务？"></a>怎么让函数组件处理异步任务？</h2><p>在 Hooks 推出之前，我们仅仅使用函数组件（Functional Component）编写纯展示组件，它是一个纯函数，给定函数的输入（Props），必然能得到一致的组件结构（DOM）。但如果我们想要打破函数纯度限制，比如我们非要在函数组件中完成一个远程数据拉取和展示，那该怎么做呢？</p>
<p>说的在具体一些，组件运行伊始，我们拉取数据，若数据尚未到达，则不渲染组件。自然而然地，首先我们会想到 async/await：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> App = <span class="keyword">async</span> props =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> total = <span class="keyword">await</span> fetchTotal();</span><br><span class="line">  <span class="keyword">const</span> users = <span class="keyword">await</span> fetchUsers();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;div&gt;&#123;<span class="string">`Total: <span class="subst">$&#123;total&#125;</span>`</span>&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">        &#123;users.map(user =&gt; (</span></span><br><span class="line"><span class="regexp">          &lt;li&gt;&#123;user.name&#125;&lt;/</span>li&gt;</span><br><span class="line">        ))&#125;</span><br><span class="line">      &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, document.querySelector("#app"));</span></span><br></pre></td></tr></table></figure>
<p>但运行这段代码，将会报错：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">Objects are not valid as <span class="selector-tag">a</span> React child (found: [<span class="selector-tag">object</span> Promise])</span><br></pre></td></tr></table></figure>
<p>这是因为 async 函数最终被转换为了 Promise 对象，而不是 React 组件。那我们当然会想到说，构建一个 转换器，来实现 async function 到 React 组件的转化：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> App = transformer(<span class="keyword">async</span> props =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> total = <span class="keyword">await</span> fetchTotal();</span><br><span class="line">  <span class="keyword">const</span> users = <span class="keyword">await</span> fetchUsers();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;div&gt;&#123;<span class="string">`Total: <span class="subst">$&#123;total&#125;</span>`</span>&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">        &#123;users.map(user =&gt; (</span></span><br><span class="line"><span class="regexp">          &lt;li&gt;&#123;user.name&#125;&lt;/</span>li&gt;</span><br><span class="line">        ))&#125;</span><br><span class="line">      &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="怎样控制业务流程的暂停与继续？"><a href="#怎样控制业务流程的暂停与继续？" class="headerlink" title="怎样控制业务流程的暂停与继续？"></a>怎样控制业务流程的暂停与继续？</h2><p>在实现这个转换器之前，我们先回顾下用 async/await 编写组件的目的：</p>
<ul>
<li>使用命令式编程编排异步任务。</li>
<li>期望获得 await 提供的暂态能力。上例中，我们期望在 <code>total</code> 获得之后，再去拉取 <code>users</code>。</li>
</ul>
<p>那么不依赖于 async/await，还要实现运行逻辑的启停，我们可以在逻辑外层包裹一个 runner，顾名思义，它能够控制一段逻辑的运行，当遇到异步副作用时，让流程暂停，等待任务完成，当任务完成时，继续执行流程。</p>
<p>假定我们使用 Promise 创建了一个异步任务：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fetch = <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">"data"</span>), <span class="number">1000</span>));</span><br></pre></td></tr></table></figure>
<p>我们也知道，Promise 是使用 <code>then</code> 进行任务串联：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">fetchTotal()</span><br><span class="line">  .then(<span class="function"><span class="params">total</span> =&gt;</span> [total, fetchUsers()])</span><br><span class="line">  .then(<span class="function">(<span class="params">[total, users]</span>) =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure>
<p>如果期望 runner 能让我们基于 Promise 构建的任务跳脱出 <code>then</code> 的链式调用，而使用 async/await 的命令式风格来控制流程：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> effect = run(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> total = fetchTotal();</span><br><span class="line">  <span class="keyword">const</span> users = fetchUsers();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><img src="/2019/07/16/React_Suspense与Hooks的另类实现/runner.png" alt="runner"></p>
<p>这能做到吗？首先，我们要思考，JavaScript 是否有能力 <strong> 阻断后续程序流程 </strong>？答案是有的，但要借助于异常与 try/catch，若流程中跑出了一个异常，那么逻辑就会进入 catch 块，而不会执行后续流程：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> task1 = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">throw</span> <span class="string">"error"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> ret1 = task1();</span><br><span class="line">  <span class="comment">// task1 抛出异常，task2 不再执行</span></span><br><span class="line">  <span class="keyword">const</span> ret2 = task2();</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>try-catch 可以阻断后续代码的逻辑，这帮助我们借道实现了 <strong> 暂停当前逻辑 </strong>，但我们还要解决：</p>
<blockquote>
<p>当进入暂态的任务完成后，被阻断的逻辑能继续执行。</p>
</blockquote>
<p>要回到我们的暂停位置，执行后续流程，其实就要：</p>
<ol>
<li>重新执行逻辑，回到暂停发生位置，此时要不再 throw error 进入 暂态，而是直接获得任务结果</li>
<li>继续后续流程</li>
</ol>
<p>因此，我们需要借助于缓存来缓存任务结果，决定再次执行任务时，是否进入暂态：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 标识当前缓存位置</span></span><br><span class="line"><span class="keyword">let</span> pos = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 缓存任务运行结果</span></span><br><span class="line"><span class="keyword">const</span> cache = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> task1 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (cache[pos]) &#123;</span><br><span class="line">    <span class="keyword">return</span> cache[pos++];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">"task1"</span>), <span class="number">1000</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> task2 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (cache[pos]) &#123;</span><br><span class="line">    <span class="keyword">return</span> cache[pos++];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">"task2"</span>), <span class="number">1000</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> main = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> step = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> ret1 = task1();</span><br><span class="line">      <span class="keyword">const</span> ret2 = task2();</span><br><span class="line">      <span class="built_in">console</span>.log(ret1, ret2);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (task) &#123;</span><br><span class="line">      task.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        cache[pos++] = value;</span><br><span class="line">        <span class="comment">// 重启流程</span></span><br><span class="line">        <span class="keyword">return</span> step();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> step();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上例中，重复代码还较多，也并不通用，只能执行 task1 与 task2。我们可以设计一个 <strong>runner</strong>，负责执行基于 Promise 编排的业务流；另外也针对异步任务做一个 <strong>wrapper</strong>，控制任务是否应当进入暂态：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当前执行的位置</span></span><br><span class="line"><span class="keyword">let</span> pos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务执行结果缓存</span></span><br><span class="line"><span class="keyword">let</span> cache = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> wrapTask = <span class="function"><span class="params">task</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (cache[pos]) &#123;</span><br><span class="line">    <span class="keyword">return</span> cache[pos++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> task;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> runner = <span class="function"><span class="params">process</span> =&gt;</span> &#123;</span><br><span class="line">  cache = [];</span><br><span class="line">  <span class="keyword">return</span> step();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 每一步都从头执行</span></span><br><span class="line">    pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> ret = process();</span><br><span class="line">      <span class="keyword">return</span> ret;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (task) &#123;</span><br><span class="line">      <span class="keyword">return</span> task.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        cache[pos] = value;</span><br><span class="line">        <span class="keyword">return</span> step();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/07/16/React_Suspense与Hooks的另类实现/throw_restart.png" alt=""></p>
<p>现在，我们就能使用命令式风格编排基于 Promise 的业务逻辑了，下面的代码中，只有当 task1 和 task2 都完成了，才会执行 <code>console.log</code>，打印结果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> task1 = <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">  wrapTask(<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">"task1"</span>), <span class="number">1000</span>)));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> task2 = <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">  wrapTask(<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">"task2"</span>), <span class="number">1000</span>)));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> main = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> ret1 = task1();</span><br><span class="line">  <span class="keyword">const</span> ret2 = task2();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"result is"</span>, re1, ret2);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">run(main); <span class="comment">// result is task1 task2</span></span><br></pre></td></tr></table></figure>
<p>这段代码的执行流程就为：</p>
<ul>
<li>从头执行业务，执行 task1，发现 cache 中没有 task1 的结果，throw task1</li>
<li>task1 resolved, 从头执行业务</li>
<li>task1 in cache, 返回 cache 中的结果赋值给 ret，任务游标 + 1，开始后续任务</li>
<li>task2 执行，发现 cache 中没有 task2 的结果, throw task2</li>
<li>task2 resolved, 从头执行业务</li>
<li>task1 in cahce, 返回 cache 中的结果赋值给 ret1，任务游标 + 1，开始后续任务</li>
<li>task2 in cahce, 返回 cache 中的结果赋值给 ret2</li>
<li>业务执行完成，退出</li>
</ul>
<p>OK，我们总结下基于 try/catch 与 Promise 实现暂态的原理：</p>
<ul>
<li>在 try block 中通过 throw promise 进入暂态</li>
<li>在 catch block 中，通过 <code>promise.then</code> 更新缓存，重启流程，以进行下一步</li>
</ul>
<h2 id="实现-React-Suspense"><a href="#实现-React-Suspense" class="headerlink" title="实现 React Suspense"></a>实现 React Suspense</h2><p>React 16 推出的 Suspense 除了做 Code-Splitting，还能实现异步组件。借助于上面实现的流程控制，我们也可以实现 React Suspense。首先，我们创建了一个 <code>withAsync</code> 来包裹函数组件：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> withAsync = <span class="function"><span class="params">func</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">AysncComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">      <span class="keyword">super</span>(props);</span><br><span class="line">      <span class="keyword">this</span>.state = &#123;</span><br><span class="line">        component: <span class="literal">null</span></span><br><span class="line">      &#125;;</span><br><span class="line">      run(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">          component: func(props)</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.state.component;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> AysncComponent;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们看到，在异步创建后，我们启动了一个 runner，来获得每一次函数组件的运行结果。现在，我们就能通过写出含有异步副作用（基于 Promise）的函数组件了：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> task1 = <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">  wrapTask(<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">"task1"</span>), <span class="number">1000</span>)));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> task2 = <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">  wrapTask(<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">"task2"</span>), <span class="number">1000</span>)));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = withAsync(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> ret1 = task1();</span><br><span class="line">  <span class="keyword">const</span> ret2 = task2();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;li&gt;&#123;ret1&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">      &lt;li&gt;&#123;ret2&#125;&lt;/</span>li&gt;</span><br><span class="line">    &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br></pre></td></tr></table></figure>
<p>这个 <code>withAsync</code> 不就是我们第一节说要实现的转换器吗。</p>
<p><img src="/2019/07/16/React_Suspense与Hooks的另类实现/async_withAsync.png" alt=""></p>
<blockquote>
<p>上面的例子你可以在 <a href="https://codesandbox.io/s/xp536m876w" target="_blank" rel="noopener">CodeSandbox</a> 上查看。</p>
</blockquote>
<h2 id="竞态优化"><a href="#竞态优化" class="headerlink" title="竞态优化"></a>竞态优化</h2><p>假如我们写了多个函数组件，就像下面这样：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> task1 = <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">  wrapTask(<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">"task1"</span>), <span class="number">1000</span>)));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> task2 = <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">  wrapTask(<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">"task2"</span>), <span class="number">2000</span>)));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> task3 = <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">  wrapTask(<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">"task3"</span>), <span class="number">4000</span>)));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> task4 = <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">  wrapTask(<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">"task4"</span>), <span class="number">5000</span>)));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App1 = withAsync(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> ret1 = task1();</span><br><span class="line">  <span class="keyword">const</span> ret2 = task2();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;li&gt;&#123;ret1&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">      &lt;li&gt;&#123;ret2&#125;&lt;/</span>li&gt;</span><br><span class="line">    &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const App2 = withAsync(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  const ret3 = task3();</span></span><br><span class="line"><span class="regexp">  const ret4 = task4();</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">      &lt;li&gt;&#123;ret3&#125;&lt;/</span>li&gt;</span><br><span class="line">      &lt;li&gt;&#123;ret4&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/u</span>l&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;App1 /&gt;</span><br><span class="line">    &lt;p&gt;-------------<span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">    &lt;App2 /&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;,</span></span><br><span class="line"><span class="regexp">  document.querySelector("#app")</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure>
<p>预期的输出你希望是：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">task1</span><br><span class="line">task2</span><br><span class="line">-------------</span><br><span class="line">task3</span><br><span class="line">task4</span><br></pre></td></tr></table></figure>
<p>事与愿违，实际的输出可能是：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">task1</span><br><span class="line">task2</span><br><span class="line">-------------</span><br><span class="line">task1</span><br><span class="line">task2</span><br></pre></td></tr></table></figure>
<p>我们来分析下执行流程：</p>
<ul>
<li>从头执行 <code>&lt;App1 /&gt;</code>，执行 task1，发现 cache 中没有 task1 的结果，throw task1</li>
<li>从头执行 <code>&lt;App2 /&gt;</code>，执行 task3，发现 cache 中没有 task3 的结果，throw task3</li>
<li>task 1 resolved，刷新缓存 <code>[&#39;task1&#39;]</code>，从头执行 <code>&lt;App1 /&gt;</code></li>
<li>从缓存中获得 <code>&#39;task1&#39;</code> 赋值给 <code>ret1</code>，pos + 1，throw task2</li>
<li>task 2 resolved，刷新缓存为 <code>[&#39;task1&#39;, &#39;task2&#39;]</code>，从头执行 <code>&lt;App1 /&gt;</code></li>
<li>赋值 <code>ret1</code>、<code>ret2</code>，并输出 <code>task1</code> 与 <code>task2</code>，此时 pos === 2</li>
<li>task 3 resovled，刷新缓存为 <code>[&#39;task1&#39;, &#39;task2&#39;, &#39;task3&#39;]</code>，从头执行 <code>&lt;App2 /&gt;</code></li>
<li>因为 pos 被重置为 0，所以取出 <code>task1</code> 赋值给 <code>ret3</code></li>
<li>同理，<code>ret4</code> 将被赋值为 <code>task2</code>。最终，你看到了不符合预期的输出</li>
</ul>
<blockquote>
<p>这个错误的例子你可以访问 <a href="https://codesandbox.io/s/suspense-async-component-bug-umi36" target="_blank" rel="noopener">这里</a> 查看：</p>
</blockquote>
<p>分析至此，你不难看出问题所在，在原始的设计中，我们并没有考虑 <strong> 竞态处理 </strong>，共享变量 <code>pos</code> 和 <code>cache</code> 在各个任务间没有得到保护。</p>
<p>为此，我们考虑：</p>
<ul>
<li>为每个流程设置其私有的 <code>pos</code> 和 <code>cache</code> 上下文</li>
<li>每次运行流程时，绑定当前上下文到当前流程的上下文</li>
<li>每次执行完流程时，释放对外部上下文的绑定</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当前的流程上下文</span></span><br><span class="line"><span class="keyword">let</span> context = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> wrapTask = <span class="function"><span class="params">task</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 每次运行 task，如果 task 已经被缓存，则返回</span></span><br><span class="line">  <span class="comment">// 并更新</span></span><br><span class="line">  <span class="keyword">if</span> (context.cache[context.pos]) &#123;</span><br><span class="line">    <span class="keyword">return</span> context.cache[context.pos++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> task;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> process =&gt; &#123;</span><br><span class="line">  <span class="comment">// 为每个流程设置自己的上下文</span></span><br><span class="line">  <span class="keyword">const</span> ctx = &#123;</span><br><span class="line">    cache: [],</span><br><span class="line">    pos: <span class="number">0</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> step();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 每次流程执行，重置当前步骤到开头</span></span><br><span class="line">    ctx.pos = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 缓存当前上下文，执行完成后恢复</span></span><br><span class="line">    <span class="keyword">const</span> cachedContext = context;</span><br><span class="line">    <span class="comment">// 将上下文绑定到当前的流程的上下文</span></span><br><span class="line">    context = ctx;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> process();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (task) &#123;</span><br><span class="line">      <span class="comment">// 记录任务进入暂态时的位置，便于后面知道刷新哪个位置的缓存</span></span><br><span class="line">      <span class="keyword">const</span> pos = ctx.pos;</span><br><span class="line">      <span class="keyword">return</span> task.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 缓存当前执行结果</span></span><br><span class="line">        ctx.cache[pos] = value;</span><br><span class="line">        <span class="comment">// 重启流程</span></span><br><span class="line">        <span class="keyword">return</span> step();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 每次执行完，释放对上下文的掌控</span></span><br><span class="line">      context = cachedContext;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>基于新的实现，上例中的两个流程 <code>&lt;App1 /&gt;</code> 及 <code>&lt;App2 /&gt;</code>，每次运行时，都使用各自的上下文来刷新和读取缓存。如果对这个实现不太看得懂，读者不妨自己手写下新的执行流程就一目了然了。</p>
<blockquote>
<p>这个新的实现和用例，你可以访问 <a href="https://codesandbox.io/s/suspense-async-component-opt-pv87n" target="_blank" rel="noopener">这里</a> 查看</p>
</blockquote>
<h2 id="Hook-useState"><a href="#Hook-useState" class="headerlink" title="Hook: useState"></a>Hook: useState</h2><p>上面，我们实现了 <strong> 函数式异步组件 </strong>，我们再来看看 <code>useState</code> 这个 Hook，先回顾下它的用法：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Counter = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;&#123;count&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;+&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure>
<p>可以看到，<code>useState</code> 为函数式组件带了状态治理的能力。假定我们要自己实现 <code>useState</code> hook，你会怎么思考？最简单地，可以这么思考：</p>
<blockquote>
<p>每次 <code>setState</code> 后，重新运行函数，获得最新状态，并用新的状态渲染组件。</p>
</blockquote>
<p>是不是又回到了我们实现 Suspense 是要面对的问题：<strong> 反复执行流程，刷新当前结果 </strong>。那么我们不妨试试用同样的手段来实现 <code>useState</code> hook：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> useState = <span class="function"><span class="params">initial</span> =&gt;</span></span><br><span class="line">  wrapTask(</span><br><span class="line">    <span class="built_in">Promise</span>.resolve([</span><br><span class="line">      initial,</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">setState</span>(<span class="params">newState</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 如何重启流程？</span></span><br><span class="line">      &#125;</span><br><span class="line">    ])</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> process = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [count2, setCount2] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;count&#125;</span> - <span class="subst">$&#123;count2&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (count &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    setCount(count + <span class="number">1</span>);</span><br><span class="line">    setCount(count + <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">run(process());</span><br></pre></td></tr></table></figure>
<p>但是遗憾的是，在 <code>setState</code> 函数中，我们没有办法重启流程。这是因为：基于 Promise 封装的任务，重启流程的时机是 <strong> 任务完成（即 Promise 被 resolved）</strong>，一个 <strong> 异步 </strong> 过程，而 <code>useState</code> 的重启时机，是我们调用了 <code>setState</code> 函数之后，这是一个 <strong> 同步 </strong> 过程。因此，我们不能使用上面的 runner 来实现 <code>useState</code> Hook。</p>
<p>那该怎么做呢？考虑到我们此时需要调度的任务是一个同步过程，即每次它执行完成后，就要执行下一步动作，那么任务就可以定义为：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Task = <span class="function">(<span class="params">callback: (<span class="params">value: <span class="built_in">any</span></span>) =&gt; <span class="built_in">void</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure>
<p>即任务接受一个 callback 作为参数，当任务完成时，callback 会被调用，去重启流程。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> run = <span class="function"><span class="params">process</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 每次运行 task，如果 task 已经被缓存，则返回</span></span><br><span class="line">  <span class="comment">// 并更新</span></span><br><span class="line">  <span class="keyword">if</span> (context.cache[context.pos]) &#123;</span><br><span class="line">    <span class="keyword">return</span> context.cache[context.pos++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> task;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> process =&gt; &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> process();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (task) &#123;</span><br><span class="line">      <span class="comment">// 记录任务进入暂态时的位置，便于后面知道刷新哪个位置的缓存</span></span><br><span class="line">      <span class="keyword">const</span> pos = ctx.pos;</span><br><span class="line">      <span class="keyword">return</span> task(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 缓存当前执行结果</span></span><br><span class="line">        ctx.cache[pos] = value;</span><br><span class="line">        <span class="comment">// 重启流程</span></span><br><span class="line">        <span class="keyword">return</span> step();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 每次执行完，释放对上下文的掌控</span></span><br><span class="line">      context = cachedContext;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>则 <code>useState</code> 就可以改造为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> useState = <span class="function"><span class="params">initial</span> =&gt;</span></span><br><span class="line">  <span class="comment">// 此时我们 wrap 的 task 就为接收一个 callback 作为参数的函数</span></span><br><span class="line">  wrapTask(<span class="function"><span class="params">callback</span> =&gt;</span></span><br><span class="line">    callback([</span><br><span class="line">      initial,</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">setState</span>(<span class="params">newState</span>) </span>&#123;</span><br><span class="line">        callback([newState, setState]);</span><br><span class="line">      &#125;</span><br><span class="line">    ])</span><br><span class="line">  );</span><br></pre></td></tr></table></figure>
<p>这部分完整实现和例子你可以访问 <a href="https://codesandbox.io/s/nnkxz64r8j" target="_blank" rel="noopener">这里</a> 查看。</p>
<h2 id="了不起的-Monad"><a href="#了不起的-Monad" class="headerlink" title="了不起的 Monad"></a>了不起的 Monad</h2><p>读者可能看到了，上面我们对 React Suspense 及 <code>useState</code> hook 的实现，逻辑和代码都是非常类似的。无论我们使用 Promise 还是 callback，目的都是在于 <strong> 重启流程，以调度后续任务 </strong>，他们只是在 catch 块中重启流程的方式不同，以及任务类型的不同。</p>
<p>如果我们能将 Promise 和 callback 任务 <strong> 包裹（wrap）或者说提升（lift）到同一数据类型 </strong>，就能泛化出通用的 runner 了，比如像下面这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">task.next(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  cache[pos] = value;</span><br><span class="line">  <span class="keyword">return</span> step();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在函数式编程中，<a href="https://www.wikiwand.com/en/Monad_(functional_programming" target="_blank" rel="noopener">Monad</a>&gt;) 便能完成这个任务。关于 Monad 在这里就不做更深入的探讨了，本文介绍的是使用 Monad 去在 JavaScript 解决实际问题，而非深入浅出 Haskell 或者范畴论（笔者也远远不具备这个能力）。</p>
<p><img src="/2019/07/16/React_Suspense与Hooks的另类实现/lift_monad.png" alt=""></p>
<p>现在，对 Monad，你只需要知道：</p>
<blockquote>
<p>对不同类型的值包裹成为 monadic value，以满足使用相同数据结构（类型）进行流程编排</p>
</blockquote>
<p>通常，Monad 需要具备下面两个方法：</p>
<ul>
<li><code>of(value)</code>: 能将任意数据类型的 <code>value</code> 包裹成一个 monadic value</li>
<li><code>chain(monad, f)</code>: 接受一个 monadic value，该方法能被 Monad 包裹的值，并通过 <code>f</code> 将其转换为另一个 monadic value。</li>
</ul>
<blockquote>
<p><strong>chain</strong> 在语义上表述了 monadic value 之间的转换串联，由于其内部能够解除值的包裹，有展开铺平的意味，因此也会被写作 <code>flatMap</code>。</p>
</blockquote>
<p>现在，为了将 Promise 和 callback 提升为 Monad，就需要实现 <code>of</code> 和 <code>chain</code> 方法，即确定如何将它们提升为 Monad，又如何串联它们形成的任务：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> createRunner = <span class="function">(<span class="params">&#123; <span class="keyword">of</span>, chain &#125;</span>) =&gt;</span> process =&gt; &#123;</span><br><span class="line">  <span class="comment">// 在 runner 实现内部，我们不再关心流程是 Promise 还是 callback，</span></span><br><span class="line">  <span class="comment">// 它们都能够视作 monad 进行处理</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">of</span>(process());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (task) &#123;</span><br><span class="line">      <span class="comment">// 记录任务进入暂态时的位置，便于后面知道刷新哪个位置的缓存</span></span><br><span class="line">      <span class="keyword">const</span> pos = ctx.pos;</span><br><span class="line">      <span class="keyword">return</span> chain(task, value =&gt; &#123;</span><br><span class="line">        <span class="comment">// 缓存当前执行结果</span></span><br><span class="line">        ctx.cache[pos] = value;</span><br><span class="line">        <span class="comment">// 重启流程</span></span><br><span class="line">        <span class="keyword">return</span> step();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 每次执行完，释放对上下文的掌控</span></span><br><span class="line">      context = cachedContext;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promiseRunner = createRunner(&#123;</span><br><span class="line">  <span class="keyword">of</span>: <span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">Promise</span>.resolve(v),</span><br><span class="line">  chain: <span class="function">(<span class="params">m, f</span>) =&gt;</span> m.then(f)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> callbackRunner = createRunner(&#123;</span><br><span class="line">  <span class="keyword">of</span>: <span class="function"><span class="params">v</span> =&gt;</span> callback =&gt; callback(v),</span><br><span class="line">  chain: <span class="function">(<span class="params">m, f</span>) =&gt;</span> callback =&gt; m(<span class="function"><span class="params">value</span> =&gt;</span> f(value)(callback))</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>关于 callback 的 <code>chain</code> 方法的推导，可以看这篇文章：<a href="https://itnext.io/promises-continuation-monad-in-javascript-f2d70ceb24a4" target="_blank" rel="noopener">https://itnext.io/promises-continuation-monad-in-javascript-f2d70ceb24a4</a></p>
</blockquote>
<p>现在，通过 <a href="https://codesandbox.io/s/monadrunner-uvljx" target="_blank" rel="noopener">CodeSandbox</a> 上的例子，你可以看到，我们的 Suspense 及 useState 都是基于同一 runner 进行实现。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://medium.freecodecamp.org/when-to-use-react-suspense-vs-react-hooks-f66ef94cb54f" target="_blank" rel="noopener">When to use React Suspense vs React Hooks</a></li>
<li><a href="https://curiosity-driven.org/monads-in-javascript" target="_blank" rel="noopener">Monads in JavaScript</a></li>
<li><a href="https://itnext.io/promises-continuation-monad-in-javascript-f2d70ceb24a4" target="_blank" rel="noopener">Promises &amp; Continuation Monad in JavaScript</a></li>
</ul>

      
    </div>

    
      
      

  <div class="post-copyright">
    <p class="copyright-item">
      <span>原文作者: </span>
      <a href="http://yoyoyohamapi.me">吴晓军</a>
    </p>
    <p class="copyright-item">
      <span>原文链接: </span>
      <a href="http://yoyoyohamapi.me/2019/07/16/React_Suspense与Hooks的另类实现/">http://yoyoyohamapi.me/2019/07/16/React_Suspense与Hooks的另类实现/</a>
    </p>
    <p class="copyright-item">
      <span>许可协议: </span>
      
      本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可
    </p>
  </div>



      
      
  <div class="post-reward">
    <input type="checkbox" name="reward" id="reward" hidden />
    <label class="reward-button" for="reward">赞赏支持</label>
    <div class="qr-code">
      
      
      
    </div>
  </div>

    

    
      <footer class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/函数式编程/">函数式编程</a>
            
              <a href="/tags/React/">React</a>
            
              <a href="/tags/Hooks/">Hooks</a>
            
          </div>
        
        
        
  <nav class="post-nav">
    
    
      <a class="next" href="/2019/04/08/使用_Hooks_创建异步组件/">
        <span class="next-text nav-default">使用 Hooks 创建异步组件</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

      </footer>
    

  </article>


          </div>
          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:softshot37@gmail.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
        
          <a href="https://github.com/yoyoyohamapi" class="iconfont icon-github" title="github"></a>
        
      
    
      
    
      
        
          <a href="https://www.zhihu.com/people/wu-xiao-jun-64-55/activities" class="iconfont icon-zhihu" title="zhihu"></a>
        
      
    
      
    
      
    
      
    
    
    
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>


<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2015 - 
    
    2019

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">吴晓军</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    
  
  <script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://yoyoyohamapi.me/2019/07/16/React_Suspense与Hooks的另类实现/';
        this.page.identifier = '2019/07/16/React_Suspense与Hooks的另类实现/';
        this.page.title = 'React Suspense 与 Hooks 的另类实现';
    };
    (function() {
    var d = document, s = d.createElement('script');

    s.src = '//yoyoyohamapi.disqus.com/embed.js';

    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();  
  </script>

  

  



    
  



  
  





  
    <script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  

  
    <script type="text/javascript" src="/lib/pjax/jquery.pjax.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/nprogress/nprogress.min.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.9.0"></script>

  <!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</body>
</html>
