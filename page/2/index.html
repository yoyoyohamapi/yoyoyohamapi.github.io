<!DOCTYPE html>
<html lang="">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="只要努力，蛆虫也能变成苍蝇翱翔于天际"/>







  <link rel="alternate" href="/atom.xml" title="吴小蛆的巣">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.4.x" />



<link rel="canonical" href="http://yoyoyohamapi.me/page/2/"/>


<meta name="description" content="只要努力，蛆虫也能变成苍蝇翱翔于天际">
<meta property="og:type" content="website">
<meta property="og:title" content="吴小蛆的巣">
<meta property="og:url" content="http://yoyoyohamapi.me/page/2/index.html">
<meta property="og:site_name" content="吴小蛆的巣">
<meta property="og:description" content="只要努力，蛆虫也能变成苍蝇翱翔于天际">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="吴小蛆的巣">
<meta name="twitter:description" content="只要努力，蛆虫也能变成苍蝇翱翔于天际">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.4.x" />







<script>
  var CONFIG = {
    search: false,
    searchPath: "/search.xml",
    fancybox: false,
    toc: true,
  }
</script>




  



    <title> 吴小蛆的巣 </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">吴小蛆的巣</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            Home
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            Archives
          
        </li>
      </a>
    
      <a href="/tags">
        <li class="mobile-menu-item">
          
          
            Tags
          
        </li>
      </a>
    
      <a href="/categories">
        <li class="mobile-menu-item">
          
          
            Categories
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">吴小蛆的巣</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              Home
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              Archives
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            
            
              Tags
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/categories">
            
            
              Categories
            
          </a>
        </li>
      
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  <section id="posts" class="posts">
    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/03/08/Image_Processing/数字图像处理（11）-- MATLAB实现自适应中值滤波(Adaptive Median Filter)/">数字图像处理（11）-- MATLAB 实现自适应中值滤波 (Adaptive Median Filter)</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Mar 8, 2017
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>在之前的图像降噪试验中，采取了一般的中值滤波方法，即选定窗口内的中间大小值作为输出像素的值，这在大部分情况都能反映窗口区域内像素的灰度情况。但是考虑到一种情况，假若窗口内分布着大量噪点，则选取的中值就有可能是噪声的灰度。为了避免这种情况，将在中值滤波过程中考虑对中值的判断及选取，这在 Gonzalez 的 <a href="http://item.jd.com/10658649.html" target="_blank" rel="external">《数字图像处理中》</a> 第五章称之为 Adaptive Median Filter。</p>
<p>其业务流程如下：</p>
<h3 id="首先确定窗口内几个主要参数："><a href="#首先确定窗口内几个主要参数：" class="headerlink" title="首先确定窗口内几个主要参数："></a>首先确定窗口内几个主要参数：</h3><ul>
<li><p>$z_{min}$: 窗口内最小灰度值（可能是 salt）</p>
</li>
<li><p>$z_{max}$: 窗口内最大灰度值（可能是 pepper）</p>
</li>
<li><p>$z_{mid}$: 窗口内中点灰度值</p>
</li>
<li><p>$z_{xy}$: 窗口中央元素灰度值</p>
</li>
<li><p>$S_{max}$: 最大允许窗口大小</p>
</li>
</ul>
<h3 id="对窗口内中值的判断分为如下两步："><a href="#对窗口内中值的判断分为如下两步：" class="headerlink" title="对窗口内中值的判断分为如下两步："></a>对窗口内中值的判断分为如下两步：</h3><p>####StageA：</p>
<blockquote>
<p>$A<em>1$ = $z</em>{mid}$ - $z_{min}$</p>
<p>$A<em>2$ = $z</em>{mid}$ - $z_{max}$</p>
<p>IF $A_1$&gt;0 AND $A_2$&lt;0 go to stageB // 当中值落在最大灰度与最小灰度间</p>
<p>Else increase the window size // 否则增加窗口大小重新选择中值直到合适</p>
<p>If window size&lt;=$S_max$ repeat StageA</p>
<p>Else output $z_{mid}$</p>
</blockquote>
<p>####StageB：</p>
<blockquote>
<p>$B<em>1$ = $z</em>{xy}$ - $z_{min}$</p>
<p>$B<em>2$ = $z</em>{xy}$ - $z_{max}$</p>
<p>// 当窗口中央元素不为噪声时，/ 窗口中央元素的优先级高于中值</p>
<p>If $B_1$&gt;0 AND $B<em>2$&lt;0 ,output $z</em>{xy}$</p>
<p>Else output $z_{mid}$</p>
</blockquote>
<p>具体实现代码如下:</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="params">[ imgDst ]</span> = <span class="title">adaptiveMedianFilter</span><span class="params">( imgSrc,kernelSize, maxKernelSize )</span></span></div><div class="line"><span class="comment">% 该函数完成自适应的中值滤波</span></div><div class="line">    <span class="comment">%params:    imgSrc: 原图像</span></div><div class="line">    <span class="comment">%           kernelSize: 卷积核大小（默认为 3）</span></div><div class="line">    <span class="comment">%           maxKernelSize: 卷积核大小（默认为 3）</span></div><div class="line">    </div><div class="line">    <span class="comment">%return:    imgDst: 输出图像</span></div><div class="line"></div><div class="line">    width = <span class="built_in">size</span>(imgSrc,<span class="number">1</span>);</div><div class="line">    height = <span class="built_in">size</span>(imgSrc,<span class="number">2</span>);  </div><div class="line">    </div><div class="line">    <span class="comment">% 需要填充的边缘厚度</span></div><div class="line">    numsPadding = <span class="built_in">floor</span>(maxKernelSize/<span class="number">2</span>);</div><div class="line">    imgPadded = <span class="built_in">zeros</span>([height+numsPadding*<span class="number">2</span>,width+numsPadding*<span class="number">2</span>]);</div><div class="line">    imgPadded(numsPadding+<span class="number">1</span>:numsPadding+height,numsPadding+<span class="number">1</span>:numsPadding+width) = imgSrc;</div><div class="line">    </div><div class="line">    <span class="comment">% 下面是自适应的中值滤波的循环过程</span></div><div class="line">    <span class="keyword">for</span> <span class="built_in">i</span>=numsPadding+<span class="number">1</span>:numsPadding+height</div><div class="line">        <span class="keyword">for</span> <span class="built_in">j</span>=numsPadding+<span class="number">1</span>:numsPadding+width</div><div class="line">            stageA( <span class="built_in">i</span>,<span class="built_in">j</span>,kernelSize,maxKernelSize,imgPadded );         </div><div class="line">        <span class="keyword">end</span></div><div class="line">    <span class="keyword">end</span></div><div class="line">    </div><div class="line">    <span class="comment">% 消去黑边</span></div><div class="line">    imgDst = imgPadded(numsPadding+<span class="number">1</span>:numsPadding+height,numsPadding+<span class="number">1</span>:numsPadding+width);</div><div class="line"></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="params">[ A1,A2,z,zMid,zMax,zMin ]</span> = <span class="title">stageA</span><span class="params">( i,j,kernelSize,maxKernelSize,imgPadded )</span></span></div><div class="line"><span class="comment">%Stage A:</span></div><div class="line">    <span class="keyword">while</span> <span class="number">1</span></div><div class="line">        <span class="comment">% 获得窗口内像素点</span></div><div class="line">        pixels = [];</div><div class="line">        <span class="keyword">for</span> k=-<span class="built_in">floor</span>(kernelSize/<span class="number">2</span>):<span class="built_in">floor</span>(kernelSize)/<span class="number">2</span></div><div class="line">            <span class="keyword">for</span> l=-<span class="built_in">floor</span>(kernelSize/<span class="number">2</span>):<span class="built_in">floor</span>(kernelSize)/<span class="number">2</span></div><div class="line">                pixels = [pixels imgPadded(i+k,j+l)];</div><div class="line">            <span class="keyword">end</span></div><div class="line">        <span class="keyword">end</span></div><div class="line">        len = <span class="built_in">length</span>(pixels);</div><div class="line">        zMax = max(pixels);</div><div class="line">        zMin = min(pixels);</div><div class="line">        zMid = median(pixels);</div><div class="line">        z = pixels((len+<span class="number">1</span>)/<span class="number">2</span>); </div><div class="line">        A1 = zMid - zMin;</div><div class="line">        A2 = zMid - zMax;</div><div class="line">        <span class="keyword">if</span> A1&gt;<span class="number">0</span> &amp;&amp; A2&lt;<span class="number">0</span></div><div class="line">            shouldBe = stageB(z,zMid,zMax,zMin);</div><div class="line">            imgPadded(<span class="built_in">i</span>,<span class="built_in">j</span>) = zMid;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            kernelSize = kernelSize + <span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span> kernelSize &gt; maxKernelSize</div><div class="line">                 imgPadded(<span class="built_in">i</span>,<span class="built_in">j</span>) = zMid;</div><div class="line">                 <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">end</span></div><div class="line">        <span class="keyword">end</span></div><div class="line">    <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="params">[shouldBe]</span> = <span class="title">stageB</span><span class="params">(z,zMid,zMax,zMin)</span></span></div><div class="line"><span class="comment">%Stage B:</span></div><div class="line">    B1 = z-zMin;</div><div class="line">    B2 = z-zMax;</div><div class="line">    <span class="keyword">if</span> B1&gt;<span class="number">0</span> &amp;&amp; B2&lt;<span class="number">0</span></div><div class="line">        shouldBe = z;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        shouldBe = zMid;</div><div class="line">    <span class="keyword">end</span>   </div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>测试代码如下：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><div class="line">clear all;</div><div class="line">close all;</div><div class="line">imgPath = <span class="string">'malight.bmp'</span>;</div><div class="line">imgSrc = imread(imgPath);</div><div class="line"><span class="comment">% 加入噪声</span></div><div class="line">imgNoised = imnoise(imgSrc,<span class="string">'salt &amp; pepper'</span>,<span class="number">0.02</span>);</div><div class="line">mKernelSize = <span class="number">3</span>;</div><div class="line">imgDst1 = medianFilter(imgNoised,mKernelSize);</div><div class="line">mKernelSize = <span class="number">5</span>;</div><div class="line">imgDst2 = medianFilter(imgNoised,mKernelSize);</div><div class="line">mkernelSize = <span class="number">3</span>;</div><div class="line">maxKernelSize = <span class="number">7</span>;</div><div class="line">tic</div><div class="line">imgDst3 =  adaptiveMedianFilter( imgSrc,mKernelSize, maxKernelSize);</div><div class="line">toc</div><div class="line"><span class="comment">% 显示实验结果</span></div><div class="line">figure(<span class="string">'NumberTitle'</span>, <span class="string">'off'</span>, <span class="string">'Name'</span>, <span class="string">'中值滤波降噪'</span>);</div><div class="line">subplot(<span class="number">221</span>);</div><div class="line">imshow(imgSrc);</div><div class="line">title(<span class="string">'原图像'</span>);</div><div class="line">subplot(<span class="number">222</span>);</div><div class="line">imshow(imgNoised,[]);</div><div class="line">title(<span class="string">'噪声图像'</span>);</div><div class="line">subplot(<span class="number">223</span>);</div><div class="line">imshow(imgDst1,[]);</div><div class="line">title(<span class="string">'卷积核大小为 3 的中值滤波'</span>);</div><div class="line">subplot(<span class="number">224</span>);</div><div class="line">imshow(imgDst3,[]);</div><div class="line">title(<span class="string">'最大卷积核为 7 的自适应中值滤波'</span>);</div></pre></td></tr></table></figure>
<p>执行效果：</p>
<p><img src="http://7pulhb.com1.z0.glb.clouddn.com/ip - 自适应中值滤波. jpg" alt="自适应中值滤波与一般中值滤波效果对比"></p>
<p>令人遗憾的是，虽然自适应中值滤波会带来更好的降噪效果，但是也会带来更长的时间开销，处理一张 256*256 大小的灰度图耗时达到了 240~250 秒左右(这有很大一部分原因是我的算法尚未优化所导致的)。</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/03/08/Image_Processing/数字图像处理（14）-- 颜色知识(1)：CIE色度图/">数字图像处理（14）-- 颜色知识 (1)：CIE 色度图</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Mar 8, 2017
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>CIE（国际照明委员会）色度图：</p>
<p><img src="http://7pulhb.com1.z0.glb.clouddn.com/ip - 色度图. jpg" alt="色度图 1"></p>
<p><img src="http://7pulhb.com1.z0.glb.clouddn.com/ip - 色度图 2.jpg" alt="色度图 2"></p>
<p>明度、色调和饱和度称为颜色视觉三特性。 明度就是明亮的程度； 色调是由波长决定的色别，如 700nm 光的色调是红色，579nm 光的色调是黄色，510nm 光的色调是绿色等等； 饱和度就是纯度，没有混入白色的窄带单色，在视觉上就是高饱和度的颜色。光谱所有的光都是最纯的颜色光，加入白色越多，混合后的颜色就越不纯，看起来也就越不饱和。</p>
<p>$(Color)=R(R)+G(G)+B(B)$ 式中，$(C)$ 代表某一种颜色，$(R)、$(G)$、$(B)$ 是红、绿、蓝三基色，$R$、$G$、$B$ 是每种颜色的比例系数，它们的和等于 $1$，即 $R+G+B=1$，“C” 是指匹配即在视觉上颜色相同，如某一蓝绿色可以表达为： </p>
<p>$(C)=0.06(R)+0.31(G)+0.63(B)$</p>
<p>关于色度图的解释如下：</p>
<p>色度图的边缘称为光谱轨迹，其中 590nm 这些数字代表波长。</p>
<p>横轴表示红基色的比例，纵轴表示绿基色的比例，当中没有专门的第三轴来表示兰基色的比例，因为兰基色的比例可由 R+B+R=1 推知。</p>
<p>设色度图上有一颜色 S，由 C 通过 S 画一直线至光谱轨迹 O 点（590nm），S 颜色的主波长即为 590nm，此处光谱的颜色即 S 的色调（橙色）。某一颜色离开 C 点至光谱轨迹的距离表明它的色纯度，即饱和度。颜色越靠近 C 越不纯，越靠近光谱轨迹越纯。S 点位于从 C 到 590nm 光谱轨迹的 45% 处，所以它的色纯度为 45%（色纯度 %=（CS/CO）×100。从光谱轨迹的任一点通过 C 画一直线抵达对侧光谱轨迹的一点，这条直线两端的颜色互为补色（虚线）。从紫红色段的任一点通过 C 点画一直线抵达对侧光谱轨迹的一点，这个非光谱色就用该光谱颜色的补色来表示。表示方法是在非光谱色的补色的波长后面加一 C 字，如 536G，这一紫红色是 536nm 绿色的补色。 CIE1931 色度图有很大的实用价值，任何颜色，不管是光源色还是表面色，都可以在这个色度图上标定出来，这就使颜色的描述简便而准确了。例如为了保证颜色标志的正确辨认和交通安全的管制，在 CIE1931 色度图上规定了具体的范围，它适用于各种警告信号和颜色标志的编码。再如在 CIE1931 色度图上，可推出由两种颜色相混合所得出的各种中间色。如 Q 和 S 相加，得出 Q 到 S 直线的各种中间颜色，如 T 点，由 C 通过 T 抵达 552nm 的光谱色，可由 552nm 的波长颜色看出 T 的色调，并可由 T 在 C 与 552nm 光谱色之间所占位置看出它的纯度。 在实际应用中，如彩色电视、彩色摄影（乳胶处理）或其它颜色复现系统都需要选择适当的红（R）、绿（G）、蓝（B）三基色，用来复现白色和各种颜色，所选定的（R）、（G）、（B）在色度图上的位置形成一个三角形。应使（R）、（G）、（B）三角形尽量能包括较大面积，同时（R）、（G）、（B）线应尽量靠近光谱轨迹，以复现比较饱和的红、绿、蓝等颜色。</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/03/08/Image_Processing/数字图像处理（13）-- 图像修复及重建(2)：关于降质函数的探讨/">数字图像处理（13）-- 图像修复及重建 (2)：关于降质函数的探讨</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Mar 8, 2017
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>在上一章中，我们着重讨论了图像受噪声污染而引起的质量下降，本章，将考虑原图像受某个降质函数的影响而引起的图像质量下降。</p>
<p>其频率域的降质模型为：</p>
<span>$$G(u,v)=F(u,v)H(u,v)+N(u,v)$$</span><!-- Has MathJax -->
<p>其中：$G(u,v)$ 为质量下降后的图像的傅里叶变换,$H(u,v)$ 为降质函数的傅里叶变换,$F(u,v)$ 为原图像的傅里叶变换,$N(u,v)$ 为噪声图像的傅里叶变换。</p>
<p>##1. 逆滤波（Inverse Filtering）<br>这是一种概念上最为简单的图像修复方式，即我们考虑修复后的图像为：</p>
<span>$$\widehat{F}(u,v)=\frac{G(u,v)}{H(u,v)}$$</span><!-- Has MathJax -->
<p>亦即：</p>
<span>$$\widehat{F}(u,v)=F(u,v)+\frac{N(u,v)}{H(u,v)}$$</span><!-- Has MathJax -->
<p> 从上式不难看出，即便我们知道了降质函数 H，假如噪声 N 未知，我们仍然无法估计出修复后的图像，并且，若 H 在某一点取很小的值，也会导致整个式子无意义（因为此时 $\frac{N(u,v)}{H(u,v)}$ 将无限大，即原图像被无限忽视）。故而在实际应用中，我们考虑截断 H 中较小的值，即截断 H 的频谱图中远离中心位置的分量。</p>
<p>##2. 维纳滤波（Wiener Filtering）<br>维纳滤波也称为最小均方差滤波（Minimum Mean Square Error Filtering），最小均方差滤波的目标是要找到一个原图像的估计 $\hat{f}$ 与原图像 f 的最小误差，其中，误差的定义式如下：</p>
<span>$$e^2=E{(f-\hat{f})^2}$$</span><!-- Has MathJax -->
<p>其中，E 是期望。</p>
<p>现在，假定：</p>
<p>图像，噪声相互独立<br>图像或者噪声其一有 0 均值<br>$\hat{f}$ 的灰度是关于 f 灰度的线性函数<br>由以上假定，可以由如下式子保证 $\hat{f}$ 与 f 之间的误差最小;</p>
<span>$$$\widehat{F}(u,v)=[\frac{1}{H(u,v)}\frac{|H(u,v)|^2}{|H(u,v)|^2+S_\eta(u,v)/S_f(u,v)}]G(u,v)$$</span><!-- Has MathJax -->
<p> 其中，$S_\eta(u,v)=|N(u,v)|^2$ 即噪声的功率谱，$S_f(u,v)=|F(u,v)|^2$ 即未退化的图像的功率谱。</p>
<p>值得注意的时，若 $|N(u,v)|^2$ 为零，则维纳滤波退化成了逆滤波。同时，当我们处理白噪声是，$|N(u,v)|^2$ 通常是一个常数，这就大大简化了处理难度，但是，$|F(u,v)|^2$ 仍然未知，通常，我们选择用一个常数 K 来近似 $\frac{S_\eta(u,v)}{S_f(u,v)}$, 得到了如下维纳滤波表达式：</p>
<span>$$\widehat{F}(u,v)=[\frac{1}{H(u,v)}\frac{|H(u,v)|^2}{|H(u,v)|^2+K}]G(u,v)$$</span><!-- Has MathJax -->
<p>##3. 图像质量的度量标准;</p>
<h3 id="信噪比-SNR（signal-to-noise-ratio）"><a href="#信噪比-SNR（signal-to-noise-ratio）" class="headerlink" title="信噪比 SNR（signal-to-noise-ratio）"></a>信噪比 SNR（signal-to-noise-ratio）</h3><span>$$SNR=\frac{\sum\limits_{u=0}^{M-1}\sum\limits_{v=0}^{N-1}|F(u,v)|^2}{\sum\limits_{u=0}^{M-1}\sum\limits_{v=0}^{N-1}|(u,v)|^2}$$</span><!-- Has MathJax -->
<p>该标准是通过原图像与附加噪声间的比例关系来衡量图像质量，显然，该值越大，图像质量越高。</p>
<h3 id="均方差-MSE（mean-square-error）"><a href="#均方差-MSE（mean-square-error）" class="headerlink" title="均方差 MSE（mean square error）"></a>均方差 MSE（mean square error）</h3><span>$$MSE=\frac{1}{MN}\sum\limits_{x=0}^{M-1}\sum\limits_{y=0}^{N-1}[f(x,y)-\hat{f}(x,y)]^2$$</span><!-- Has MathJax -->
<p>该标准是通过比较估计图像与原图像间的差异来衡量图像修复情况的。值越小，修复越成功。</p>
<h3 id="空间域的信噪比-SNR"><a href="#空间域的信噪比-SNR" class="headerlink" title="空间域的信噪比 SNR"></a>空间域的信噪比 SNR</h3><span>$$SNR=\frac{\sum\limits_{x=0}^{M-1}\sum\limits_{y=0}^{N-1}\hat{f}(x,y)^2}{\sum\limits_{x=0}^{M-1}\sum\limits_{y=0}^{N-1}[f(x,y)-\hat{f}(x,y)]^2}$$</span><!-- Has MathJax -->

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/03/08/Image_Processing/数字图像处理（16）-- 颜色知识(3)：伪彩色图像处理/">数字图像处理（16）-- 颜色知识 (3)：伪彩色图像处理</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Mar 8, 2017
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>伪彩色图像处理，顾名思义，其操作对象并非彩色图像，而是一般的灰度图像，伪彩色图像处理即将一般的灰度图像转换为彩色图像。</p>
<h2 id="灰度切割："><a href="#灰度切割：" class="headerlink" title="灰度切割："></a>灰度切割：</h2><p>那么如何将一般的灰度转换为彩色呢？我们首先会想到人工赋予每个灰度或者每个灰度级一个彩色值，这便是灰度切割，或者说是强度切割。</p>
<p><img src="http://7pulhb.com1.z0.glb.clouddn.com/ip - 灰度切割. png" alt="灰度切割"></p>
<h2 id="变换函数："><a href="#变换函数：" class="headerlink" title="变换函数："></a>变换函数：</h2><p>该方法将原始灰度通过变换函数形成彩色向量，如下图所示：</p>
<p><img src="http://7pulhb.com1.z0.glb.clouddn.com/ip - 变换函数. png" alt="变换函数"></p>
<p>伪彩色处理的目的还是在于通过更醒目的颜色突出原图像某些区域。</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/03/08/Image_Processing/数字图像处理（15）-- 颜色知识(2)：颜色模型/">数字图像处理（15）-- 颜色知识 (2)：颜色模型</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Mar 8, 2017
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>###RGB 颜色模型：<br>该模型使用红绿蓝三基色构成的三维向量来表示某一颜色，这种表示所具有的颜色语义是相当清楚的，然而并不能很好地适应人的视觉特点也不利于印刷。</p>
<p><img src="http://7pulhb.com1.z0.glb.clouddn.com/ip-RGB 颜色模型. jpg" alt="RGB 颜色模型"></p>
<p>在 RGB 颜色模型的三维空间中，可以看到，立方体的对角线恰好是灰度。</p>
<p>同时，有如下几个概念需要明确：</p>
<p><strong>色深 (depth)</strong>：是用 bit 数来表示数码影像色彩数目的单位。例如（23，127，240）就是 24 位色深（8bit * 3），那么总的颜色数就为 224≈16,777,216 ，即 24 位色深能够表达约 1600 万种颜色，这十分接近人能够分辨的色彩范围。</p>
<p><strong>安全色</strong>：不同的平台（Mac、PC 等）有不同的调色板，不同的浏览器也有自己的调色板。这就意味着对于一幅图，显示在 Mac 上的 Web 浏览器中的图像，与它在 PC 上相同浏览器中显示的效果可能差别很大。为了解决各平台调色板的差异，就有了 web 安全色的概念。在该模型中，用相应的 16 制进制值 00、33、66、99、CC 和 FF 的组合（可重复选取）来表达颜色，这也就意味着，web 安全色共有 6<em>6</em>6=216 种。</p>
<p><img src="http://7pulhb.com1.z0.glb.clouddn.com/ip-web 安全色. jpg" alt="web 安全色"></p>
<p>##CMY 及 CMYK 颜色模型：<br>CMYK 也称作印刷色彩模式，是一种依靠反光的色彩模式，和 RGB 类似，CMY 是 3 种印刷油墨名称的首字母：青色 Cyan、品红色 Magenta、黄色 Yellow。其中 K 是源自一种只使用黑墨的印刷版 Key Plate。从理论上来说，只需要 CMY 三种油墨就足够了，它们三个加在一起就应该得到黑色。但是由于目前制造工艺还不能造出高纯度的油墨，CMY 相加的结果实际是一种暗红色。</p>
<p><img src="http://7pulhb.com1.z0.glb.clouddn.com/ip-CMYK.jpg" alt="CMYK"></p>
<p>##HSI 颜色模型：</p>
<p><strong>色调 H(Hue)</strong>： 与光波的波长有关，它表示人的感官对不同颜色的感受，如红色、绿色、蓝色等，它也可表示一定范围的颜色，如暖色、冷色等。<br>饱和度 S(Saturation)： 表示颜色的纯度，纯光谱色是完全饱和的，加入白光会稀释饱和度。饱和度越大，颜色看起来就会越鲜艳，反之亦然。</p>
<p><strong>强度 I(Intensity)</strong>： 对应成像亮度和图像灰度，是颜色的明亮程度。<br>HSI 模型的建立基于两个重要的事实： ① I 分量与图像的彩色信息无关；② H 和 S 分量与人感受颜色的方式是紧密相联的。这些特点使得 HSI 模型非常适合彩色特性检测与分析。<br>HSI 最大的优势就是分离了‘灰度’与颜色信息，这样，一般的会读操作就可以对 HSI 图像直接应用。</p>
<p>##Lab 颜色模型：</p>
<p>Lab 颜色空间中的 L 分量用于表示像素的亮度，取值范围是 [0,100], 表示从纯黑到纯白；a 表示从红色到绿色的范围，取值范围是 [127,-128]；b 表示从黄色到蓝色的范围，取值范围是 [127,-128]。<br>不难看出，Lab 颜色空间同样很好的分离了颜色和亮度信息，并且 a,b 分别都是表示颜色间的渐变程度，而非颜色自己本身，这样做的好处据说是更加利于人的视觉特性。</p>
<p>Lab 颜色空间有如下优势：</p>
<ul>
<li><p>基于生理特征描述人类对于颜色的感觉。</p>
</li>
<li><p>设备独立，也就是说适用于显示设别，印刷设备乃至输入设备。</p>
</li>
</ul>
<p>在数字图像处理中，Lab 颜色模型有利于：</p>
<ul>
<li><p>色调及对比度的编辑。</p>
</li>
<li><p>图像压缩。</p>
</li>
</ul>
<p>在 PhotoShop 中，图像编辑所采用的颜色模型正是 Lab 颜色模型。</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/03/08/Sails_Tutorial/利用sails.js+mongodb开发博客系统(1)--创建项目/">利用 Sails.js+MongoDB 开发博客系统 (1)-- 创建项目</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Mar 8, 2017
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h2 id="Sails-js-简介"><a href="#Sails-js-简介" class="headerlink" title="Sails.js 简介"></a>Sails.js 简介</h2><p>Sails 是构建于 <a href="http://expressjs.com/" target="_blank" rel="external">Express</a> 之上的一个实时 Node MVC 框架，其整个风格来源于<a href="http://rubyonrails.org/" target="_blank" rel="external">Ruby on Rails</a>, 包括提供了类似于 Rails 的脚手架功能，同时又吸纳了不少现代 web app 工具和功能，比如 grunt 和 websocket 等。</p>
<p>显然，Sails 的最佳应用场景会是一些实时性较强的场景，比如聊天室，游戏等，但是官方也笃定的认为 sails 适用于任何 web app 的开发。对于 web 之前我已经使用过了的 php 的 symfony2 和 ruby 的 rails，但在学习了 Nodejs 之后，我需要一个 node 的框架进行项目实战，因此，我充满感性的因为那只小章鱼和官网健全的文档选择了 sails，这一点都不机智。</p>
<p>本教程（也可以说是开发日志）将帮助各位开发一个基本的个人技术博客站点，旨在让大家熟悉 sails 的开发流程，并且在好好的串联一下有关 js，有关前端，有关 mongo 的相关知识，真正要搭建一个健壮的博客系统，教程上的内容还远远不够，需要各位自己努力。</p>
<p><a href="https://github.com/yoyoyohamapi/blog" target="_blank" rel="external">项目 demo 的源码</a>已经托管到了 github，方便各位在遇到困惑的时候进行查阅。</p>
<p><img src="http://www.sailsjs.org/images/bkgd_squiddy.png" alt="sails"></p>
<h2 id="前驱知识"><a href="#前驱知识" class="headerlink" title="前驱知识"></a>前驱知识</h2><p>在完成博客系统搭建前，你需要去认识或者学习以下罗列出的几门知识，个人认为，每次新技能 get 是会带来如同网游中技能树成长的快感的。</p>
<ul>
<li><p><a href="https://nodejs.org/" target="_blank" rel="external"><strong>Node.js</strong></a>:</p>
<p>  要注意，Node 并非 javascript 一个框架，相比框架，Node 更加底层。其实 Node.js 归为前驱知识也并不必要，因为大部分想要利用 Sails 来构建博客系统的读者在之前已经对 Node.js 有所接触了。</p>
<p>  教程：任何工程技术最好的教学资料一定是官方文档(理由不是官方文档写的多么精彩，而是足够时效)，除了官方文档外，我的 Node 启蒙还有<a href="http://item.jd.com/11457487.html" target="_blank" rel="external">《Node.js 实战》</a>。</p>
</li>
</ul>
<ul>
<li><p><a href="http://gruntjs.com/" target="_blank" rel="external"><strong>Grunt（智慧野猪）</strong></a>:</p>
<p>  一个前端自动化构建工具，从现在开始，应当把以前你那混乱不堪，毫无优化的前端代码扔到历史的垃圾桶了，我们需要<strong>Grunt</strong>让我们的前端更加智慧。Grunt 本意是 “咕噜声”, 官方也是贴切的采用了野猪作为其 Logo，猪是一种大智若愚的动物，而<strong>Grunt</strong>“愚 “在一定学习成本，配置撰写，“智” 在撰写完成后行云流水的自动化构建体验。</p>
</li>
<li><p><a href="http://bower.io/" target="_blank" rel="external"><strong>Bower（美丽园丁鸟）</strong></a>:</p>
<p>  <strong>Bower</strong>是一个前端插件管理器，类似于 PHP 的<a href=""><strong>composer</strong></a>,<strong>bower</strong>能够帮助开发者脱离手动下载包，手动管理包的依赖关系等等繁重业务劳动。BTW, 似乎前端这个技术的 Logo（看见小鸟嘴上衔着的叶纸了吗，是不是就是那片璀璨的 jquery 哇）总是设计精良，名字也是诗意盎然（勤劳如园丁鸟，衔取树枝木条，造就景观大厦），相比之下，<strong>composer</strong>那残念的指挥家简直不能看。</p>
</li>
</ul>
<p>对于<strong>Grunt</strong>和<strong>Bower</strong>的学习，除了官方资料外，<a href="https://github.com/materliu" target="_blank" rel="external">materliu</a>的 <a href="http://www.imooc.com/learn/30" target="_blank" rel="external">视频教程</a> 十分推荐，PPT 制作精良，讲解也充满文艺气息，风格非常对我胃口。</p>
<ul>
<li><p><a href="http://sass-lang.com/" target="_blank" rel="external"><strong>Sass</strong></a> &amp; <a href="http://compass-style.org/" target="_blank" rel="external"><strong>Compass</strong></a>:</p>
<p>  <strong>Sass</strong>能够程序化我们的 css，提高了我们 css 代码的重用性，而<strong>Compass</strong>则又让 Sass 变得无比强大。借助于<strong>Compass</strong>，我们现在甚至都只用一句话就能写出一个健壮的 box shadow，而不用在充满疲惫地去为该属性添加一个个内核前缀。</p>
</li>
<li><p><a href="http://requirejs.org/" target="_blank" rel="external"><strong>RequireJS</strong></a>: 其实我是国内 <a href="">Seajs</a> 的忠实拥趸，但是考虑到更好的兼容性，前端模块化开发这次选择了<strong>RequireJS</strong>，如果你曾经接触过<strong>Seajs</strong>，那么学习<strong>RequireJS</strong>并不是难事。</p>
</li>
</ul>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="基础设施"><a href="#基础设施" class="headerlink" title="基础设施"></a>基础设施</h3><ol>
<li>node 环境搭建：<a href="https://github.com/joyent/node/wiki/Installing-Node.js-via-package-manager" target="_blank" rel="external">戳我</a></li>
<li>ruby 环境搭建：<a href="https://www.ruby-lang.org/en/documentation/" target="_blank" rel="external">戳我</a></li>
<li>mongodb 安装：<a href="https://www.mongodb.org/downloads" target="_blank" rel="external">戳我</a></li>
</ol>
<hr>
<h3 id="编辑器-or-IDE"><a href="#编辑器-or-IDE" class="headerlink" title="编辑器 or IDE"></a>编辑器 or IDE</h3><p>如果是想用编辑器开发，<a href="http://www.sublimetext.com/" target="_blank" rel="external">sublime</a>依旧会是首选，git 官方出品的 <a href="https://atom.io/" target="_blank" rel="external">Atom</a> 目前也发布了 1.0 稳定版，大家可以尝鲜。如果是 IDE，作为 jetbrain 家的铁粉，会强烈推荐<a href="https://www.jetbrains.com/webstorm/" target="_blank" rel="external">webstorm</a>，各种愉悦，爽快加轻松不一一列举辣。</p>
<hr>
<h2 id="项目创建"><a href="#项目创建" class="headerlink" title="项目创建"></a>项目创建</h2><h3 id="安装-sails"><a href="#安装-sails" class="headerlink" title="安装 sails"></a>安装 sails</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">sudo npm -g install sails</div></pre></td></tr></table></figure>
<h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">sails new blog</div></pre></td></tr></table></figure>
<p>如此这般，我们就在当前目录下创建了一个 sails 项目（如果你知道<a href="http://yeoman.io/" target="_blank" rel="external">Yeoman</a>, 那也不建议用<strong>Yeaman</strong>来创建项目，上面 sails 的相关构建器（generator）已经许久没有更新了）。</p>
<h2 id="目录结构："><a href="#目录结构：" class="headerlink" title="目录结构："></a>目录结构：</h2><p><img src="http://7pulhb.com1.z0.glb.clouddn.com/sails - 目录结构. png" alt="sails 目录结构"></p>
<p>__blog</p>
<p>..<strong>api</strong>: 存放业务逻辑，数据模型，安全策略等</p>
<p>..<strong>assets</strong>: 用过 web 开发框架应该对此很熟悉，就是存放图像，js，css 等静态资源的目录，值得一提的是，sails 项目运行起来后，静态资源会被 grunt 中配置的响应任务压缩并转移到. tmp 文件下，即网站上对这些资源的寻址实际也是定位到. tmp 下，这样做有两个好处：</p>
<pre><code>1. 压缩的资源能够提高网页的加载和访问效率。
2. 保留了源文件，便于开发者调试和修改。
</code></pre><p>..<strong>config</strong>: 配置文件存放目录</p>
<p>..<strong>node_modules</strong>: node 包存放目录</p>
<p>..<strong>tasks</strong>: grunt 任务存放目录, 我们可以将自己撰写的 grunt 任务放到<strong>tasks/config</strong>目录下，然后在<strong>tasks/register</strong>注册任务，就能够通过 grunt 执行我们的构建过程了。</p>
<p>..<strong>views</strong>: 视图存放目录</p>
<hr>
<h2 id="Grunt-Tasks-说明"><a href="#Grunt-Tasks-说明" class="headerlink" title="Grunt Tasks 说明"></a>Grunt Tasks 说明</h2><p><img src="http://7pulhb.com1.z0.glb.clouddn.com/sails-grunt_tasks.png" alt="grunt task"></p>
<p>###tasks/config / 下配置任务说明</p>
<ul>
<li><strong>clean.js</strong>: </li>
</ul>
<p><strong>dev</strong>模式下，清除<strong>.tmp</strong>目录下文件，亦即给项目一个干净的启动状态。<strong>build</strong>模式下，清除<strong>www</strong>目录。</p>
<ul>
<li><strong>coffee.js</strong>: </li>
</ul>
<p>将<strong>assets/js</strong>下的 js 文件转化成 CoffeScript 并输出至<strong>.tmp/public</strong>目录。</p>
<ul>
<li><strong>concat.js</strong>: </li>
</ul>
<p>文件合并，将已经注入到页面的各个 js 及各个 css 文件合并，并输出至<strong>.tmp/public</strong>目录。</p>
<ul>
<li><strong>copy.js</strong>: </li>
</ul>
<p>文件复制，<strong>dev</strong>模式下，将<strong>assets</strong>下的资源复制到<strong>.tmp/public 目录</strong>。<strong>build</strong>模式下，将<strong>.tmp/public</strong>目录下文件复制到<strong>www</strong>目录下。</p>
<ul>
<li><strong>cssmin.js</strong>:</li>
</ul>
<p>将<strong>concat.js</strong>合并好的 css 文件压缩。</p>
<ul>
<li><strong>jst.js</strong>: </li>
</ul>
<p>预编译模板（模板引擎为 jst）。</p>
<ul>
<li><strong>less.js</strong>: </li>
</ul>
<p>因为我们用了 sass，所以不再考虑用 less。</p>
<ul>
<li><strong>sails-linker.js</strong>: </li>
</ul>
<p>sails 链接器，当你在 html 文件中插入</p>
<p><img src="http://7pulhb.com1.z0.glb.clouddn.com/sails-sails_linkers.png" alt="sails_linker"></p>
<p>等代码包裹块后，该任务能够自动注入在<strong>pipeline.js</strong>中设置好的 js 文件，css 文件的注入也类似。注入后的文件输出至<strong>.tmp/public</strong>目录及<strong>views</strong>目录。</p>
<ul>
<li><strong>sync.js</strong>: </li>
</ul>
<p>同步两个目录，这里同步的是<strong>assets</strong>目录和. tmp/public，该任务和<strong>copy.js</strong>任务非常类似，不同的是，同步仅发生在文件改变时。</p>
<ul>
<li><strong>uglify.js</strong>: </li>
</ul>
<p>这个大家不会陌生，用来压缩 js 文件的，这里的压缩对象是<strong>concat.js</strong>合并好的 js 文件。</p>
<ul>
<li><strong>watch.js</strong>: </li>
</ul>
<p>文件监听，当文件改变时触发相应地任务，如在 sails 中，<strong>aseests</strong>等目录下的文件变化时，会触发 [<strong>syncAssets</strong> , <strong>linkAssets</strong>] 这一任务流，该任务流中的这两个任务会在之后介绍。</p>
<h3 id="tasks-register-下注册的任务流说明"><a href="#tasks-register-下注册的任务流说明" class="headerlink" title="tasks/register / 下注册的任务流说明"></a>tasks/register / 下注册的任务流说明</h3><ul>
<li><strong>compileAssets.js</strong>:</li>
</ul>
<p>顾名思义, 该任务旨在编译<strong>assets</strong>目录下文件，该任务流的任务执行过程为:</p>
<p>clean:dev –》 jst:dev –》  less:dev –》 copy:dev –》 coffee:dev</p>
<p>亦即：缓存清除 –》编译 jst 至<strong>.tmp/public</strong> –》编译 less 至<strong>.tmp/publc</strong> –》剩余文件 (字体，图片等) 拷贝至<strong>.tmp/public</strong> –》js 转换成 coffeescript2 至<strong>.tmp/public</strong></p>
<ul>
<li><strong>linkAssetsXXXX.js</strong>:</li>
</ul>
<p>利用<strong>sails-linker</strong>, 完成一系列的注入操作</p>
<ul>
<li><strong>syncAssets.js</strong>:</li>
</ul>
<p>同步<strong>assets/</strong>目录下文件的任务流，其过程为：</p>
<p>jst:dev –》 less:dev –》 sync:dev –》coffee:dev</p>
<p>中文释义不再赘述。</p>
<ul>
<li><strong>default.js</strong>:</li>
</ul>
<p>该任务流会在 grunt 命令后不接任何参数时执行，其任务过程为：</p>
<p>compileAssets –》 linkAssets –》 watch，即编译，链接，运行时监听（这个工作过程学过<strong>操作系统</strong>的同学不会陌生）</p>
<ul>
<li><strong>build.js</strong>:</li>
</ul>
<p>构建任务流，因为这只是完成构建任务，故而其任务过程相比较<strong>default.js</strong>, 不再监听文件改动，而是在任务流末尾执行 clean，copy 等任务打扫下战场。</p>
<ul>
<li><strong>buildProd.js</strong>:</li>
</ul>
<p>只是在产品环境（production）下的构建过程，相比较于<strong>build.js</strong>，会执行一些文件合并及压缩工作来提高页面访问体验和效率。</p>
<hr>
<h2 id="扬帆起航（Sails-lift）"><a href="#扬帆起航（Sails-lift）" class="headerlink" title="扬帆起航（Sails lift）"></a>扬帆起航（Sails lift）</h2><p>OK，现在我们可以启动项目了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">sails lift</div></pre></td></tr></table></figure>
<p>不带参数 lift 过程默认会执行的 grunt 任务流为<strong>default.js</strong>。(lift 的详细参数使用说明可以通过 <code>sails lift -h</code> 查看)<br>接下来在浏览器输入 <a href="http://localhost:1337，你应该能够看到如下页面：" target="_blank" rel="external">http://localhost:1337，你应该能够看到如下页面：</a><br><img src="http://7pulhb.com1.z0.glb.clouddn.com/sails-sais_lift.png" alt="sais lift"></p>
<hr>
<h2 id="章节预告"><a href="#章节预告" class="headerlink" title="章节预告"></a>章节预告</h2><p>在下一章当中，我们不会立即开始博客系统开发，而是先对 sails 再进行一定的配置和改造，使其能够更加方便我们的代码编写。</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/03/08/Image_Processing/数字图像处理（18）-- 颜色知识(5)：图像金字塔/">数字图像处理（18）-- 颜色知识 (5)：图像金字塔</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Mar 8, 2017
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>为什么我们需要处理不同分辨率下的图像，这还是因为分辨率直接关系到我们对于图像上目标的识别，例如，一些极为细致的景物我们就需要在高分表率下观察，否则在高分辨率下的一坨鼻屎在低分辨率下可能就会糊成一滩雀斑。但这也不能否定掉低分辨率的作用，比如广袤的原野，无论在高分辨率下还是低分辨率下，它都是原野，那么，小体积，少信息量的低分辨率图像更加利于加快我们的处理速度。</p>
<p>首先认识图像金字塔：<br>图像金字塔，堂堂五个字，能够反映其气节的还是金字塔三个字。金字塔是什么形状的？由下至上横截面积不断缩小直至近似为一个点，在图像金字塔中，金字塔是一副图像对应的不同分辨率图像的集合，金字塔每层的横截面就是该图像对应的某个分辨率，通常金字塔底部为图像原始分辨率，由上至下每层分辨率缩小 2 倍，至金字塔塔尖，分辨率为 1x1，亦即缩小为一点。</p>
<p>图像金字塔主要分为<strong>近似金字塔(approximation pyramid)</strong>, 亦称为<strong>高斯金字塔</strong>，和<strong>预测残差金字塔(predication residual pyramid)</strong>，亦称<strong>拉普拉斯金字塔</strong>。</p>
<p>下图是二者的建立过程（插入滤波器的译法实在不好，应当是插值滤波器）：</p>
<p><img src="http://7pulhb.com1.z0.glb.clouddn.com/ip - 金字塔建立过程. jpg" alt="金字塔建立过程"></p>
<p>第 J 层的分辨率图像先与近似滤波器作用，完成向下 2 倍的采样，这样便得到了第 J-1 层的图像，分什么称之为近似图像，就是因为图像尽管变模糊了，但大致还是和 j 层输入图像类似。其实，金字塔向下 (向塔尖方向) 的过程就是 “近似” 过程。</p>
<p>该近似图像再通过插值滤波器向上进行 2 倍采样，得到了预测图像（向上，即向金字塔底部的过程就是对图像的预测，由近似图像预测原图像），原图像与预测图像做差就得到了预测残差图像。</p>
<p>在 opencv2 中，通过</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">pyrDown()</div></pre></td></tr></table></figure>
<p>方法对图像进行向下采样，得到原图像的近似.</p>
<p>通过</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">pyrUp()</div></pre></td></tr></table></figure>
<p>方法对近似图像进行向上采样，得到原图像的预测，在与原图像做差，获得残差图像。</p>
<p>范例及代码如下：</p>
<p>原图像</p>
<p><img src="http://7pulhb.com1.z0.glb.clouddn.com/ip - 金字塔_原图像. png" alt="原图像"></p>
<p>近似图像</p>
<p><img src="http://7pulhb.com1.z0.glb.clouddn.com/ip - 金字塔_近似图像. png" alt="近似图像"></p>
<p>预测图像</p>
<p><img src="http://7pulhb.com1.z0.glb.clouddn.com/ip - 金字塔_预测图像. png" alt="预测图像"></p>
<p>预测残差</p>
<p><img src="http://7pulhb.com1.z0.glb.clouddn.com/ip - 金字塔_预测残差. png" alt="预测残差"></p>
<pre><code class="cpp"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2\highgui\highgui.hpp&gt;</span></span>
<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2\imgproc\imgproc.hpp&gt;</span></span>

<span class="keyword">using</span> <span class="keyword">namespace</span> cv;

<span class="comment">//Global Varaibles</span>
Mat imgSrc, imgApproximation,imgPredication,imgResidual;
<span class="keyword">const</span> <span class="keyword">char</span> *winNameSrc = <span class="string">"Src Image"</span>;
<span class="keyword">const</span> <span class="keyword">char</span> *winNameAppr = <span class="string">"Approximation Image"</span>;
<span class="keyword">const</span> <span class="keyword">char</span> *winNamePred = <span class="string">"Predication Image"</span>;
<span class="keyword">const</span> <span class="keyword">char</span> *winNamePredR = <span class="string">"Predication Residual Image"</span>;

<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{
<span class="keyword">const</span> <span class="keyword">char</span> *imgPath = <span class="string">"F:\\ImgPrcSrcs\\DIP3E_CH08_Original_Images\\Fig0819(a).tif"</span>;
imgSrc = imread(imgPath, CV_LOAD_IMAGE_GRAYSCALE);
Size sizeSrc = imgSrc.size();
<span class="comment">// 向下两倍采样, 获得近似图像 imgApproximation</span>
pyrDown(imgSrc,imgApproximation,Size(sizeSrc.width/<span class="number">2</span>,sizeSrc.height/<span class="number">2</span>));
<span class="comment">// 向上两倍采样，获得预测图像 imgPredication</span>
pyrUp(imgApproximation, imgPredication, sizeSrc);
<span class="comment">// 将原图像与预测图像做差运算，获得预测残差图像</span>
imgResidual = imgSrc - imgPredication;
imgResidual.convertTo(imgResidual, CV_32F);
imshow(winNameSrc, imgSrc);
imshow(winNameAppr,imgApproximation);
imshow(winNamePred,imgPredication);
imshow(winNamePredR, imgResidual);
waitKey(<span class="number">0</span>);
}
</code></pre>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/03/08/Image_Processing/数字图像处理（2）-- 图像的代数运算/">数字图像处理（2）-- 图像的代数运算</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Mar 8, 2017
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h2 id="图像加法"><a href="#图像加法" class="headerlink" title="图像加法"></a>图像加法</h2><p><img src="http://7pulhb.com1.z0.glb.clouddn.com/ip - 图像的加法. jpg" alt="图像的加法"></p>
<ol>
<li>去除 “叠加性噪音” </li>
</ol>
<p><img src="http://7pulhb.com1.z0.glb.clouddn.com/ip - 去除叠加性噪音. jpg" alt="去除 “叠加性噪音” "></p>
<ol>
<li>生成图像的叠加效果（控制两幅图对应像素的显示亮度比例）</li>
</ol>
<p><img src="http://7pulhb.com1.z0.glb.clouddn.com/ip - 生成叠加效果. jpg" alt="生成图像的叠加效果"></p>
<h2 id="图像减法"><a href="#图像减法" class="headerlink" title="图像减法"></a>图像减法</h2><p><img src="http://7pulhb.com1.z0.glb.clouddn.com/ip - 图像减法. jpg" alt="图像的减法"></p>
<p><strong>图像的减法主要应用在:</strong></p>
<ol>
<li><p>去除不需要的叠加性图案</p>
</li>
<li><p>检测两幅图像之间的差别</p>
</li>
<li><p>计算物体边界的梯度（差分运算）</p>
</li>
</ol>
<h2 id="图像乘法"><a href="#图像乘法" class="headerlink" title="图像乘法"></a>图像乘法</h2><ol>
<li>图象的局部显示 （用二值模板图像与原图像做乘法）</li>
</ol>
<p><img src="http://7pulhb.com1.z0.glb.clouddn.com/ip - 图像乘法. jpg" alt="显示图像感兴趣区域（ROI）"></p>
<h2 id="几何空间变换"><a href="#几何空间变换" class="headerlink" title="几何空间变换"></a>几何空间变换</h2><p><img src="http://7pulhb.com1.z0.glb.clouddn.com/ip - 几何空间变换. jpg" alt="图像的几何变换"></p>
<p>坐标旋转公式的推导：<a href="http://www.cnblogs.com/ywxgod/archive/2010/08/06/1793609.html" target="_blank" rel="external">参看这里</a></p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/03/08/Image_Processing/数字图像处理（3）-- 图像处理的概率方法/">数字图像处理（3）-- 图像处理的概率方法</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Mar 8, 2017
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>释义：直接将图像的灰度值看成是随机变量</p>
<p><img src="http://7pulhb.com1.z0.glb.clouddn.com/ip - 图像处理的概率方法. jpg" alt="图像处理的概率方法"></p>
<p>数学中，随机变量的方差反映了其与均值（期望）的偏离程度，灰度图像的方差越大，即像素的灰度值变化程度越大，明暗对比更加强烈。</p>
<p><img src="http://7pulhb.com1.z0.glb.clouddn.com/ip - 灰度标准差. jpg" alt="灰度标准差"></p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/03/08/Image_Processing/数字图像处理（4）-- 图像增强：灰度变化/">数字图像处理（4）-- 图像增强：灰度变化</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Mar 8, 2017
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h2 id="图像增强的基本方法："><a href="#图像增强的基本方法：" class="headerlink" title="图像增强的基本方法："></a>图像增强的基本方法：</h2><h3 id="空间域处理（增强构成图像的像素）："><a href="#空间域处理（增强构成图像的像素）：" class="headerlink" title="空间域处理（增强构成图像的像素）："></a>空间域处理（增强构成图像的像素）：</h3><ul>
<li><strong>点处理</strong>（图象灰度变换、直方图均衡等）。</li>
<li><strong>邻域处理</strong>（线性、非线性平滑和锐化等）。</li>
</ul>
<h3 id="频域处理-："><a href="#频域处理-：" class="headerlink" title="频域处理 ："></a>频域处理 ：</h3><p><strong>高、低通滤波</strong>、<strong>同态滤波</strong>等</p>
<h2 id="空间域增强"><a href="#空间域增强" class="headerlink" title="空间域增强"></a>空间域增强</h2><p>公式 $g(x,y)=T[f(x,y)]$</p>
<p>其中：</p>
<p>$f(x,y)$：输入图像</p>
<p>$g(x,y)$：输出图像</p>
<p>$T$ 是对 $f$ 的一种操作，定义在（x,y）的邻域上。</p>
<p>空间域一般的方法是利用点 $(x,y)$ 事先定义的邻域里的一个 f 值的函数来决定 $g$ 在 $(x,y)$ 的值, 主要是利用所谓的模板（也称为滤波器, 核, 掩模）. 模板是一个小的 (3×3) 二维阵列, 模板的系数值决定了处理的性质, 如图像尖锐化等. 以这种方法为基础的增强技术通常是指<strong>模板处理</strong>或<strong>空域滤波</strong>.</p>
<h3 id="灰度变换：-s-T-r-—————-s-为输出灰度值，-r-为输入灰度值"><a href="#灰度变换：-s-T-r-—————-s-为输出灰度值，-r-为输入灰度值" class="headerlink" title="灰度变换：$s=T(r)$—————-$s$ 为输出灰度值，$r$ 为输入灰度值"></a>灰度变换：$s=T(r)$—————-$s$ 为输出灰度值，$r$ 为输入灰度值</h3><ul>
<li><p><strong>线性变换</strong>(正比或反比)</p>
</li>
<li><p><strong>对数变换</strong>(对数和反对数的)</p>
</li>
<li><p><strong>幂次变换</strong>(n 次幂和 n 次方根变换)</p>
</li>
</ul>
<p>注：下图的灰度级是均一化的灰度级</p>
<p><img src="http://7pulhb.com1.z0.glb.clouddn.com/ip - 灰度变换. png" alt="灰度变换"></p>
<p>Ex：（灰度已经均一化）</p>
<ul>
<li><p><strong>图像反转</strong>：s=L-1-r(考虑灰度级为[0,L-1], 显然，原来灰度值为 L-1 的输出后灰度值为 0, 实现了反色)</p>
</li>
<li><p><strong>对数变换</strong>：s=clog(1+r)（由上图知道，对数变换曲线处于正比函数上方，图像变亮，c 值用来控制灰度不超值？）</p>
</li>
<li><p><strong>幂次变换</strong>：s=crγ（伽马校正，当γ&lt;0 时，变换函数曲线在正比函数上方（因为均一化造成），输出灰度级变小。即此时扩展低灰度级，压缩高灰度级，使图像变亮，如下图所示。反之使图像变暗。）</p>
</li>
</ul>
<p><img src="http://7pulhb.com1.z0.glb.clouddn.com/ip - 幂次变换. png" alt="幂次变换"></p>
<p>幂次变换代码片：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2\highgui\highgui.hpp&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2\imgproc\imgproc.hpp&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="comment">//Global variables</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> *winNameSrc = <span class="string">"Src Image!"</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> *winNameDst = <span class="string">"Dst Image!"</span>;</div><div class="line">Mat imgSrc, imgDst;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *imgPath = <span class="string">"F:\\ImgPrcSrcs\\DIP3E_Original_Images_CH03\\Fig0309(a)(washed_out_aerial_image).tif"</span>;</div><div class="line">  imgSrc = imread(imgPath,CV_LOAD_IMAGE_GRAYSCALE);</div><div class="line">  namedWindow(winNameSrc,CV_WINDOW_AUTOSIZE);</div><div class="line">  imshow(winNameSrc,imgSrc);</div><div class="line">  imgSrc.convertTo(imgSrc, CV_32FC1);</div><div class="line">  <span class="comment">// 重要！幂次变换考虑将灰度级归一化</span></div><div class="line">  normalize(imgSrc, imgDst, <span class="number">1.0</span>, <span class="number">0.0</span>, NORM_MINMAX);</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; imgDst.rows; i++)&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; imgDst.cols; j++)&#123;</div><div class="line">      imgDst.at&lt;<span class="keyword">float</span>&gt;(i, j) = <span class="built_in">pow</span>(imgDst.at&lt;<span class="keyword">float</span>&gt;(i, j),<span class="number">5.0</span>);</div><div class="line">    &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 重构灰度级，方便图像显示</span></div><div class="line">   normalize(imgDst, imgDst, <span class="number">255.0</span>, <span class="number">0.0</span>, NORM_MINMAX);</div><div class="line">   namedWindow(winNameDst, CV_WINDOW_AUTOSIZE);</div><div class="line">   imgDst.convertTo(imgDst, CV_8UC1);</div><div class="line">   imshow(winNameDst,imgDst);</div><div class="line">   waitKey(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="分段线性变换"><a href="#分段线性变换" class="headerlink" title="分段线性变换"></a>分段线性变换</h3><p>顾名思义，在不同灰度区间采用线性变换，以<strong>对比拉伸</strong>为例：</p>
<p><img src="http://7pulhb.com1.z0.glb.clouddn.com/ip - 对比拉伸. jpg" alt="对比拉伸"></p>
<p>ab</p>
<p>cd</p>
<p>(a)变换函数的形式 (b)低对比度图像 (c)对比度拉伸的结果 (d)门限化的结果</p>
<p>由 a 图可以看出，亮处变亮，暗处变暗, 中部灰度剧烈变化，即提高了明暗对比。代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2\highgui\highgui.hpp&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2\imgproc\imgproc.hpp&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</div><div class="line"> </div><div class="line"><span class="comment">//Global Variables</span></div><div class="line">Mat imgSrc, imgGray, imgDst;</div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> *winNameSrc = <span class="string">"Src Image!"</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> *winNameDst = <span class="string">"Dst Image!"</span>;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *imgPath = <span class="string">"F:\\ImgPrcSrcs\\DIP3E_Original_Images_CH03\\Fig0310(b)(washed_out_pollen_image).tif"</span>;</div><div class="line">  imgSrc = imread(imgPath);</div><div class="line">  cvtColor(imgSrc,imgGray,CV_RGB2GRAY);</div><div class="line">  <span class="comment">// 灰度格式转换 </span></div><div class="line">  imgGray.convertTo(imgGray,CV_32FC1);</div><div class="line">  <span class="comment">// 归一化图像</span></div><div class="line">  normalize(imgGray,imgDst,<span class="number">1.0</span>,<span class="number">0.0</span>,NORM_MINMAX);</div><div class="line">  <span class="comment">// 进行对比拉伸</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; imgDst.rows; i++)&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; imgDst.cols; j++)&#123;</div><div class="line">      <span class="keyword">if</span> (imgDst.at&lt;<span class="keyword">float</span>&gt;(i, j) &lt;= (<span class="keyword">float</span>)<span class="number">1</span>/ <span class="number">3</span>)</div><div class="line">        imgDst.at&lt;<span class="keyword">float</span>&gt;(i, j) = <span class="number">0.5</span>*imgDst.at&lt;<span class="keyword">float</span>&gt;(i, j);</div><div class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (imgDst.at&lt;<span class="keyword">float</span>&gt;(i, j) &gt;= (<span class="keyword">float</span>)<span class="number">2</span> / <span class="number">3</span>)</div><div class="line">        imgDst.at&lt;<span class="keyword">float</span>&gt;(i, j) = <span class="number">0.5</span>*imgDst.at&lt;<span class="keyword">float</span>&gt;(i, j) + <span class="number">0.5</span>;</div><div class="line">      <span class="keyword">else</span></div><div class="line">        imgDst.at&lt;<span class="keyword">float</span>&gt;(i, j) = <span class="number">2</span> * imgDst.at&lt;<span class="keyword">float</span>&gt;(i, j) - <span class="number">0.5</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 重构灰度级，方便显示</span></div><div class="line">  normalize(imgDst,imgDst,<span class="number">255.0</span>,<span class="number">0</span>,NORM_MINMAX);</div><div class="line">  imgDst.convertTo(imgDst, CV_8UC1);</div><div class="line">  namedWindow(winNameSrc,CV_WINDOW_AUTOSIZE);</div><div class="line">  imshow(winNameSrc,imgSrc);</div><div class="line">  namedWindow(winNameDst,CV_WINDOW_AUTOSIZE);</div><div class="line">  imshow(winNameDst,imgDst);</div><div class="line">  waitKey(<span class="number">0</span>);</div><div class="line">&#125;</div><div class="line">``` </div><div class="line"></div><div class="line">### 灰度切割（高亮感兴趣灰度级）</div><div class="line"></div><div class="line"></div><div class="line">![灰度切割](http:<span class="comment">//7pulhb.com1.z0.glb.clouddn.com/ip - 灰度切割. jpg)</span></div><div class="line"></div><div class="line">a 图中显示灰度值处于 AB 间的灰度保持恒定高亮，其余灰度保持为恒定值（变暗），这样就突出目标，消除背景。</div><div class="line"></div><div class="line">b 图中 A~B 变暗，其余灰度不变，显然就有利于突出目标，保留背景细节。</div><div class="line"></div><div class="line"> 下面图像左侧为原图，右侧为试用 b 变换突出了目标区域，并保留了其余细节。</div><div class="line"></div><div class="line">![高亮 ROI](http:<span class="comment">//7pulhb.com1.z0.glb.clouddn.com/ip - 高亮 ROI.jpg)</span></div><div class="line"></div><div class="line">代码如下：</div><div class="line"></div><div class="line">```cpp</div><div class="line">#include &lt;opencv2\highgui\highgui.hpp&gt;</div><div class="line">#include &lt;opencv2\imgproc\imgproc.hpp&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line"> </div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</div><div class="line"> </div><div class="line"><span class="comment">//Global Variables</span></div><div class="line">Mat imgSrc, imgGray, imgDst;</div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> *winNameSrc = <span class="string">"Src Image!"</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> *winNameDst = <span class="string">"Dst Image!"</span>;</div><div class="line"><span class="keyword">int</span> beginLevel = <span class="number">150</span>, endLevel = <span class="number">200</span>;<span class="comment">// 感兴趣的灰度区间 </span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxLevel = <span class="number">255</span>;</div><div class="line"> </div><div class="line"><span class="comment">//Funcation Daclarations</span></div><div class="line"><span class="keyword">void</span> IntensitySlicing(<span class="keyword">int</span> ,<span class="keyword">void</span> *);</div><div class="line"> </div><div class="line"><span class="keyword">int</span> main()&#123;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *imgPath = <span class="string">"F:\\ImgPrcSrcs\\DIP3E_Original_Images_CH03\\Fig0312(a)(kidney).tif"</span>;</div><div class="line">  imgSrc = imread(imgPath);</div><div class="line">  cvtColor(imgSrc, imgGray, CV_RGB2GRAY);</div><div class="line">  namedWindow(winNameSrc, CV_WINDOW_AUTOSIZE);</div><div class="line">  imshow(winNameSrc, imgSrc);</div><div class="line">  createTrackbar(<span class="string">"begin level:"</span>, winNameSrc, &amp;amp;beginLevel, maxLevel,IntensitySlicing);</div><div class="line">  createTrackbar(<span class="string">"end level:"</span>, winNameSrc, &amp;amp;endLevel, maxLevel, IntensitySlicing);</div><div class="line">  waitKey(<span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">void</span> IntensitySlicing(<span class="keyword">int</span>, <span class="keyword">void</span> *)&#123;</div><div class="line">  imgDst = imgGray.clone();</div><div class="line">  imgDst.convertTo(imgDst, CV_32SC1);</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"["</span>&lt;&lt;beginLevel &lt;&lt;<span class="string">","</span>&lt;&lt;endLevel&lt;&lt;<span class="string">"]"</span>&lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="keyword">if</span> (endLevel &gt; beginLevel)&#123;</div><div class="line">    <span class="comment">// 进行高亮感兴趣区域</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; imgDst.rows; i++)&#123;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; imgDst.cols; j++)&#123;</div><div class="line">        <span class="comment">// 落在灰度区间的变亮</span></div><div class="line">        <span class="keyword">if</span> (imgDst.at&lt;<span class="keyword">int</span>&gt;(i, j) &gt;= beginLevel &amp;amp;&amp;amp; imgDst.at&lt;<span class="keyword">int</span>&gt;(i, j) &lt;= endLevel)&#123;</div><div class="line">          imgDst.at&lt;<span class="keyword">int</span>&gt;(i, j) = <span class="number">250</span>;</div><div class="line">         &#125;</div><div class="line">   <span class="comment">// 反之不变</span></div><div class="line">      &#125;	</div><div class="line"> 		&#125;</div><div class="line"> 	&#125;</div><div class="line">   imgDst.convertTo(imgDst,CV_8UC1);</div><div class="line">   namedWindow(winNameDst, CV_WINDOW_AUTOSIZE);</div><div class="line">   imshow(winNameDst, imgDst);</div><div class="line">&#125;</div><div class="line">``` </div><div class="line"></div><div class="line">### 位图切割：</div><div class="line"></div><div class="line"> 假设灰度值用 < span class="number">8bit 表示，则每一位即代表一个位平面，图像将被分为 < span class="number">8 个位平面（bit plane），每个平面的像素的灰度即为该位平面的十进制值。</div><div class="line"></div><div class="line">如__00100010__灰度会被分为 < span class="number">8 个位平面 </div><div class="line"></div><div class="line">（<span class="number">00000000</span>,<span class="number">00000000</span>,<span class="number">00100000</span>,<span class="number">00000000</span>,<span class="number">00000000</span>,<span class="number">00000000</span>,<span class="number">0000010</span>,<span class="number">00000000</span>）。</div><div class="line"></div><div class="line"> 显然每个位平面（bit plane）是可以考虑构成一副二值图像，如第 < span class="number">8 位只可能构成 < span class="number">10000000（<span class="number">128</span>）或者 < span class="number">00000000（<span class="number">0</span>），即原像素灰度最高位等于 < span class="number">1（即灰度属于 [<span class="number">128</span>,<span class="number">255</span>]）者的第 < span class="number">8 位平面灰度为 < span class="number">128（二值化后令为 < span class="number">1），最高位等于 < span class="number">0(即灰度属于[<span class="number">0</span>,<span class="number">127</span>]) 者的第 < span class="number">8 位平面灰度为 < span class="number">0（二值化后令为零）;</div><div class="line"></div><div class="line">再考虑第 < span class="number">1 位只可能构成 < span class="number">00000001（<span class="number">1</span>）或者 < span class="number">00000000（<span class="number">0</span>），即原像素灰度最低位等于 < span class="number">1（即灰度属于 [<span class="number">1</span>,<span class="number">255</span>]）者的第 < span class="number">1 位平面灰度为 < span class="number">1（二值化后为 < span class="number">1），而等于 < span class="number">0（即灰度属于 < span class="number">0）者的第一位平面灰度为 < span class="number">0（二值化后为 < span class="number">0）。</div><div class="line"></div><div class="line"> 注意到下图（第一幅为原图，而其余图像为第 < span class="number">1 到第 < span class="number">8 位平面的二值化图像），一个图像的高阶位如前 < span class="number">4 位包含视觉上很重要的大多数数据；其它位对图像中的更多微小细节（暗部细节）有作用。（Why？因为某像素灰度高位数字构成的位平面更接近于原始强度，如某像素的灰度为 < span class="number">11000010（<span class="number">194</span>），其最高位构成的位平面为 < span class="number">1000000（<span class="number">128</span>，二值化后为 < span class="number">1，即白色，与原灰度接近）相对于第二位 < span class="number">00000010（<span class="number">2</span>，二值化后为 < span class="number">0，即黑色，与原灰度差异过大）更加接近 < span class="number">194）</div><div class="line"></div><div class="line">![位图切割](http:<span class="comment">//7pulhb.com1.z0.glb.clouddn.com/ip - 位图切割. png)</span></div><div class="line"></div><div class="line"> 示例代码如下：</div><div class="line"></div><div class="line">```cpp</div><div class="line">#include &lt;opencv2\highgui\highgui.hpp&gt;</div><div class="line">#include &lt;opencv2\imgproc\imgproc.hpp&gt;</div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</div><div class="line"><span class="comment">//Global Variables</span></div><div class="line">Mat imgSrc, imgGray, imgDst;</div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> *winNameSrc = <span class="string">"Src Image!"</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> *winNameDst = <span class="string">"Dst Image!"</span>;</div><div class="line"><span class="keyword">int</span> n=<span class="number">4</span>;<span class="comment">// 第 n 位位平面</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxLevel = <span class="number">8</span>;</div><div class="line"><span class="comment">//Funcation Daclarations</span></div><div class="line"><span class="keyword">void</span> getNthBitPlane(<span class="keyword">int</span> ,<span class="keyword">void</span> *);</div><div class="line"><span class="keyword">int</span> main()&#123;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *imgPath = <span class="string">"F:\\ImgPrcSrcs\\DIP3E_Original_Images_CH03\\Fig0314(a)(100-dollars).tif"</span>;</div><div class="line">  imgSrc = imread(imgPath);</div><div class="line">  cvtColor(imgSrc, imgGray, CV_RGB2GRAY);</div><div class="line">  namedWindow(winNameSrc, CV_WINDOW_AUTOSIZE);</div><div class="line">  imshow(winNameSrc, imgSrc);</div><div class="line">  createTrackbar(<span class="string">"nth bit plane:\n"</span>, winNameSrc, &amp;amp;n, maxLevel, getNthBitPlane);</div><div class="line">  getNthBitPlane(<span class="number">0</span>, <span class="number">0</span>);</div><div class="line">  waitKey(<span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">void</span> getNthBitPlane(<span class="keyword">int</span>, <span class="keyword">void</span> *)&#123;</div><div class="line">  imgDst = imgGray.clone();</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; imgDst.rows; i++)&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; imgDst.cols; j++)&#123;</div><div class="line">      <span class="comment">// 通过移位操作获取第 n 位</span></div><div class="line">      <span class="keyword">int</span> bit = (<span class="keyword">int</span>)(imgDst.at&lt;uchar&gt;(i, j) &gt;&gt; (n - <span class="number">1</span>));</div><div class="line">      <span class="keyword">if</span> (bit == <span class="number">1</span>)</div><div class="line">      imgDst.at&lt;uchar&gt;(i, j) = <span class="number">255</span>;<span class="comment">// 二值化</span></div><div class="line">      <span class="keyword">else</span></div><div class="line">      imgDst.at&lt;uchar&gt;(i, j) = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  namedWindow(winNameDst, CV_WINDOW_AUTOSIZE);</div><div class="line">  imshow(winNameDst, imgDst);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
        
      
    </div>

    

    

  </article>

    
  </section>

  
  <nav class="pagination">
    
      <a class="prev" href="/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text">Prev</span>
      </a>
    
    
      <a class="next" href="/page/3/">
        <span class="next-text">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>


          </div>
          

        </div>  
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:softshot37@gmail.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
        
          <a href="https://github.com/yoyoyohamapi" class="iconfont icon-github" title="github"></a>
        
      
    
      
    
      
        
          <a href="https://www.zhihu.com/people/wu-xiao-jun-64-55/activities" class="iconfont icon-zhihu" title="zhihu"></a>
        
      
    
      
    
    
    
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>


<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://hexo.io/">Hexo</a>
  </span>
  
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2015 - 
    
    2017

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">吴晓军</span>
  </span>
</div>
      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  


    <script type="text/javascript" src="/js/src/even.js?v=2.4.x"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.4.x"></script>

    
  <!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</body>
</html>
