<!DOCTYPE html>
<html lang="">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="只要努力，蛆虫也能变成苍蝇翱翔于天际"/>







  <link rel="alternate" href="/atom.xml" title="吴小蛆的巣">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.4.x" />



<link rel="canonical" href="http://yoyoyohamapi.me/page/3/"/>


<meta name="description" content="只要努力，蛆虫也能变成苍蝇翱翔于天际">
<meta property="og:type" content="website">
<meta property="og:title" content="吴小蛆的巣">
<meta property="og:url" content="http://yoyoyohamapi.me/page/3/index.html">
<meta property="og:site_name" content="吴小蛆的巣">
<meta property="og:description" content="只要努力，蛆虫也能变成苍蝇翱翔于天际">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="吴小蛆的巣">
<meta name="twitter:description" content="只要努力，蛆虫也能变成苍蝇翱翔于天际">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.4.x" />







<script>
  var CONFIG = {
    search: false,
    searchPath: "/search.xml",
    fancybox: false,
    toc: true,
  }
</script>




  



    <title> 吴小蛆的巣 </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">吴小蛆的巣</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            Home
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            Archives
          
        </li>
      </a>
    
      <a href="/tags">
        <li class="mobile-menu-item">
          
          
            Tags
          
        </li>
      </a>
    
      <a href="/categories">
        <li class="mobile-menu-item">
          
          
            Categories
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">吴小蛆的巣</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              Home
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              Archives
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            
            
              Tags
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/categories">
            
            
              Categories
            
          </a>
        </li>
      
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  <section id="posts" class="posts">
    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/03/08/Image_Processing/数字图像处理（6）-- 图像增强：空间滤波/">数字图像处理（6）-- 图像增强：空间滤波</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Mar 8, 2017
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h2 id="空间域对图像的处理和频率域对图像的处理有什么异同？"><a href="#空间域对图像的处理和频率域对图像的处理有什么异同？" class="headerlink" title="空间域对图像的处理和频率域对图像的处理有什么异同？"></a>空间域对图像的处理和频率域对图像的处理有什么异同？</h2><p>核心是一样的，都是对图像的处理，只是空间域对图像的处理是从灰度值的<strong>大小（静态性）</strong>着手，而频率域对图像的处理则是从灰度的<strong>变化情况（动态性）</strong>着手。就好比买一本书，你既可以从实体店买，也可以从网上商城买，手段不一样，但最终目的都是获取到你需要的那本书。</p>
<h2 id="如何理解图像的频谱图？"><a href="#如何理解图像的频谱图？" class="headerlink" title="如何理解图像的频谱图？"></a>如何理解图像的频谱图？</h2><p>图像进行二维傅立叶变换得到频谱图（即将图像从空间域投射到频率域后频率的幅度图，为什么要用幅度来表示傅里叶变幻？因为图像经傅立叶变换后，往往得到的是复数形式。要直接表示结果就必须用到两幅图像：一幅表示实部，一幅表示虚部。这样表示十分不方便，同时也没有得到有用的信息，因此引入变换结果的模作为值在频谱图中表示出来），就是图像梯度的分布图,<strong>当然频谱图上的各点与图像上各点并不存在一一对应的关系（如频谱图上的中心位置并非原图的中心位置），即使在不移频的情况下也是没有。傅立叶频谱图上我们看到的明暗不一的亮点，实际上反映的时原图像（二维序列）某一频率（垂直及水平方向的灰度变化剧烈程度，即梯度变化情况）的多少，即该频率的幅度，幅度越高，亮度越高</strong>，也就意味着某种变化情况存在的更多。将频谱图像中心化后，越接近于频谱中心（0 频率点，即灰度在 水平及垂直方向都无明显变化）的位置亮度越高，即原图像的大多数像素的都不发生明显的灰度变化，因为绝大部分图像灰度都是呈现区域型分布的，某一区域的灰度都是近似的。</p>
<h2 id="更多关于频谱图的理解："><a href="#更多关于频谱图的理解：" class="headerlink" title="更多关于频谱图的理解："></a>更多关于频谱图的理解：</h2><p>将频谱移频到圆心除了可以清晰地看出图像频率分布以外，还有一个好处，它可以分离出有周期性规律的干扰信号，比如正弦干扰，一副带有正弦干扰，移频到原点的频谱图上可以看出除了中心以外还存在以某一点为中心，对称分布的亮点集合，这个集合就是干扰噪音产生的，这时可以很直观的通过在该位置放置带阻滤波器消除干扰。</p>
<p>1、考虑到傅立叶变换具有对称性，为了便于显示，频率图像往往以图像的中心为坐标原点，左上 - 右下、右上 - 左下对称。</p>
<p>2、图像中心为原始图像的平均亮度，频率为 0. 从图像中心向外，频率增高。高亮度表明频率特征明显。</p>
<p>3、此外，频率域图像中心明显的频率变化方向与原图像中地物方向垂直。也就是说如果原始图像中有多种水平分布的地物，那么频率域图像中在垂直方向的频率变化比较明显。如果原始图像中地物左下 - 右上分布，那么频率域图像中在左上 - 右下方向频率变化比较明显，反之亦然。</p>
<h2 id="如何理解这种垂直性？"><a href="#如何理解这种垂直性？" class="headerlink" title="如何理解这种垂直性？"></a>如何理解这种垂直性？</h2><p>如下图所示，原图像有一个竖直矩形，而起傅里叶变换的频谱图中产生了与之水平亮带，这是为什么？考虑到二维离散傅里叶变换可以分解为先进行一维的行傅里叶变换再进行一维的列傅里叶变换（即从同时考虑灰度在水平，垂直方向的变化转而对灰度在这两个方向的变化情况进行分开考虑）。显然原图像的灰度变化仅发生在水平方向（由黑色进入白色，白色进入黑色），即对于灰度的变化程度的反映（即频率）只会出现在水平方向，亦即水平方向有更多的频率，亦即水平方向幅度值更高，故而水平方向更亮。</p>
<p><img src="http://7pulhb.com1.z0.glb.clouddn.com/ip - 傅里叶频谱图垂直性. png" alt="垂直性"></p>
<h2 id="频率域滤波的步骤？"><a href="#频率域滤波的步骤？" class="headerlink" title="频率域滤波的步骤？"></a>频率域滤波的步骤？</h2><p>频率域滤波的实质是用一个滤波函数 H(u,v)乘以原图像的傅里叶变换 F(u,v)。</p>
<p><img src="http://7pulhb.com1.z0.glb.clouddn.com/ip - 频率域滤波步骤. jpg" alt="频率域滤波步骤"></p>
<p>Ex：下图展示了图像进行高通和低通滤波后，其频谱图的变化。</p>
<p><img src="http://7pulhb.com1.z0.glb.clouddn.com/ip - 高通低通滤波. jpg" alt="高通低通滤波"></p>
<p>如图，一副图像中大体上是低频成分占多数（很容易理解，因为图像中的部分图案还是块状的，块状上的像素其强度还是近似的，即与其周围像素区别不大）。首先，我们对其进行低通滤波，截断图像的高频成分，亦即我们截断了灰度剧烈变化的情况，也就丢失了图像的突变细节，实现了对图像的模糊，从中也可以看出在频率域滤波的直观，我们仅只是做了一个 “圈地运动”（这种圈，在之后可能是很武断很无情的圈，也可能是欲拒还休（理想），半遮半掩的圈（高通，巴特沃斯低阶）），“圈” 下了低频部分，即完成了图像的模糊操作。</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/03/08/Image_Processing/数字图像处理（5）-- 图像增强：空间滤波/">数字图像处理（5）-- 图像增强：空间滤波</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Mar 8, 2017
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h2 id="空间滤波的实质："><a href="#空间滤波的实质：" class="headerlink" title="空间滤波的实质："></a>空间滤波的实质：</h2><p>用某个<strong>mask（或者称 kernel）</strong>去覆盖某个像素，并参考该像素及其邻域像素的强度，去计算一个乘积和:</p>
<p> $w*f$</p>
<p>其中: 系数 $w$ 来自于 mask，而 $f$ 指示像素强度。相关和卷积的操作过程皆是如此。</p>
<h2 id="空间平滑滤波："><a href="#空间平滑滤波：" class="headerlink" title="空间平滑滤波："></a>空间平滑滤波：</h2><p>用途：用于模糊处理和减少噪声。</p>
<p>典型的随机噪声由灰度级的急剧变化组成；</p>
<p>平滑处理降低了图像的 “尖锐” 变化；</p>
<p><strong>“负面效应”</strong>：图像边缘模糊化；（图像边缘也由灰度级的急剧变化组成）。</p>
<h3 id="线性平滑滤波器"><a href="#线性平滑滤波器" class="headerlink" title="线性平滑滤波器"></a>线性平滑滤波器</h3><h4 id="均值滤波："><a href="#均值滤波：" class="headerlink" title="均值滤波："></a>均值滤波：</h4><p>算法思路很简单，即求取 mask 覆盖像素的平均值，用该平均值替代中心像素值。</p>
<p><strong>opencv2</strong>中，通过</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">blur( src, dst, Size( i, i ), Point(<span class="number">-1</span>,<span class="number">-1</span>)）</div></pre></td></tr></table></figure>
<p>方法实现均值滤波，其中：</p>
<ul>
<li><p>src: 输入图像</p>
</li>
<li><p>dst: 输出图像</p>
</li>
<li><p>Size( w,h ): 定义内核大小( w 像素宽度， h 像素高度)</p>
</li>
<li><p>Point(-1, -1): 指定锚点位置(被平滑点)， 如果是负值，取核的中心为锚点。</p>
</li>
</ul>
<h4 id="加权均值滤波："><a href="#加权均值滤波：" class="headerlink" title="加权均值滤波："></a>加权均值滤波：</h4><p>需考虑各个像素的权重，该权重由像素位置决定，显然，越靠近中心像素其权重越高。</p>
<h3 id="统计排序（Order-Statistic）滤波器（非线性）"><a href="#统计排序（Order-Statistic）滤波器（非线性）" class="headerlink" title="统计排序（Order-Statistic）滤波器（非线性）"></a>统计排序（Order-Statistic）滤波器（非线性）</h3><h4 id="中值滤波（median-filter）："><a href="#中值滤波（median-filter）：" class="headerlink" title="中值滤波（median filter）："></a>中值滤波（median filter）：</h4><p>对窗口内像素强度排序，选取中值作为中心像素强度。使拥有不同灰度的点看起来更接近于它的邻近值。主要用途：去除 “椒盐” 噪声（黑白相间的噪点）。其特点是在去除噪音的同时，可以比较好地保留边的锐度和图像细节。</p>
<p>考虑像素集    <strong>（10,20,20,20,180,20,20,25,100）</strong>, 中心像素强度为 180，排序后为<strong>（10,20,20,20,20,20,25,100,180）</strong>，那么中心像素强度将被更新为 20，显然，原来发亮的中心像素（可能就会是一个白色噪点）经中值滤波后，其强度更接近周围像素，假若其真为噪点，显然该噪点就被成功消除</p>
<p>二维中值滤波的窗口形状和尺寸对滤波效果影响较大，不同的图象内容和不同的应用要求，往往采用不同的窗口形状和尺寸。常用的二维中值滤波窗口有线状、十字形、方形等。窗口尺寸一般先用 3×3，再取 5×5 逐渐增大，直到滤波效果满意为止。就一般经验来讲，对于有缓变的较长轮廓线物体的图象，采用方形窗口为宜。对于包含有尖顶物体的图象，用十字形窗口；而窗口大小则以不超过图象中最小有效物体的尺寸为宜。如果图象中点、线、尖角细节较多，则不宜采用中值滤波。</p>
<p><img src="http://7pulhb.com1.z0.glb.clouddn.com/ip - 中值滤波器. jpg" alt="中值滤波器"></p>
<p>在 opencv2，通过 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">medianBlur(src, dst, i)</div></pre></td></tr></table></figure>
<p>方法来实现中值滤波，其中：</p>
<ul>
<li><p>src: 输入图像</p>
</li>
<li><p>dst: 输出图像, 必须与 src 相同类型<br>i: 内核大小 (只需一个值，因为我们使用正方形窗口)，必须为奇数。</p>
</li>
</ul>
<h2 id="空间锐化滤波器："><a href="#空间锐化滤波器：" class="headerlink" title="空间锐化滤波器："></a>空间锐化滤波器：</h2><h3 id="空间微分引入："><a href="#空间微分引入：" class="headerlink" title="空间微分引入："></a>空间微分引入：</h3><p>锐化处理可以用空间微分来完成. 微分算子的响应强度与图像在该点的突变程度有关，图像微分增强了边缘和其他突变 (如噪声) 而消弱了灰度变化缓慢的区域.</p>
<p>我们最感兴趣的是微分算子在<strong>①恒定灰度区域(平坦段)</strong>、<strong>②突变的开头与结尾(阶梯与斜坡突变)</strong>以及<strong>③沿着灰度级斜坡处的特性</strong>。</p>
<p><img src="http://7pulhb.com1.z0.glb.clouddn.com/ip - 空间微分. jpg" alt="一阶微分与二阶微分"></p>
<p>如上图所示：</p>
<ul>
<li><p>在<strong>平坦段</strong>，即灰度恒定段（constant intensity），一阶，二阶微分均为零，亦即对图像求取一阶微分或二阶微分后，灰度恒定段的灰度将被置为 0，全黑。</p>
</li>
<li><p>在<strong>斜坡段（ramp）</strong>，一阶微分非零（即对图像求取一阶微分后，该区域灰度非零，通常斜坡段多是像素边缘（灰度区分明显）部分，故而对图像求取一阶微分有利于边缘提取(即可二值化非零值为白色，零值为黑色，则边缘呈白色)），值得注意的是，在斜坡起点和终点处的二阶微分异号。</p>
</li>
<li><p>在<strong>灰度跃迁段（step）</strong>起点和终点间，二阶微分穿过零点（Zero Crossing），且值跃迁到高灰度，因而现象对于定为边缘（边缘灰度跃迁大，图像求取二阶微分后边缘呈浅灰色）很有作用。</p>
</li>
</ul>
<p>总结：</p>
<p>一阶微分和二阶微分的区别:</p>
<ul>
<li><p>一阶微分处理通常会产生较宽的边缘（斜坡段一阶微分灰度始终非零）</p>
</li>
<li><p>二阶微分处理对细节有较强的响应, 如细线和孤立点（会有灰度跃迁，在求取二阶微分后的图像上呈浅灰色）</p>
</li>
<li><p>一阶微分处理一般对灰度阶梯（一阶非零）有较强的响应</p>
</li>
<li><p>二阶微分处理对灰度级阶梯变化产生双响应（斜坡起点终点异号，斜坡上为零，即以零间隔起点，终点）</p>
</li>
<li><p>二阶微分在图像中灰度值变化相似时, 对线的响应要比对阶梯强, 且点比线强. 大多数应用中, 对图像增强来说. 二阶微分处理比一阶微分好, 因为形成细节的能力强. 而一阶微分处理主要用于提取边缘.</p>
</li>
</ul>
<h3 id="基于二阶微分的图像增强-——-拉普拉斯算子"><a href="#基于二阶微分的图像增强-——-拉普拉斯算子" class="headerlink" title="基于二阶微分的图像增强 —— 拉普拉斯算子"></a>基于二阶微分的图像增强 —— 拉普拉斯算子</h3><p>公式：$\Delta=f(x+1,y)+f(x-1,y)+f(x,y+1)+f(x,y-1)-4f(x,y)$</p>
<p>由此得出拉普拉斯掩膜为（微分掩模的所有系数之和为 0 保证了灰度恒定区域的响应为 0）：</p>
<p><img src="http://7pulhb.com1.z0.glb.clouddn.com/ip - 拉普拉斯算子. jpg" alt="拉普拉斯算子"></p>
<p>再思考，图像求取二阶微分后应当是什么样子的？因为二阶微分包含正值和负值，正值在灰度突变处呈浅灰色，负值全部视作 0 灰度，呈全黑。故原图在求取二阶微分后，边缘或者灰度突变的点将在新图像中呈浅灰色，其余部分呈黑色。</p>
<p>若是边缘提取，那么拉普拉斯算子法结束即可，若是要锐化原图像，则还应当对拉普拉斯产生的图像与原图像做叠加处理。</p>
<p><img src="http://7pulhb.com1.z0.glb.clouddn.com/ip - 拉普拉斯 Demo.jpg" alt="拉普拉斯 Demo"></p>
<p>代码实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2\highgui\highgui.hpp&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2\imgproc\imgproc.hpp&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="comment">//Global variable</span></div><div class="line">Mat imgSrc, imgGray, imgLaped, imgLapedScaled, imgFinal;</div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> *winNameSrc = <span class="string">"Src Image"</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> *winNameLaped = <span class="string">"Laped Image"</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> *winNameLapedScaled = <span class="string">"LapedScaled Image"</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> *winNameFinal = <span class="string">"Final Image"</span>;</div><div class="line"><span class="comment">//Function Daclarations</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">scaled</span><span class="params">(<span class="keyword">int</span> newMin, Mat src)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *imgPath = <span class="string">"F:\\ImgPrcSrcs\\DIP3E_Original_Images_CH03\\Fig0338(a)(blurry_moon).tif"</span>;</div><div class="line">  imgSrc = imread(imgPath);</div><div class="line">  cvtColor(imgSrc,imgGray,CV_RGB2GRAY);</div><div class="line">  namedWindow(winNameSrc, CV_WINDOW_AUTOSIZE);</div><div class="line">  imshow(winNameSrc,imgGray);</div><div class="line">  <span class="comment">// 先降噪</span></div><div class="line">  medianBlur(imgGray, imgGray, <span class="number">3</span>);</div><div class="line">  <span class="comment">// 调用拉普拉斯方法</span></div><div class="line">  <span class="keyword">int</span> kernel_size = <span class="number">3</span>;<span class="comment">// 设置拉普拉斯掩膜大小为 3</span></div><div class="line">  Laplacian(imgGray,imgLaped,CV_16S,kernel_size);</div><div class="line">  <span class="comment">/*</span></div><div class="line">  src_gray: 输入图像。</div><div class="line">  dst : 输出图像</div><div class="line">  ddepth : 输出图像的深度。 因为输入图像的深度是 CV_8U ，这里我们必须定义 ddepth = CV_16S 以避免外溢。</div><div class="line">  kernel_size : 内部调用的 Sobel 算子的内核大小，此例中设置为 3。</div><div class="line">  scale, delta 和 BORDER_DEFAULT : 使用默认值。</div><div class="line">  namedWindow(winNameLaped,CV_WINDOW_AUTOSIZE);</div><div class="line">  */</div><div class="line">  <span class="comment">// 还原为 8 位色深</span></div><div class="line">  convertScaleAbs(imgLaped, imgLaped);</div><div class="line">  <span class="comment">//Scaling</span></div><div class="line">  <span class="keyword">double</span> newMin= <span class="number">100</span>;</div><div class="line">  imgLapedScaled = imgLaped.clone();</div><div class="line">  scaled(newMin, imgLapedScaled);</div><div class="line">  namedWindow(winNameLaped,CV_WINDOW_AUTOSIZE);</div><div class="line">  namedWindow(winNameLapedScaled, CV_WINDOW_AUTOSIZE);</div><div class="line">  imshow(winNameLaped, imgLaped);</div><div class="line">  imshow(winNameLapedScaled, imgLapedScaled);</div><div class="line">  <span class="comment">// 锐化</span></div><div class="line">  add(imgGray,imgLaped,imgFinal);</div><div class="line">  namedWindow(winNameFinal, CV_WINDOW_AUTOSIZE);</div><div class="line">  imshow(winNameFinal,imgFinal);</div><div class="line">  waitKey(<span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">//Scaling the Laplacianed Image</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">scaled</span><span class="params">(<span class="keyword">int</span> newMin,Mat src)</span></span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; imgLaped.rows; i++)</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; imgLaped.cols; j++)&#123;</div><div class="line">      src.at&lt;uchar&gt;(i, j) = src.at&lt;uchar&gt;(i, j) + newMin;</div><div class="line">    &#125;</div><div class="line">  normalize(src, src, <span class="number">255</span>, <span class="number">0</span>, NORM_MINMAX);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="反锐化掩膜（Usharp-Masking）与高频提升滤波-Highboost-Filtering-处理"><a href="#反锐化掩膜（Usharp-Masking）与高频提升滤波-Highboost-Filtering-处理" class="headerlink" title="反锐化掩膜（Usharp Masking）与高频提升滤波 (Highboost Filtering) 处理"></a>反锐化掩膜（Usharp Masking）与高频提升滤波 (Highboost Filtering) 处理</h3><p>过程：</p>
<ul>
<li><p>求得模糊处理后的图像：$f_1$</p>
</li>
<li><p>原图像减去模糊处理后的图像，得到清晰边缘（反锐化掩膜）：$mask=f-f_1$</p>
</li>
</ul>
<ul>
<li>原图像加上一定量的反锐化掩膜，进行锐化：$g = f+k*mask$（若 $k=1$，则称之为高频提升滤波）。</li>
</ul>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2\highgui\highgui.hpp&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2\imgproc\imgproc.hpp&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="comment">//Global Variables</span></div><div class="line">Mat imgSrc, imgSmoothed, imgMask, imgFinal;</div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span>* winNameSrc = <span class="string">"Src Image"</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span>* winNameSmoothed = <span class="string">"Smoothed Image"</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span>* winNameMask = <span class="string">"Unsharpen Mask"</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span>* winNameFinal = <span class="string">"Final Image"</span>;</div><div class="line"><span class="comment">//Function Daclarations</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *imgPath = <span class="string">"F:\\ImgPrcSrcs\\DIP3E_Original_Images_CH03\\Fig0340(a)(dipxe_text).tif"</span>;</div><div class="line">  imgSrc = imread(imgPath, CV_LOAD_IMAGE_GRAYSCALE);</div><div class="line">  <span class="comment">// 图像模糊</span></div><div class="line">  blur(imgSrc,imgSmoothed,Size(<span class="number">3</span>,<span class="number">3</span>));</div><div class="line">  <span class="comment">// 反锐化掩膜 = 原图像 - 模糊图像</span></div><div class="line">  imgMask = imgSrc - imgSmoothed;</div><div class="line">  <span class="comment">// 最终图像 = 原图像 + 反锐化图像</span></div><div class="line">  <span class="keyword">double</span> k = <span class="number">1</span>;</div><div class="line">  imgFinal = imgSrc + k*imgMask;</div><div class="line">  namedWindow(winNameSrc,CV_WINDOW_AUTOSIZE);</div><div class="line">  namedWindow(winNameSmoothed,CV_WINDOW_AUTOSIZE);</div><div class="line">  namedWindow(winNameMask,CV_WINDOW_AUTOSIZE);</div><div class="line">  namedWindow(winNameFinal,CV_WINDOW_AUTOSIZE);</div><div class="line">  imshow(winNameSrc,imgSrc);</div><div class="line">  imshow(winNameSmoothed,imgSmoothed);</div><div class="line">  imshow(winNameMask,imgMask);</div><div class="line">  imshow(winNameFinal,imgFinal);</div><div class="line">  waitKey(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="一阶微分的应用-–-梯度"><a href="#一阶微分的应用-–-梯度" class="headerlink" title="一阶微分的应用 – 梯度"></a>一阶微分的应用 – 梯度</h3><p>####Sobel 梯度算子：</p>
<p><img src="http://7pulhb.com1.z0.glb.clouddn.com/ip-sobel 算子. jpg" alt="Soble 算子"></p>
<p>$M(x,y) = |g_x|+|g_y| = |(z_7+2<em>z_8+z_9)-(z_1+2</em>z_2+z_3)|+|(z_3+2<em>z_6+z_9)-(z_1+2</em>z_4+z_7)|$</p>
<p><img src="http://7pulhb.com1.z0.glb.clouddn.com/ip-gx,gy.jpg" alt="gx,gy"></p>
<p>使用权重 2 的目的：突出中心点（最接近中心）的作用以达到平滑的目的。</p>
<p>在<strong>opencv2</strong>中通过</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">Sobel(InputArray src, OutputArray dst, <span class="keyword">int</span> ddepth, <span class="keyword">int</span> xorder, <span class="keyword">int</span> yorder, <span class="keyword">int</span> ksize=<span class="number">3</span>, <span class="keyword">double</span> scale=<span class="number">1</span>, <span class="keyword">double</span> delta=<span class="number">0</span>, <span class="keyword">int</span> borderType=BORDER_DEFAULT )</div></pre></td></tr></table></figure>
<p>实现 sobel 算子，参数解释：</p>
<ul>
<li><p>src – 源图像</p>
</li>
<li><p>dst – 目标图像</p>
</li>
<li><p>ddepth – 目标图像颜色深度。</p>
</li>
<li><p>xorder – x 方向的微分阶数。</p>
</li>
<li><p>yorder – y 方向的微分阶数。</p>
</li>
<li><p>ksize – Sobel 掩膜的大小，仅限于 1, 3, 5, or 7.</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2\highgui\highgui.hpp&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2\imgproc\imgproc.hpp&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</div><div class="line"><span class="comment">//Global Varaibles</span></div><div class="line">Mat imgSrc, imgDst;</div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> *winNameSrc = <span class="string">"Src Image"</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> *winNameDst = <span class="string">"Dist Image"</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *imgPath = <span class="string">"F:\\ImgPrcSrcs\\DIP3E_Original_Images_CH03\\Fig0342(a)(contact_lens_original).tif"</span>;</div><div class="line">  imgSrc = imread(imgPath,CV_LOAD_IMAGE_GRAYSCALE);</div><div class="line">  <span class="comment">// 模糊处理</span></div><div class="line">  GaussianBlur(imgSrc,imgSrc,Size(<span class="number">3</span>,<span class="number">3</span>),<span class="number">0</span>);</div><div class="line">  <span class="comment">//x,y 方向的梯度矩阵</span></div><div class="line">  Mat gradX, gradY;</div><div class="line">  <span class="comment">// 求 x,y 方向的梯度</span></div><div class="line">  Sobel(imgSrc,gradX,CV_16S,<span class="number">1</span>,<span class="number">0</span>);</div><div class="line">  Sobel(imgSrc,gradY,CV_16S,<span class="number">0</span>,<span class="number">1</span>);</div><div class="line">  <span class="comment">// 还原为 8 位色深</span></div><div class="line">  convertScaleAbs(gradX,gradX);</div><div class="line">  convertScaleAbs(gradY, gradY);</div><div class="line">  <span class="comment">//dst = |gradX|+|gradY|</span></div><div class="line">  add(<span class="built_in">abs</span>(gradX), <span class="built_in">abs</span>(gradY), imgDst);</div><div class="line">  namedWindow(winNameSrc,CV_WINDOW_AUTOSIZE);</div><div class="line">  namedWindow(winNameDst,CV_WINDOW_AUTOSIZE);</div><div class="line">  imshow(winNameSrc,imgSrc);</div><div class="line">  imshow(winNameDst,imgDst);</div><div class="line">  waitKey(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://7pulhb.com1.z0.glb.clouddn.com/ip-sobleDemo.jpg" alt="SobelDemo"></p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/03/08/Image_Processing/数字图像处理（7）-- 频率域滤波（1）：基本滤波器介绍/">数字图像处理（7）-- 频率域滤波（1）：基本滤波器介绍</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Mar 8, 2017
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h2 id="陷波滤波器（带阻滤波）："><a href="#陷波滤波器（带阻滤波）：" class="headerlink" title="陷波滤波器（带阻滤波）："></a>陷波滤波器（带阻滤波）：</h2><p><img src="http://7pulhb.com1.z0.glb.clouddn.com/ip - 陷波滤波器. jpg" alt="陷波滤波器"></p>
<p>可以看到，陷波滤波器将图像的平均灰度级置为 0（平均灰度级 “下陷”）。那么，原图像平均灰度级为 0 代表什么？即代表原图的像素灰度要么全为 0，要么有正有负，那么一般就将负数看作零。因而整个陷波操作以后，图像的平均灰度下降，即较之原图像，新图像变暗。</p>
<p><img src="http://7pulhb.com1.z0.glb.clouddn.com/ip - 陷波滤波器 Demo.jpg" alt="陷波滤波器 Demo"></p>
<h2 id="低通滤波器：使低频通过而使高频衰减的滤波器"><a href="#低通滤波器：使低频通过而使高频衰减的滤波器" class="headerlink" title="低通滤波器：使低频通过而使高频衰减的滤波器"></a>低通滤波器：使低频通过而使高频衰减的滤波器</h2><ul>
<li><p>被低通滤波的图像比原始图像少尖锐的细节部分而突出平滑过渡（低频）部分</p>
</li>
<li><p>对比<strong>空间域滤波</strong>的平滑处理，如均值滤波器</p>
</li>
</ul>
<h2 id="高通滤波器：使高频通过而使低频衰减的滤波器"><a href="#高通滤波器：使高频通过而使低频衰减的滤波器" class="headerlink" title="高通滤波器：使高频通过而使低频衰减的滤波器"></a>高通滤波器：使高频通过而使低频衰减的滤波器</h2><ul>
<li><p>被高通滤波的图像比原始图像少灰度级的平滑过渡而突出边缘等细节部分</p>
</li>
<li><p>对比<strong>空间域</strong>的梯度算子、拉普拉斯算子</p>
</li>
</ul>
<p><img src="http://7pulhb.com1.z0.glb.clouddn.com/ip - 低通，高通滤波函数. jpg" alt="低通，高通滤波函数"></p>
<p>如上图所示，低通滤波使得图像高频部分下陷（图像变模糊），高通滤波使得图像低频部分下陷（图像边缘及灰度变化剧烈的部分被显示）。</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/03/08/Image_Processing/数字图像处理（8）-- 频率域滤波（2）：图像平滑/">数字图像处理（8）-- 频率域滤波（2）：图像平滑</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Mar 8, 2017
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h2 id="频率域平滑滤波器："><a href="#频率域平滑滤波器：" class="headerlink" title="频率域平滑滤波器："></a>频率域平滑滤波器：</h2><h3 id="理想低通滤波器（ILPF）："><a href="#理想低通滤波器（ILPF）：" class="headerlink" title="理想低通滤波器（ILPF）："></a>理想低通滤波器（ILPF）：</h3><p><img src="http://7pulhb.com1.z0.glb.clouddn.com/ip - 理想低通滤波器. jpg" alt="理想低通滤波器"></p>
<p>可以看到，理想低通滤波器很 “武断” 的截断了 $D_0$ 以外的所有频率成分。即在半径为 $D_0$ 的圆内，所有频率没有衰减地通过滤波器，而在此半径的圆之外的所有频率完全被衰减掉。这种 “武断” 是不留一丝情面的, 可以看到下图的滤波函数及傅里叶频谱中光滑的圆周：</p>
<p><img src="http://7pulhb.com1.z0.glb.clouddn.com/ip - 武断的理想低通滤波器. jpg" alt="不留情面的“斩断”"></p>
<p>下图为理想滤波器的模糊效果，可以观察到其产生了振铃现象：</p>
<p><img src="http://7pulhb.com1.z0.glb.clouddn.com/ip - 理想低通滤波器 Demo.jpg" alt="理想滤波器 Demo"></p>
<h3 id="巴特沃斯低通滤波器-BLPF-："><a href="#巴特沃斯低通滤波器-BLPF-：" class="headerlink" title="巴特沃斯低通滤波器(BLPF) ："></a>巴特沃斯低通滤波器(BLPF) ：</h3><p><img src="http://7pulhb.com1.z0.glb.clouddn.com/ip - 巴特沃斯滤波器. jpg" alt="巴特沃斯滤波器"></p>
<p><img src="http://7pulhb.com1.z0.glb.clouddn.com/ip - 巴特沃斯的“斩断”.jpg" alt="巴特沃斯的“斩断”"></p>
<p>如图，巴特沃斯低通滤波器就不像理想低通滤波器那样“武断”，截断部分与未截断部分 有一定的过度，这就使得平滑后的图像 过度更加自然。当然要注意的是，如最右边的图像所示，随着阶数 $n$ 的升高，巴特沃斯低通滤波器越来越趋近于理想低通滤波器，故而阶数越高，越容易产生振铃现象。</p>
<p>如图是 n=2 时候的巴特沃斯低通滤波器：</p>
<p><img src="http://7pulhb.com1.z0.glb.clouddn.com/ip - 巴特沃斯 Demo.jpg" alt="巴特沃斯 Demo"></p>
<p>高斯低通滤波器（GLPF）：</p>
<p><img src="http://7pulhb.com1.z0.glb.clouddn.com/ip - 高斯滤波器. jpg" alt="高斯低通滤波器"></p>
<p><img src="http://7pulhb.com1.z0.glb.clouddn.com/ip - 高通的“斩断”.jpg" alt="高斯低通滤波器"></p>
<p>可以看到，高斯低通滤波器非常近似于巴特沃斯低通滤波器，但滤波曲线更加陡峭，并且即便随着 $D_0$ 的变化，其滤波曲线仍然能保持一定形状。</p>
<p><img src="http://7pulhb.com1.z0.glb.clouddn.com/ip - 高斯滤波器 Demo.jpg" alt="高斯低通滤波器 Demo"></p>
<p>关于 BLPF 与 GLPF 的选用：</p>
<ul>
<li><p>GLPF 不能达到有相同截止频率的二阶 BLPF 的平滑效果</p>
</li>
<li><p>GLPF 没有振铃</p>
</li>
<li><p>如果需要严格控制低频和高频之间截至频率的过渡，选用 BLPF，代价是可能产生振铃</p>
</li>
</ul>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/08/02/thunkify/">thunkify</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Aug 2, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>自己之前曾经撸过一个验证库，代码大致如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">validate</span>(<span class="params">data, rules, cb</span>) </span>&#123;</div><div class="line">  <span class="comment">// ....</span></div><div class="line">  <span class="comment">// 一切完成后会触发回调函数</span></div><div class="line">  cb(<span class="literal">null</span>, errMap);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>出于性能上的考虑，该库被封装为了一个异步函数，需要提供一个回调函数 <code>cb</code> 来获得验证结果，该回调函数是一个满足 node 规范的 <strong>error-first callback</strong>。在其他系统中，该库使用良好，但是，新项目使用了 koa，我在中间件中使用这个库提供的 <code>validate</code> 方法， 却连编译期都没有通过：</p>
          <div class="read-more">
            <a href="/2016/08/02/thunkify/" class="read-more-link">Read more..</a>
          </div>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/08/01/使用-ES6-中的-generator-来优化异步过程（翻译及补充）/">使用 ES6 中的 generator 来优化异步过程</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Aug 1, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <blockquote>
<p>原文：<a href="https://davidwalsh.name/async-generators" target="_blank" rel="external">Going Async With ES6 Generators</a><br>本文在作者文章的基础上，适当补充了一些代码及说明</p>
</blockquote>
<p>ES6 中的 generator 能够帮助我们提供一种类似同步一样的代码风格，来将异步过程的具体实现隐藏。这样的好处就是我们能够更加自然的表达自己的业务流程（work flow），而避免陷入异步的麻烦中。换言之，借助于 generator，我们既拥有了异步执行的能力，又不用再绞尽脑汁的去维护异步代码。</p>
<p>继续阅读本文，你会发现这么做的结果简直太美妙了，以前那些糟糕的异步代码现在讲会想同步代码那样变得 <strong> 易于阅读 </strong> 和 <strong> 可维护 </strong>。需要知道的是，这个同步只是代码风格上的同步，他的执行过程仍然是异步的。</p>
<p>说了那么多，仍然有些抽象，现在我们由浅入深地看看到底怎么通过 ES6 来优化异步过程。</p>
<h2 id="一个最简单的异步"><a href="#一个最简单的异步" class="headerlink" title="一个最简单的异步"></a>一个最简单的异步</h2><p>假设我们的程序原来拥有这样的异步代码，这是最为朴实和原始的 JavaScript 异步流程控制：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeAjaxCall</span>(<span class="params">url,cb</span>) </span>&#123;</div><div class="line">    <span class="comment">// do some ajax fun</span></div><div class="line">    <span class="comment">// call `cb(result)` when complete</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">makeAjaxCall( <span class="string">"http://some.url.1"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">result1</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse( result1 );</div><div class="line"></div><div class="line">    makeAjaxCall( <span class="string">"http://some.url.2/?id="</span> + data.id, <span class="function"><span class="keyword">function</span>(<span class="params">result2</span>)</span>&#123;</div><div class="line">        <span class="keyword">var</span> resp = <span class="built_in">JSON</span>.parse( result2 );</div><div class="line">        <span class="built_in">console</span>.log( <span class="string">"The value you asked for:"</span> + resp.value );</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>可以看到，对于一次异步请求，我们获取异步结果的过程放到了回调当中。然而，借助 generator 来完成相同的任务：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 我们将真正的异步功能掩藏在 `request` 中，这样我们在 generator 中能专注同步写法</span></div><div class="line">    <span class="comment">// 通过 `it.next(..)` 来获得异步结果，并让 generator 的流程继续</span></div><div class="line">  makeAjaxCall(url, (result)=&gt;&#123;</div><div class="line">    it.next(result);</div><div class="line">  &#125;);</div><div class="line">  <span class="comment">// 注意，这里没有返回任何值，也就是说 `request()` 的执行结果会返回 `undefined`</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">main</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 在 generator 中，我们的异步处理流程摇身一变成了同步执行过程</span></div><div class="line">  <span class="keyword">const</span> result1 = <span class="keyword">yield</span> request(<span class="string">'http://some.url.1'</span>);</div><div class="line">  <span class="keyword">const</span> data =  <span class="built_in">JSON</span>.parse(result1);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> result2 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.2?id="</span> + data.id );</div><div class="line">    <span class="keyword">const</span> resp = <span class="built_in">JSON</span>.parse( result2 );</div><div class="line">    <span class="built_in">console</span>.log( <span class="string">"The value you asked for:"</span> + resp.value );</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// `main()` 方法执行后，generator 进入暂态，当 `makAjaxCall` 异步任务完成后，会让 `main()` 继续</span></div><div class="line">it = main();</div><div class="line">it.next();</div></pre></td></tr></table></figure>
<p>可以看到，generator 函数 <code>*main(..)</code> 自身非常纯净，我们在其中撰写业务流程就像我们在 PHP 或者 Java 等语言撰写业务流程，看不到任何的回调。</p>
<p>下面解释一下以上代码片是如何工作的：</p>
<p>helper 函数 <code>request(..)</code> 简单的包裹了异步任务 <code>makeAjaxCall(..)</code>，一旦 <code>makeAjaxCall(..)</code> 取得了结果，就调用 generator 迭代器的 <code>next(..)</code> 方法使 generator 继续运行。</p>
<p>当 <code>*main</code> 运行到 <code>yield ..</code> 后，他会被暂停在 <code>yield</code> 发生的位置，直到遇到了在 <code>makeAjaxCall(..)</code> 的回调中声明的 <code>it.next(..)</code> 才会继续执行。注意到，我们把 Ajax 请求到的结果 <code>result</code> 传递给了 <code>it.next(..)</code>，那么之后，<code>result</code> 就会被返回到的 <code>*main</code> 暂停了的位置，作为 <code>yield ..</code> 表达式的输出，所以，<code>result1</code> 不会是 <code>undefined</code>（默认情况下，<code>yield</code> 返回 <code>undefined</code>），而是拿到的异步结果。</p>
<p>这就是真正牛逼的地方。语句 <code>result1 = yield request(..)</code> 所表达的意图是要去请求一个值，但是，这个请求过程却被隐藏了。利用 <code>yield</code> 实现 <strong> 暂停 </strong> 功能，然后将 <strong> 继续 </strong> 功能放到 generator 函数以外地方，更准确地说，是放到了 generator 以外的异步回调中，从而保证了我们能够在 generator 中利用 <strong> 同步 </strong> 方式撰写业务流程。</p>
<blockquote>
<p><strong> 暂停 - 继续 </strong> 这样串行执行的过程模拟了 <strong> 同步 </strong> 的过程，使得这条语句在语法风格上实现了同步，但其内部实现又是异步的。</p>
</blockquote>
<p>别高兴的太早，上面的代码还存在一些问题。在上面的代码中，我们总是执行一个异步 Ajax 调用，但是，如果我们之后将 Ajax 的返回结果缓存到了内存来提升性能，这意味着我们下一次请求不再需要去服务端获得数据，而可以立即从内存上获取。为了满足这个需求，我们可能就会将代码改成如下形式:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> cache = &#123;&#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span>(cache[url]) &#123;</div><div class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</div><div class="line">      it.next(cacheUrl);</div><div class="line">    &#125;,<span class="number">0</span>);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    makeAjaxCall(url, (resp)=&gt;&#123;</div><div class="line">      it.next(resp);</div><div class="line">      cache[url] = resp;</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意：这里用到了 <code>setTimeout(..0)</code> 这个小技巧来强行进入异步过程，如果我们直接调用 <code>it.next(cacheUrl)</code>，就会出错，原因在于执行语句 <code>yield request(..)</code> 时，我们先执行 <code>request(..)</code>，之后 generator 函数才会暂停（后执行 <code>yield</code> ）。所以，如果我们直接调用 <code>it.next(cacheUrl)</code>，则流程如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">next()-&gt;request()-&gt;next()</div></pre></td></tr></table></figure>
<p>由于此时 generator 已经运行了，程序会抛出错误 <code>Generator is already running</code>。而通过 <code>setTimeout(..0)</code> 包裹后，我们的执行流程如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">next()-&gt;request()-&gt;yield-&gt;next()-&gt; 继续</div></pre></td></tr></table></figure>
<p>整个业务才能继续执行。</p>
<p>现在，我们的 generator 是这样的:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> result1 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.1"</span> );</div><div class="line"><span class="keyword">const</span> data = <span class="built_in">JSON</span>.parse( result1 );</div></pre></td></tr></table></figure>
<p>牛逼吧？尽管我们新添加了缓存的逻辑，但丝毫不影响我们的 generator 函数，仍旧是在专心的写业务。在 <code>*main()</code> 中，其过程仍然是非常清晰的业务流：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">请求值 --&gt; 暂停（等待请求完成）--&gt; 获得值 --&gt; 继续</div></pre></td></tr></table></figure>
<blockquote>
<p>在该场景下，暂停的持续时间变得很微妙，他可能很长（比如向服务器请求值），也可能很短（比如从内存缓存中请求值），但在我们的 <code>*main()</code> 中，还是只关注工作流（flow），无论异步过程的实现细节是否变得复杂。</p>
</blockquote>
<h2 id="更好的异步流程控制"><a href="#更好的异步流程控制" class="headerlink" title="更好的异步流程控制"></a>更好的异步流程控制</h2><p>上面的代码已经满足了一些简单的异步场景。但是很快，他的功能就会显得捉襟见肘，我们需要一个更加强大的异步机制来结合我们的 generator 去满足更大的业务场景。这个机制就是 <strong>Promises</strong>。</p>
<blockquote>
<p>对于 ES6 中 Promise 尚存疑惑的读者可以看下作者关于此的<a href="http://blog.getify.com/promises-part-1/" target="_blank" rel="external">博客</a>。</p>
</blockquote>
<p>首先，我们反思一下之前的设计缺陷：</p>
<ul>
<li>缺乏清晰的错误处理</li>
</ul>
<p>在 <a href="https://davidwalsh.name/es6-generators-dive#error-handling" target="_blank" rel="external">作者之前撰写的文章</a> 中，我们能够知道一些在 Ajax 调用过程中检测错误的手段：通过 <code>it.throw(..)</code> 将错误返回的 generator 中，而在 generator 中，我们又通过 <code>try..catch</code> 来俘获错误，进行错误处理:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>) </span>&#123;</div><div class="line">  makeAjaxCall(url, (err,result)=&gt;&#123;</div><div class="line">    <span class="keyword">if</span>(err) it.throw(err);</div><div class="line">    <span class="keyword">else</span> it.next(result);</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">main</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">const</span> result1 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.1"</span> );</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (err) &#123;</div><div class="line">        <span class="built_in">console</span>.log( <span class="string">"Error:"</span> + err );</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">const</span> data = <span class="built_in">JSON</span>.parse( result1 );</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">const</span> result2 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.2?id="</span> + data.id );</div><div class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</div><div class="line">        <span class="built_in">console</span>.log( <span class="string">"Error:"</span> + err );</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">const</span> resp = <span class="built_in">JSON</span>.parse( result2 );</div><div class="line">    <span class="built_in">console</span>.log( <span class="string">"The value you asked for:"</span> + resp.value );</div><div class="line">&#125; );</div></pre></td></tr></table></figure>
<p>这样做的坏处就是，我们把错误抛出耦合到了 Ajax 流程中，设想，我们有还有其他的 generator 也用到了 <code>request(..)</code>，我们的错误控制就会变成这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>) </span>&#123;</div><div class="line">    makeAjaxCall(url, (err,result)=&gt;&#123;</div><div class="line">        <span class="keyword">if</span>(err) &#123;</div><div class="line">            it1.throw(err);</div><div class="line">            it2.throw(err);</div><div class="line">            it3.throw(err);</div><div class="line">            <span class="comment">// ..</span></div><div class="line">            itn.throw(err);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这使得 <code>request(..)</code> 难以复用。</p>
<ul>
<li>如果 <code>makeAjaxCall(..)</code> 是一个并不受我们的控制的第三方库</li>
</ul>
<p>我们如果要在其中做诸如 <code>it.next(..)</code> 这样对 generator 的控制，就不得不修改这个库的实现，耗费人力不说，随意破坏第三方库也会使得代码难以移植。</p>
<ul>
<li>并行任务。</li>
</ul>
<p>由于 generator 中的 <code>yield</code> 是一个单步暂停点，同一时刻就只能跑一个任务。所以，我们渴望一个新的方式去执行并行任务，并且不需要太多的人工介入。</p>
<p>要解决上述的问题就需要我们探索新的设计模式了，结合这个新的设计模式，能让我们的基于 generator 的异步过程变得更加优雅。这个新的设计模式将会引入 <strong>Promise</strong>，其流程大致如下：</p>
<p><code>yield</code> 一个 Promise 对象后暂停，直至这些 Promise 对象被 <strong> 履行（fulfill）</strong> 的时候才继续我们的 generator。由于并行的 <code>Promise.all([..])</code> 也是一个 Promise 对象，所以在这种设计模式下，也能执行并行任务。</p>
<p>让我们对之前的 <code>request(..)</code> 函数加以修改，使之基于 Promise：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</div><div class="line">      <span class="comment">// 现在，`makeAjaxCall(..)` 不再耦合 `it.next(..)`</span></div><div class="line">        makeAjaxCall( url, (result)=&gt;resolve(result));</div><div class="line">    &#125; );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>request(..)</code> 构造了一个 Promise 对象并返回，该 Promise 对象将会在 Ajax 请求完成后被 resolved。现在，generator 中的 <code>yield</code> 最终也将产出这个 Promise 对象。我们还需要一个工具函数来控制我们的 generator 的迭代器，完成我们 generator 函数的自动执行。我们暂且将这个工具函数称之为 <code>runGenerator(..)</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// `runGenerator` 函数将运行一个 generator 函数 `g` 直至其完成</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">runGenerator</span>(<span class="params">g</span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> it = g(), ret;</div><div class="line">    <span class="comment">// 执行迭代过程的函数，首次立即执行的目的是为了启动 generator</span></div><div class="line">    (<span class="function"><span class="keyword">function</span> <span class="title">iterate</span>(<span class="params">val</span>)</span>&#123;</div><div class="line">        <span class="comment">// 获得最近迭代结果, 启动时 val 是 undefined</span></div><div class="line">        ret = it.next( val );</div><div class="line"></div><div class="line">    <span class="comment">// 如果 generator 没有执行完毕</span></div><div class="line">        <span class="keyword">if</span> (!ret.done) &#123;</div><div class="line">            <span class="comment">// 是否 `ret` 仍然是一个 Promise 对象，如果是，意味着 generator 还在不断 yield</span></div><div class="line">            <span class="keyword">if</span> (<span class="string">"then"</span> <span class="keyword">in</span> ret.value) &#123;</div><div class="line">                <span class="comment">// 将 `iterate(val)` 注册为该 Promise 的 `then(..)` 的回调，</span></div><div class="line">                <span class="comment">// 借此，获得一个 Promise 链</span></div><div class="line">                ret.value.then( iterate );</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 如果不是 Promise 对象，而是立即数, 将该结果返回</span></div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// avoid synchronous recursion</span></div><div class="line">                setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">                    iterate( ret.value ); <span class="comment">// 相当于 `it.next(立即数)`</span></div><div class="line">                &#125;, <span class="number">0</span> );</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;)();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以分析一下该工具函数的执行过程：</p>
<ol>
<li>我们首先初始化了传入的 generator 的迭代器 <code>it</code>，并且创建了一个迭代函数 <code>iterate</code>，该迭代函数用来 <strong> 继续 </strong> generator 的流程，从而让 generator 的自动执行至完毕。</li>
<li>每次我们执行 <code>iterator(val)</code>，就会调用 <code>it.next(val)</code>，并且获得结果 <code>ret</code>。假设我们 generator 中的执行语句是 <code>yield request( &quot;http://some.url.1&quot; )</code>，<code>request(..)</code> 会返回一个 Promise 对象，此时，<code>ret</code> 也就是该 Promise 对象，我们向其 <code>then(..)</code> 方法注册 <code>iterator</code>，使得该 Promise 对象完成后能够进入下一个 Promise 对象的流程，并且每次完成都会继续 generator。</li>
<li>当 <code>iterator(val)</code> 不停流转，直至 <code>val</code> 是一个立即数时，暗示 Promise 链执行完毕，获得了结果，将其返回到 generator 使 generator 得以继续执行。</li>
</ol>
<blockquote>
<p>简言之，结合了 Promise 的 generator 异步流程就是：每次 <code>yield</code> 一个 Promise 进入暂停态，在 Promise 完成后 generator 得以继续执行。</p>
</blockquote>
<p>下面我们看看怎么使用 <code>runGenerator</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">runGenerator( <span class="function"><span class="keyword">function</span> *<span class="title">main</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">const</span> result1 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.1"</span> );</div><div class="line">    <span class="keyword">const</span> data = <span class="built_in">JSON</span>.parse( result1 );</div><div class="line"></div><div class="line">    <span class="keyword">const</span> result2 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.2?id="</span> + data.id );</div><div class="line">    <span class="keyword">const</span> resp = <span class="built_in">JSON</span>.parse( result2 );</div><div class="line">    <span class="built_in">console</span>.log( <span class="string">"The value you asked for:"</span> + resp.value );</div><div class="line">&#125; );</div></pre></td></tr></table></figure>
<p>简直碉堡了，有没有！我们的业务逻辑仍然没什么变化！</p>
<p>设想，如果我们不做 <code>runGenerator</code> 函数，就需要手动控制 generator 的流程：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> it = main(); <span class="comment">// 获得 generator 的迭代器</span></div><div class="line"><span class="comment">// 不断用 `then(..)` 修饰 Promise</span></div><div class="line">it.next().value.then(<span class="function">(<span class="params">result1</span>)=&gt;</span>&#123;</div><div class="line">  it.next(result1).value.then(<span class="function">(<span class="params">result2</span>)=&gt;</span>&#123;</div><div class="line">    <span class="comment">// 最终的结果返回</span></div><div class="line">    it.next(result2);</div><div class="line">  &#125;)</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>如果业务流非常漫长，则撰写的嵌套是非常恐怖的。</p>
<p>现在，我们已经使用了 Promise 来管理基于 generator 的异步流程，它将我们从充满了诸如回调陷阱（callback hell）中解放了出来。通过 generators+promise 这个设计模式，我们阐述一下如何解决上面提到的三个问题：</p>
<ol>
<li>现在，我们拥有内置的错误处理。虽然这点没有在上面的 <code>runGenerator(..)</code> 进行揭示，但是，后文会讲到，在新的设计模式下，从 Promise 中监听所有的错误并不困难。最终通过将错误绑定到 <code>it.throw(..)</code>，我们就可以放心的在 generator 中使用 <code>try..catch</code> 语句来捕获和处理错误。</li>
<li>我们拥有了 Promise 提供的 <a href="https://blog.getify.com/promises-part-2/#uninversion" target="_blank" rel="external">control/trustability</a>。</li>
<li>Promise 已经做了大量抽象帮助我们方便的操纵多个 “并行的” 任务。</li>
</ol>
<p>例如，<code>yield Promise.all([..])</code> 将会利用传入的并行的任务数组（数组元素都是 Promise 对象），产出单一的 Promise 对象供 generator 操纵，generator 会等待所有的子 Promise 对象完成（无论完成顺序是怎样的）才继续进行。最后，我们真正返回给 generator 流程的是所有子 Promise 的响应构成的数组，数组元素的顺序会与请求顺序一致。</p>
<h2 id="generators-promise-下的错误处理"><a href="#generators-promise-下的错误处理" class="headerlink" title="generators+promise 下的错误处理"></a>generators+promise 下的错误处理</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</div><div class="line">        makeAjaxCall( url, (err,text)=&gt;&#123;</div><div class="line">            <span class="keyword">if</span> (err) reject( err );</div><div class="line">            <span class="keyword">else</span> resolve( text );</div><div class="line">        &#125; );</div><div class="line">    &#125; );</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">runGenerator</span>(<span class="params">g</span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> it = g(), ret;</div><div class="line">    <span class="comment">// 现在，传入了 `err` 作为第一个参数</span></div><div class="line">    (<span class="function"><span class="keyword">function</span> <span class="title">iterate</span>(<span class="params">err, val</span>)</span>&#123;</div><div class="line">        <span class="comment">// generator 迭代过程中遇到错误就 `throw`</span></div><div class="line">        <span class="keyword">if</span>(err) &#123;</div><div class="line">          setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</div><div class="line">            it.throw(err);</div><div class="line">          &#125;,<span class="number">0</span>);</div><div class="line">          <span class="keyword">return</span>;</div><div class="line">      &#125;</div><div class="line">        ret = it.next( val );</div><div class="line"></div><div class="line">    <span class="comment">// 如果 generator 没有执行完毕</span></div><div class="line">        <span class="keyword">if</span> (!ret.done) &#123;</div><div class="line">            <span class="comment">// 是否 `ret` 仍然是一个 Promise 对象，如果是，意味着 generator 还在不断 `yield`</span></div><div class="line">            <span class="keyword">if</span> (<span class="string">"then"</span> <span class="keyword">in</span> ret.value) &#123;</div><div class="line">                <span class="comment">// 将 `iterate(val)` 注册为该 Promise 的 `then(..)` 的回调，</span></div><div class="line">                <span class="comment">// 借此，获得一个 Promise 链</span></div><div class="line">                ret.value.then( iterate );</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 如果不是 Promise 对象，而是立即数，暗示 Promise 链已经获得最终结果，将该结果返回</span></div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// avoid synchronous recursion</span></div><div class="line">                setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">                    iterate( ret.value ); <span class="comment">// 相当于 it.next(立即数)</span></div><div class="line">                &#125;, <span class="number">0</span> );</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;)();</div><div class="line">&#125;</div><div class="line"></div><div class="line">runGenerator(<span class="function"><span class="keyword">function</span> *<span class="title">main</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">const</span> result1 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.1"</span> );</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (err) &#123;</div><div class="line">        <span class="built_in">console</span>.log( <span class="string">"Error:"</span> + err );</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">const</span> data = <span class="built_in">JSON</span>.parse( result1 );</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">const</span> result2 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.2?id="</span> + data.id );</div><div class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</div><div class="line">        <span class="built_in">console</span>.log( <span class="string">"Error:"</span> + err );</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">const</span> resp = <span class="built_in">JSON</span>.parse( result2 );</div><div class="line">    <span class="built_in">console</span>.log( <span class="string">"The value you asked for:"</span> + resp.value );</div><div class="line">&#125; );</div></pre></td></tr></table></figure>
<p>如果一个 Promise 的 reject 发生，那么该 reject 对应到的错误会映射到 generator 中的能够捕获的一个错误，这个映射过程是通过 <code>runGenerator(..)</code> 中声明的 <code>it.throw(..)</code> 来完成的。</p>
<h2 id="generators-promise-下的并行任务"><a href="#generators-promise-下的并行任务" class="headerlink" title="generators+promise 下的并行任务"></a>generators+promise 下的并行任务</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</div><div class="line">        makeAjaxCall( url, resolve );</div><div class="line">    &#125; )</div><div class="line">    <span class="comment">// 当获得返回的 `text`，可以做一些后置处理</span></div><div class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">text</span>)</span>&#123;</div><div class="line">        <span class="comment">// did we just get a (redirect) URL back?</span></div><div class="line">        <span class="keyword">if</span> (<span class="regexp">/^https?:\/\/.+/</span>.test( text )) &#123;</div><div class="line">            <span class="comment">// make another sub-request to the new URL</span></div><div class="line">            <span class="keyword">return</span> request( text );</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// otherwise, assume text is what we expected to get back</span></div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> text;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">runGenerator( <span class="function"><span class="keyword">function</span> *<span class="title">main</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">const</span> search_terms = <span class="keyword">yield</span> <span class="built_in">Promise</span>.all( [</div><div class="line">        request( <span class="string">"http://some.url.1"</span> ), <span class="comment">// 每个元素也是 promise 对象</span></div><div class="line">        request( <span class="string">"http://some.url.2"</span> ),</div><div class="line">        request( <span class="string">"http://some.url.3"</span> )</div><div class="line">    ] );</div><div class="line"></div><div class="line">    <span class="keyword">const</span> search_results = <span class="keyword">yield</span> request(</div><div class="line">        <span class="string">"http://some.url.4?search="</span> + search_terms.join( <span class="string">"+"</span> )</div><div class="line">    );</div><div class="line">    <span class="keyword">const</span> resp = <span class="built_in">JSON</span>.parse( search_results );</div><div class="line"></div><div class="line">    <span class="built_in">console</span>.log( <span class="string">"Search results:"</span> + resp.value );</div><div class="line">&#125; );</div></pre></td></tr></table></figure>
<p>在上面代码中，<code>Promise.all([ .. ])</code> 创建了一个 Promise 对象，该对象会等待三个子 Promise 对象完成。最终，返回的到 generator 的，恢复 generator 执行的，会是该 Promise 对象的执行结果。</p>
<h3 id="ES7-中的-async"><a href="#ES7-中的-async" class="headerlink" title="ES7 中的 async"></a>ES7 中的 <code>async</code></h3><p>尚未发布的 ES7 标准中提出了一个 <code>async</code> 函数，该函数就像我们上面撰写被 <code>runGenerator(..)</code> 所包裹的 generator。通过 <code>await</code> 关键字，你能够发出 Promise 对象，他会等待这些对象完成后才继续下去（我们甚至都不再需要借助迭代器了）。</p>
<p>aysnc 函数的大致使用过程如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> result1 = <span class="keyword">await</span> request( <span class="string">"http://some.url.1"</span> );</div><div class="line">    <span class="keyword">const</span> data = <span class="built_in">JSON</span>.parse( result1 );</div><div class="line"></div><div class="line">    <span class="keyword">const</span> result2 = <span class="keyword">await</span> request( <span class="string">"http://some.url.2?id="</span> + data.id );</div><div class="line">    <span class="keyword">const</span> resp = <span class="built_in">JSON</span>.parse( result2 );</div><div class="line">    <span class="built_in">console</span>.log( <span class="string">"The value you asked for:"</span> + resp.value );</div><div class="line">&#125;</div><div class="line"></div><div class="line">main();</div></pre></td></tr></table></figure>
<p>正如你所看到的那样，一个 <code>async function</code> 能够被直接调用，而不需要再包裹上 <code>runGenerator(..)</code>。其次，我们将用新的关键字 <code>await</code> 来替代 <code>yield</code> 告诉 <code>async function</code> 在继续前需要等待当前的 Promise 处理完成。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>generator+promise 的设计模式集成了强大而优雅的同步式的异步流程控制的优势。通过简单的 wrapper 函数，我们能够自动地运行我们的 generator 直至完成，包括清晰明了的同步式的错误控制。</p>
<p>而在 ES7 以上的版本，我们还能有 <code>async function</code> 来完成同样的任务。</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/06/28/JavaScript-中的递归优化/">JavaScript 中的递归优化</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Jun 28, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>说到递归，我们先来看一个最常见的递归用例：<strong> 计算阶乘 </strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">  <span class="keyword">return</span> n*factorial(n<span class="number">-1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试一下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">factorial(<span class="number">5</span>); <span class="comment">// =&gt; 120</span></div></pre></td></tr></table></figure>
<p>似乎一切正常，5 的阶乘 120 被正确计算出来了，我们试着把数字调大一些：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">factorial(<span class="number">70000</span>);</div><div class="line"><span class="comment">// Uncaught RangeError:Maximum call stack size exceeded(…)</span></div></pre></td></tr></table></figure>
<p>浏览器提示我们 <strong> 栈溢出 </strong> 了（测试环境：chrome 51），究竟发生了什么呢?</p>
          <div class="read-more">
            <a href="/2016/06/28/JavaScript-中的递归优化/" class="read-more-link">Read more..</a>
          </div>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/06/23/Redux-的中间件/">Redux 中间件的实现</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Jun 23, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>我们知道在 Redux 中，dispatch 的作用在于派发一个 action，该 action 会被 reducer 收到，reducer 根据 action 的类型进行相应的状态（state）维护：</p>
<div style="text-align:center"><br><img src="https://www.lucidchart.com/publicSegments/view/bc695af5-28c4-432d-ba5f-270905ce996e/image.png" width="500"></img><br></div>
          <div class="read-more">
            <a href="/2016/06/23/Redux-的中间件/" class="read-more-link">Read more..</a>
          </div>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/06/20/Flux下的组件化开发/">Flux 下的组件化开发</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Jun 20, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h2 id="Flux-构成"><a href="#Flux-构成" class="headerlink" title="Flux 构成"></a>Flux 构成</h2><p>首先要明确的是，Flux 并不是一个前端框架，而是前端的一个设计模式，一个状态管理机制，其把前端的一个交互流程简单的模拟成了一个单向数据流。</p>
<div style="text-align:center"><br><img src="http://facebook.github.io/flux/img/flux-simple-f8-diagram-1300w.png" width="500"><br></div>

<p>在上图中，我们可以看到 Flux 的四个核心构成：</p>
<h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p>一个交互动作, 更多的时候代表一个时间，比如用户在页面组件上的点击（click），失焦（blur），双击（doubleclick）等等。一个 Action 往往由如下两个部分组成：</p>
<ul>
<li>交互类型（type）：例如创建、删除、更新等</li>
<li>交互体（payload）：或者说交互的携带信息，例如创建的文本</li>
</ul>
<h3 id="Dispatcher"><a href="#Dispatcher" class="headerlink" title="Dispatcher"></a>Dispatcher</h3><p>Action 分发器。从上图的数据流中，我们可以看到，用户每次产生的 Action 将被送入 Dispatcher，Dispatcher 对 Action 进行简单的包裹之后将其派发到 <strong> 所有 </strong> Store 中。</p>
<blockquote>
<p>注意！Dispatcher 的这种广播行为有别于 <strong>Pub/Sub</strong> 模型，在 Pub/Sub 模型中，需要声明订阅的消息类型，然后发布者会像订阅者广播特定类型的消息。而在 Dispatcher 中，Store 向其注册的任意回调接口都不要声明订阅的 Action 类型，即 Store 只告诉 Dispatcher “如果 Action 到来，请你把它发送给我”。当 Dispatcher 派发 Action 时，所有注册到 Dispatcher 的 callback 都会得到响应。回调可以通过简单的 switch-case 来针对不对类型的 Action 做出不同的响应。</p>
</blockquote>
<h2 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h2><p>数据仓库，保存了我们某个前端 App 的数据以及对数据的操作。Store 会向 Dispatcher 注册一个回调函数，该回调函数接受一个 Action 作为参数。当 Action 被派发到 Store 时，该回调函数被调用，借由 Action 中描述的 <strong> 交互类型（type）</strong>，Store 进行不同处理，这些处理都将被持久化到 Store 维护的数据对象上。</p>
<p>Store 完成数据的变更后，由于 Flux 并不是双向数据绑定的，因而即便我们已经持久化了 Store 中的数据，但组件的数据并未得到更新，组件也不会重新渲染。所以，每次数据变动后，为了告知组件去更新数据，Store 会 emit 一个 change 事件。当监听到 change 事件发生，注册到监听器上的回调去完成各个组件的状态更新。</p>
<h2 id="View"><a href="#View" class="headerlink" title="View"></a>View</h2><p>顾名思义，这就是用户所能看到的视图。有别于传统的 MVC，在 Flux 中，View 并不会和数据模型（Model）产生交互，其只会产生各种交互行为（Actions），这些行为将会被送到 Dispatcher 中，如下图所示：</p>
<div style="text-align:center"><br><img src="http://facebook.github.io/flux/img/flux-simple-f8-diagram-with-client-action-1300w.png" width="500"><br></div>

<p>当 View 中维护的状态变动时，View 需要被重新渲染。</p>
<h2 id="Todo-栗子"><a href="#Todo-栗子" class="headerlink" title="Todo 栗子"></a>Todo 栗子</h2><p>下面我们分析一个用 React+Flux 实现的一个 Flux 栗子，其源码托管在 <a href="https://github.com/facebook/flux/tree/master/examples/flux-todomvc" target="_blank" rel="external">github</a>上。</p>
<p>在项目实践中，面向组件化开发的最佳场景我认为是 <strong> 交互驱动型的开发 </strong>，该定义可能不够准确，其描述的是一旦一个完善的交互设计稿产生后，我们就可以从交互稿中 <strong> 分割 </strong> 出组件，并进行组件的状态 <strong> 分析 </strong>。假设我们得到了 Todo 的交互原型：</p>
<div style="text-align:center"><br><img src="http://7pulhb.com2.z0.glb.clouddn.com/Flux-Todo%E4%BA%A4%E4%BA%92%E5%8E%9F%E5%9E%8B.png" width="800"><br></div>

<blockquote>
<p>这是交互设计师的给我们的原稿，并且，原稿可能远不止这样一幅简单的图像，可能还包括更多的交互效果</p>
</blockquote>
<p>我们将会把这个应用拆分为如下组件：</p>
<h3 id="TodoApp"><a href="#TodoApp" class="headerlink" title="TodoApp"></a>TodoApp</h3><div style="text-align:center"><br><img src="http://7pulhb.com2.z0.glb.clouddn.com/Flux-TodoApp.png" width="500"><br></div>

<p>通常，在前端面向组件化的开发过程中，我们往往需要一个顶部容器包裹住我们的组件，一个页面可以存在若干个这样的顶部容器，这个容器类似一个集装箱或者盒子，封装了某个页面应用的所有组件和状态。例如，在某视频网站中，视频播放窗口可以作为一个顶部容器，其包裹了播放窗口，进度条，播放选项等各个组件，同时，评论部分也可以作为一个顶部容器，其包裹了评论列表，评论框等组件。</p>
<p>在 Todo 中，TodoApp 作为一个顶部容器，包裹了所有 Todo 应用需要的组件，这样，我们在应用入口只需要从 TodoApp 开始渲染，进而逐个渲染其子组件。但更为重要的是，TodoApp 将会封装其下各个组件需要用到的状态，通过数据流，各个组件将会收到状态，并且在状态改变时，重新开始渲染自己，最终更新页面内容。</p>
<h3 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h3><div style="text-align:center"><br><img src="http://7pulhb.com2.z0.glb.clouddn.com/Flux-TodoHeader.png" width="500"><br></div>

<p>这是一个头部组件，根据交互设计，他除了将保有静态的 “todos” 文字标题以外，还将会具有如下行为：</p>
<ul>
<li>右侧输入框失焦或者按下回车键：创建新的 todo 任务</li>
</ul>
<p>可以看到，由于 Header 不维护任何状态，所以 Header 是一个 <strong> 无状态（Stateless）</strong> 的组件</p>
<h3 id="Footer"><a href="#Footer" class="headerlink" title="Footer"></a>Footer</h3><div style="text-align:center"><br><img src="http://7pulhb.com2.z0.glb.clouddn.com/Flux-TodoFooter.png" width="500"><br></div>

<p>这是一个底部组件，它将显示未完成 todo 数，并能删除所有已完成 todo。首先他需要维护这些 <strong> 状态 </strong>:</p>
<ul>
<li><p>所有任务：</p>
<ul>
<li>通过遍历任务的完成情况，能获得未完成 todo 任务数</li>
<li>通过遍历任务的完成情况，统计已完成 todo 任务的信息</li>
<li>如果当前无任务，隐藏 Footer</li>
</ul>
</li>
</ul>
<p>因此，在初步的设计中，Footer 是一个 <strong> 有状态（Stateful）</strong> 的组件。后面我们会谈到该做法的不恰当。</p>
<p>并且，他具有如下行为：</p>
<ul>
<li>单击右侧按钮（Clear completed）: 清除所有已完成 todo 任务</li>
</ul>
<h3 id="MainSection"><a href="#MainSection" class="headerlink" title="MainSection"></a>MainSection</h3><div style="text-align:center"><br><img src="http://7pulhb.com2.z0.glb.clouddn.com/TodoMainSection.png" width="500"><br></div>

<p>该组件将会负责渲染所有的以创建任务，因而他需要维护的状态为：</p>
<ul>
<li>所有任务</li>
</ul>
<p>其具有的行为：</p>
<ul>
<li>点击顶部左侧图标按钮：完成 / 取消完成所有任务，具体根据 <strong> 所有任务 </strong> 是否都完成了决定</li>
</ul>
<p>因此， MainSection 也是一个有状态的组件。</p>
<h3 id="TodoItem"><a href="#TodoItem" class="headerlink" title="TodoItem"></a>TodoItem</h3><div style="text-align:center"><br><img src="http://7pulhb.com2.z0.glb.clouddn.com/TodoItem.png" width="500"><br></div>

<p>这是 todo 项目，每个项目来源于 MainSection 中的迭代，并且该组件具有如下行为：</p>
<ul>
<li>单击左侧按钮：完成 / 取消完成该任务</li>
<li>单击右侧按钮：删除该 todo</li>
<li>双击 todo 文本：进入下面的编辑模式</li>
</ul>
<div style="text-align:center"><br><img src="http://7pulhb.com2.z0.glb.clouddn.com/%E5%8F%8C%E5%87%BB%E8%BF%9B%E5%85%A5%E7%BC%96%E8%BE%91.png" width="500"><br></div>

<p>我们不难发现，“是否处于编辑模式” 实际上可作为该组件的一个状态，该状态的切换直接影响了该组件的展示和行为，所以，TodoItem 组件应当维护一个状态：</p>
<ul>
<li>是否编辑模式</li>
</ul>
<p>在编辑模式中，具有如下行为：</p>
<ul>
<li>输入框失焦或者按下回车键：更新任务</li>
</ul>
<p>可以看到，Header 组件及 TodoItem 组件的中的输入框具有一致的交互行为，所以，我们可以将该输入框提出来作为单独的组件，这也侧面体现了，一份完善的交互设计原型将预测到实现过程中的复用和抽象，避免了一些代码重构的时间。</p>
<h3 id="TodoTextInput"><a href="#TodoTextInput" class="headerlink" title="TodoTextInput"></a>TodoTextInput</h3><p>现在，我们抽象出一个可复用的输入组件 TodoTextInput 供 Header 和 TodoItem 使用，他需要维护如下状态：</p>
<ul>
<li>输入值</li>
</ul>
<p>他具有如下行为：</p>
<ul>
<li>输入框失焦或者按下回车键：调用存储过程（创建，更新等等）</li>
</ul>
<h3 id="组件结构"><a href="#组件结构" class="headerlink" title="组件结构"></a>组件结构</h3><div style="text-align:center"><br><img src="https://www.lucidchart.com/publicSegments/view/0f5014ca-ef30-4eac-8e6a-74a76dfc18d6/image.png" width="500"><br></div>

<h3 id="状态维护"><a href="#状态维护" class="headerlink" title="状态维护"></a>状态维护</h3><div style="text-align:center"><br><img src="https://www.lucidchart.com/publicSegments/view/1c6988eb-cb2c-4092-8f7f-2cbc11e07c9e/image.png" width="500"><br></div>

<p>我们发现在 MainSection 和 Footer 组件中都需要维护 <strong>allTodos</strong> 这一状态。由于 MainSection 与 Footer 属于平级的组件，所以，当 MainSection 中的 allTodos 这一状态发生改变时，为使 Footer 中的状态也发生改变，MainSection 中需要保存有 Footer 的引用才能更新到 Footer 的状态，同理，Footer 中也需要保存有 MainSection 的引用。这样，两个组件将会是强耦合的，如下图所示：</p>
<div style="text-align:center"><br><img src="https://www.lucidchart.com/publicSegments/view/210b9a7b-f8db-4642-bee0-62b8a62dbb33/image.png" width="500"><br></div>

<p>设想，如果以后还有更多的组件需要 allTodos 这一状态，这一设计模式将会是十分糟糕的，任何一个组件的脱离将可能导致整个引用网络的崩溃。</p>
<p>既然 allTodos 被多个组件共享，那么我们可以将该状态提升到更上一次的组件中，然后通过 <code>props</code> 传递给子组件。所以，在本例中，最终将 allTodos 提到了顶部容器 TodoApp 中进行维护，这样，通过 TodoApp 的 <code>setState()</code> 方法，所有绑定到 TodoApp 的组件都获得了状态更新，避免了组件间的相互引用，如下图所示：</p>
<div style="text-align:center"><br><img src="https://www.lucidchart.com/publicSegments/view/0140d060-b037-4ab8-9357-61029d6a14ef/image.png" width="500"><br></div>

<p>在 React 中，我们应当尽量创建多的无状态（Stateless）的组件，而把共享状态放到上层组件中，使上层组件成为一个有状态（Stateful）的组件。这样，有状态组件封装了交互行为以及与行为互动的状态，子组件通过 <code>props</code> 共享状态并进行数据渲染。更多 <code>state</code> 与 <code>props</code> 的关系和区别可以参看<a href="https://facebook.github.io/react/docs/interactivity-and-dynamic-uis-zh-CN.html" target="_blank" rel="external">官方文档</a></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><div style="text-align:center"><br><img src="http://7pulhb.com2.z0.glb.clouddn.com/Flux-%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" width="500"><br></div>

<p>其中 app.js 为应用的入口文件，从入口开始，逐步构造我们的 App。</p>
<h4 id="Dispatcher-1"><a href="#Dispatcher-1" class="headerlink" title="Dispatcher"></a>Dispatcher</h4><p><strong>js/AppDispatcher.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> Dispatcher = <span class="built_in">require</span>(<span class="string">'flux'</span>).Dispatcher;</div><div class="line"><span class="built_in">module</span>.exports = <span class="keyword">new</span> Dispatcher();</div></pre></td></tr></table></figure>
<p>可以看到，TodoMVC 中的 Dispatcher 实现来自于于官方的<a href="https://www.npmjs.com/package/flux" target="_blank" rel="external">实现</a>。我们可以看下 Flux 中的 Dispatcher 源码，首先看到 <code>Dispatcher()</code> 构造函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dispatcher</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    _classCallCheck(<span class="keyword">this</span>, Dispatcher);</div><div class="line"></div><div class="line">    <span class="keyword">this</span>._callbacks = &#123;&#125;; <span class="comment">// 保存向 Dispatcher 注册回调函数</span></div><div class="line">    <span class="keyword">this</span>._isDispatching = <span class="literal">false</span>; <span class="comment">// 是否正在分派 Action</span></div><div class="line">    <span class="keyword">this</span>._isHandled = &#123;&#125;; <span class="comment">// 已经完成执行的回调列表</span></div><div class="line">    <span class="keyword">this</span>._isPending = &#123;&#125;; <span class="comment">// 正在执行中的回调列表</span></div><div class="line">    <span class="keyword">this</span>._lastID = <span class="number">1</span>; <span class="comment">// 回调 Id 的起始标志</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再看注册方法 <code>register(callback)</code> , 每个向 Dispatcher 的注册的回调（callback）都拥有唯一 Id 进行标识：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 向 Dispatcher 注册回调函数, 每个回调函数都有唯一 id 进行标识</div><div class="line"> * @param callback</div><div class="line"> * @returns &#123;string&#125; 注册回调的 id</div><div class="line"> */</div><div class="line"></div><div class="line">Dispatcher.prototype.register = <span class="function"><span class="keyword">function</span> <span class="title">register</span>(<span class="params">callback</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> id = _prefix + <span class="keyword">this</span>._lastID++;</div><div class="line">    <span class="keyword">this</span>._callbacks[id] = callback;</div><div class="line">    <span class="keyword">return</span> id;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 根据 id 删除回调</div><div class="line"> */</div><div class="line"></div><div class="line">Dispatcher.prototype.unregister = <span class="function"><span class="keyword">function</span> <span class="title">unregister</span>(<span class="params">id</span>) </span>&#123;</div><div class="line">    !<span class="keyword">this</span>._callbacks[id] ? process.env.NODE_ENV !== <span class="string">'production'</span> ? invariant(<span class="literal">false</span>, <span class="string">'Dispatcher.unregister(...): `%s` does not map to a registered callback.'</span>, id) : invariant(<span class="literal">false</span>) : <span class="literal">undefined</span>;</div><div class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>._callbacks[id];</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>执行一个注册了的回调函数将经历如下过程：</p>
<ol>
<li>标识当前正在执行的回调为进行中（Pending）状态</li>
<li>将当前待处理的用户行为（payload）送至回调执行</li>
<li>执行完成，标识该回调已经完成（Handled）</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 执行回调函数, 该过程为:</div><div class="line"> * 1. 标识当前正在执行的回调为 Pending 状态</div><div class="line"> * 2. 将 payload 送入回调执行</div><div class="line"> * 3. 执行完成, 标识该回调已经完成</div><div class="line"> * @internal</div><div class="line"> */</div><div class="line"></div><div class="line">Dispatcher.prototype._invokeCallback = <span class="function"><span class="keyword">function</span> <span class="title">_invokeCallback</span>(<span class="params">id</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>._isPending[id] = <span class="literal">true</span>;</div><div class="line">    <span class="keyword">this</span>._callbacks[id](<span class="keyword">this</span>._pendingPayload);</div><div class="line">    <span class="keyword">this</span>._isHandled[id] = <span class="literal">true</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>派发 <code>dispatch(payload)</code> 指定的用户行为 <code>payload</code> 到所有的 callback 将经历如下过程：</p>
<p>首先，需要明确的是能够进行派发的前提是当前 Dispatcher 为空闲状态，接下来</p>
<ol>
<li>派发前的预处理 <code>startDispatching()</code><ul>
<li>初始化所有回调的状态</li>
<li>设置当前正在分发的 <code>payload</code><ul>
<li>标识当前的 Dispatcher 状态为 “正在进行派发”</li>
</ul>
</li>
</ul>
</li>
<li>根据注册顺序依次执行回调 <code>invokeCallback(id)</code></li>
<li>派发结束后的收尾工作 <code>stopDispatching()</code><ul>
<li>清除派发对象</li>
<li>标识当前的 Dispatcher 状态为 “结束派发”</li>
</ul>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 派发一个 payload 到所以已注册的 callback 中</div><div class="line"> */</div><div class="line"></div><div class="line">Dispatcher.prototype.dispatch = <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">payload</span>) </span>&#123;</div><div class="line">    !!<span class="keyword">this</span>._isDispatching ? process.env.NODE_ENV !== <span class="string">'production'</span> ? invariant(<span class="literal">false</span>, <span class="string">'Dispatch.dispatch(...): Cannot dispatch in the middle of a dispatch.'</span>) : invariant(<span class="literal">false</span>) : <span class="literal">undefined</span>;</div><div class="line">    <span class="keyword">this</span>._startDispatching(payload);</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> id <span class="keyword">in</span> <span class="keyword">this</span>._callbacks) &#123;</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>._isPending[id]) &#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">this</span>._invokeCallback(id);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">this</span>._stopDispatching();</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 分发 payload 前的初始化:</div><div class="line"> * 1. 初始化所有回调的状态</div><div class="line"> * 2. 设置当前正在分发的 payload</div><div class="line"> * 3. 标识当前 "正在进行派发"</div><div class="line"> * @internal</div><div class="line"> */</div><div class="line"></div><div class="line">Dispatcher.prototype._startDispatching = <span class="function"><span class="keyword">function</span> <span class="title">_startDispatching</span>(<span class="params">payload</span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> id <span class="keyword">in</span> <span class="keyword">this</span>._callbacks) &#123;</div><div class="line">        <span class="keyword">this</span>._isPending[id] = <span class="literal">false</span>;</div><div class="line">        <span class="keyword">this</span>._isHandled[id] = <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>._pendingPayload = payload;</div><div class="line">    <span class="keyword">this</span>._isDispatching = <span class="literal">true</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 结束派发时的收尾工作</div><div class="line"> * 1. 清除派发对象</div><div class="line"> * 2. 标识当前 "结束派发"</div><div class="line"> * @internal</div><div class="line"> */</div><div class="line"></div><div class="line">Dispatcher.prototype._stopDispatching = <span class="function"><span class="keyword">function</span> <span class="title">_stopDispatching</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>._pendingPayload;</div><div class="line">    <span class="keyword">this</span>._isDispatching = <span class="literal">false</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><strong>waitFor</strong></p>
<p>再看 Dispatcher 中一个很重要的方法: <code>waitFor(ids)</code>, 顾名思义，该方法的作用是：等待其他向 Dispatcher 注册了的回调执行完成。因而，该方法主要保证了 dispatch 时，待响应的回调函数的执行的 <strong> 顺序性 </strong>。</p>
<p>例如，在一个航班订票系统中，我们首先要选择完国家（Country），才能选择城市（City），所以，当一个类型为 “更新所选国家”的交互被送到 <code>CityStore</code> 所注册的回调时，为了保证能正确的选择更新后国家的城市，我们需要这样做：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">CityStore.dispatchToken = flightDispatcher.register(<span class="function"><span class="keyword">function</span>(<span class="params">payload</span>) </span>&#123;</div><div class="line">     <span class="keyword">if</span> (payload.actionType === <span class="string">'country-update'</span>) &#123;</div><div class="line">       <span class="comment">/*</span></div><div class="line">        * 如果不执行 waitFor(), 由于程序的异步性，那么可能 CityStore 的回调先于 ContryStore 的回调执行 </div><div class="line">        * 此时的国家尚未更新，得到的默认城市是错误的，而并不是最新的</div><div class="line">        * */</div><div class="line">       flightDispatcher.waitFor([CountryStore.dispatchToken]);</div><div class="line">       <span class="comment">// waitFor() 保证了 ContryStore 先响应了'country-update'，即保证了国家更新先于城市更新</span></div><div class="line"></div><div class="line">       <span class="comment">// 此时我们能正确的选择该国家的城市</span></div><div class="line">       CityStore.city = getDefaultCityForCountry(CountryStore.country);</div><div class="line">     &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>下面我们看 <code>waitFor()</code> 的源码实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 等待指定的回调完成</div><div class="line"> */</div><div class="line"></div><div class="line">Dispatcher.prototype.waitFor = <span class="function"><span class="keyword">function</span> <span class="title">waitFor</span>(<span class="params">ids</span>) </span>&#123;</div><div class="line">    !<span class="keyword">this</span>._isDispatching ? process.env.NODE_ENV !== <span class="string">'production'</span> ? invariant(<span class="literal">false</span>, <span class="string">'Dispatcher.waitFor(...): Must be invoked while dispatching.'</span>) : invariant(<span class="literal">false</span>) : <span class="literal">undefined</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> ii = <span class="number">0</span>; ii &lt; ids.length; ii++) &#123;</div><div class="line">        <span class="keyword">var</span> id = ids[ii];</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>._isPending[id]) &#123;</div><div class="line">            !<span class="keyword">this</span>._isHandled[id] ? process.env.NODE_ENV !== <span class="string">'production'</span> ? invariant(<span class="literal">false</span>, <span class="string">'Dispatcher.waitFor(...): Circular dependency detected while'</span> + <span class="string">'waiting for `%s`.'</span>, id) : invariant(<span class="literal">false</span>) : <span class="literal">undefined</span>;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        !<span class="keyword">this</span>._callbacks[id] ? process.env.NODE_ENV !== <span class="string">'production'</span> ? invariant(<span class="literal">false</span>, <span class="string">'Dispatcher.waitFor(...): `%s` does not map to a registered callback.'</span>, id) : invariant(<span class="literal">false</span>) : <span class="literal">undefined</span>;</div><div class="line">        <span class="keyword">this</span>._invokeCallback(id);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="Store-1"><a href="#Store-1" class="headerlink" title="Store"></a>Store</h4><p>在 <strong>js/stores/TodoStore.js</strong> 中：</p>
<p>首先，我们维护我们的数据对象，并提供若干对于该数据的操作：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 保存 TODO 列表</span></div><div class="line"><span class="keyword">var</span> _todos = &#123;&#125;;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * 创建一个 Todo</div><div class="line"> * @param text &#123;string&#125; Todo 内容</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">text</span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 更新一个 TODO item</div><div class="line"> * @param id &#123;string&#125;</div><div class="line"> * @param updates &#123;object&#125; 待更新对象的属性</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params">id, updates</span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 根据一个更新属性值对象更新所有 Todo</div><div class="line"> * @param updates &#123;object&#125;</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateAll</span>(<span class="params">updates</span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 删除 Todo</div><div class="line"> * @param id &#123;string&#125;</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">destroy</span>(<span class="params">id</span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 删除所有的已完成的 TODO items</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">destroyCompleted</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后导出一个全局单例，该单例提供了常用的外部访问接口，并且通过 node 提供的 <code>EventEmitter</code> 来实现事件的派发和监听：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> TodoStore = assign(&#123;&#125;, EventEmitter.prototype, &#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 是否所有 TODO 都已完成</div><div class="line">     * @return &#123;boolean&#125;</div><div class="line">     */</div><div class="line">    areAllComplete: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 获得所有的 TODO</div><div class="line">     * @returns &#123;object&#125;</div><div class="line">     */</div><div class="line">    getAll: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 发送变更事件</div><div class="line">     */</div><div class="line">    emitChange: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 添加变更事件监听</div><div class="line">     * @param callback</div><div class="line">     */</div><div class="line">    addChangeListener: <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</div><div class="line">        <span class="comment">// 一旦受到变更事件, 触发回调</span></div><div class="line">        <span class="comment">/*</span></div><div class="line">         *   例如, 当我们创建一条 todo 时,</div><div class="line">         *   TodoStore 将会发出一条变更事件,</div><div class="line">         *   上游的状态维护器将会调用 callback 进行状态更新</div><div class="line">         */</div><div class="line">        <span class="keyword">this</span>.on(CHANGE_EVENT, callback);</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 删除变更事件监听</div><div class="line">     * @param callback</div><div class="line">     */</div><div class="line">    removeChangeListener: <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.removeListener(CHANGE_EVENT, callback);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>最后，我们需要向 <code>AppDispatcher</code> 注册回调函数，以便在 <code>payload</code> 被分发到 TodoStore 时，TodoStore 能做出响应：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">AppDispatcher.register(<span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">action</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> text;</div><div class="line"></div><div class="line">    <span class="comment">// 根据不同的 action 类型(即不同的交互逻辑), 执行不同过程</span></div><div class="line">    <span class="keyword">switch</span> (action.actionType) &#123;</div><div class="line">        <span class="keyword">case</span> TodoConstants.TODO_CREATE:</div><div class="line">            text = action.text.trim();</div><div class="line">            <span class="keyword">if</span>( text!==<span class="string">''</span>) &#123;</div><div class="line">                create(text);</div><div class="line">                <span class="comment">// 一旦变更, 发出变更事件,</span></div><div class="line">                TodoStore.emitChange();</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="keyword">case</span> TodoConstants.TODO_TOGGLE_COMPLETE_ALL:</div><div class="line">            <span class="comment">// ...</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="keyword">case</span> TodoConstants.TODO_UNDO_COMPLETE:</div><div class="line">            <span class="comment">// ...</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="keyword">case</span> TodoConstants.TODO_COMPLETE:</div><div class="line">            <span class="comment">// ...</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="keyword">case</span> TodoConstants.TODO_UPDATE_TEXT:</div><div class="line">           <span class="comment">// ...</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="keyword">case</span> TodoConstants.TODO_DESTROY:</div><div class="line">            <span class="comment">// ...</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="keyword">case</span> TodoConstants.TODO_DESTROY_COMPLETED:</div><div class="line">            <span class="comment">// ...</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">        <span class="comment">// no op</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<blockquote>
<p>! 注意, 在回调执行过程中，如果发生状态的变动，需要抛出 change 事件，这样才能将组建的状态也更新（通过回调）。</p>
</blockquote>
<h4 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h4><p>我们将 TodoApp 中常见的 Action 都封装到了 <strong>js/TodoActions.js</strong> 中, 通过其中的 <code>AppDispatcher</code> 单例，我们可以将 Action 派发出去:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> TodoActions = &#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 创建行为 </div><div class="line">     * @param text &#123;string&#125;</div><div class="line">     */</div><div class="line">    create: <span class="function"><span class="keyword">function</span> (<span class="params">text</span>) </span>&#123;</div><div class="line">        <span class="comment">// 将创建行为送到 Dispatcher, Dispatcher 派发这个行为(action 对象) 到各个 Store</span></div><div class="line">        AppDispatcher.dispatch(&#123;</div><div class="line">            <span class="attr">actionType</span>: TodoConstants.TODO_CREATE,</div><div class="line">            <span class="attr">text</span>: text</div><div class="line">        &#125;);</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 更新行为</div><div class="line">     * @param id &#123;string&#125;</div><div class="line">     * @param text &#123;string&#125;</div><div class="line">     */</div><div class="line">    updateText: <span class="function"><span class="keyword">function</span> (<span class="params">id, text</span>) </span>&#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 全部设置为完成</div><div class="line">     * @param todo</div><div class="line">     */</div><div class="line">    toggleComplete: <span class="function"><span class="keyword">function</span> (<span class="params">todo</span>) </span>&#123;</div><div class="line">       <span class="comment">// ...</span></div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 标记所有的 Todo 为已完成</div><div class="line">     */</div><div class="line">    toggleCompleteAll: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="comment">// ...</span></div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     *</div><div class="line">     * @param id</div><div class="line">     */</div><div class="line">    destroy: <span class="function"><span class="keyword">function</span> (<span class="params">id</span>) </span>&#123;</div><div class="line">       <span class="comment">// ...</span></div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 删除所有已完成的 Todo</div><div class="line">     */</div><div class="line">    destroyCompleted: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="Components"><a href="#Components" class="headerlink" title="Components"></a>Components</h4><p>下面开始实现各个组件，个人偏向的流程是先在组件目录下创建好各个空白组件，之后再依序进行装填：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> React = <span class="built_in">require</span>(<span class="string">'react'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> Header = React.createClass(&#123;</div><div class="line"></div><div class="line">    <span class="attr">render</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="comment">// <span class="doctag">TODO:</span>:render</span></div><div class="line">    &#125;,</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = Header;</div></pre></td></tr></table></figure>
<p>装填顺序我会选择先装填顶部容器（此例中即为 TodoApp ），之后按照 DOM 树 <strong> 自底向上 </strong> 地进行装填:</p>
<p><strong>TodoApp.react.js</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> Footer = <span class="built_in">require</span>(<span class="string">'./Footer.react'</span>);</div><div class="line"><span class="keyword">var</span> Header = <span class="built_in">require</span>(<span class="string">'./Header.react'</span>);</div><div class="line"><span class="keyword">var</span> MainSection = <span class="built_in">require</span>(<span class="string">'./MainSection.react'</span>);</div><div class="line"><span class="keyword">var</span> React = <span class="built_in">require</span>(<span class="string">'react'</span>);</div><div class="line"><span class="keyword">var</span> TodoStore = <span class="built_in">require</span>(<span class="string">'../stores/TodoStore'</span>);</div><div class="line"></div><div class="line"><span class="comment">// 在根 DOM 下维护状态,</span></div><div class="line"><span class="comment">// 这样的状态往往是共享状态(会向下传递的状态)</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTodoState</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">allTodos</span>: TodoStore.getAll(),</div><div class="line">        <span class="attr">areAllComplete</span>: TodoStore.areAllComplete()</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> TodoApp = React.createClass(&#123;</div><div class="line">    <span class="attr">getInitialState</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> getTodoState();</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 绑定生命期 -- 挂载</div><div class="line">     */</div><div class="line">    componentDidMount: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">// 挂载时再为 TodoStore 添加监听器</span></div><div class="line">        TodoStore.addChangeListener(<span class="keyword">this</span>._onChange);</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="attr">componentWillUnmount</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        TodoStore.removeChangeListener(<span class="keyword">this</span>._onChange);</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="attr">render</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            &lt;div&gt;</div><div class="line">                &lt;Header /&gt;</div><div class="line">                &lt;MainSection</div><div class="line">                    allTodos=&#123;this.state.allTodos&#125;</div><div class="line">                    areAllComplete=&#123;this.state.areAllComplete&#125;</div><div class="line">                /&gt;</div><div class="line">                &lt;Footer allTodos=&#123;this.state.allTodos&#125;/&gt;</div><div class="line">            &lt;/div&gt;</div><div class="line">        );</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Event handler for 'change' events coming from the TodoStore</div><div class="line">     */</div><div class="line">    _onChange: function() &#123;</div><div class="line">        this.setState(getTodoState());</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">module.exports = TodoApp;</div></pre></td></tr></table></figure>
<blockquote>
<p>为了方便，TodoApp 不仅维护 allTodos 这个状态，还维护 areAllComplete，该状态主要服务于 MainSection 中的 “完成所有 / 取消完成所有任务” 这一用例，避免重复遍历 allTodos 的开销。</p>
</blockquote>
<p>我们可以看到，TodoApp 提供了一个 <code>onChange()</code> 方法作为 TodoStore 的 <code>change</code> 事件的回调，当 TodoStore 发出 change 事件时，TodoApp 将刷新状态，借此通知其下组件如 MainSection 等重新渲染。</p>
<p>更多组件的实现不再赘述。下面着重介绍 Flux 的工作流程</p>
<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>我们以 创建新的 Todo 这一工作流程为例展示 Flux 的工作过程。在 Flux 中，该流程如下图所示：</p>
<div style="text-align:center"><br><img src="https://www.lucidchart.com/publicSegments/view/49534565-8e62-4836-a6ca-e616269ba094/image.png" width="500"><br></div>

<p>（1） 我们在 TodoTextInput 中敲入数据，在输入框上，我们监听了 <strong> 失焦(onBlur)</strong> 和 <strong> 按下键盘按键(onKeyDown)</strong> 的事件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// js/components/TodoTextInput.react.js</span></div><div class="line"> <span class="comment">/**</span></div><div class="line">   * @return &#123;object&#125;</div><div class="line">   */</div><div class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) /*<span class="title">object</span>*/ </span>&#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;input</div><div class="line">        className=&#123;this.props.className&#125;</div><div class="line">        id=&#123;this.props.id&#125;</div><div class="line">        placeholder=&#123;this.props.placeholder&#125;</div><div class="line">        onBlur=&#123;this._save&#125;</div><div class="line">        onChange=&#123;this._onChange&#125;</div><div class="line">        onKeyDown=&#123;this._onKeyDown&#125;</div><div class="line">        value=&#123;this.state.value&#125;</div><div class="line">        autoFocus=&#123;true&#125;</div><div class="line">      /&gt;</div><div class="line">    );</div><div class="line">  &#125;,</div></pre></td></tr></table></figure>
<p>当事件发生时，调用 <code>save()</code> 方法进行处理：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">_save: function() &#123;</div><div class="line">    this.props.onSave(this.state.value);</div><div class="line">    this.setState(&#123;</div><div class="line">      value: &apos;&apos;</div><div class="line">    &#125;);</div><div class="line"> &#125;,</div></pre></td></tr></table></figure>
<p>（2） 在 Header 组件中，我们通过为 TodoTextInput 指定 <code>onSave</code> 属性（props）来确定当输入域发生变化后的执行逻辑，使得我们在 TodoTextInput 的状态发生改变时，能够发出一个 “创建行为” 到 Dispatcher：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// js/components/Header.react.js</span></div><div class="line"><span class="comment">/**</span></div><div class="line">   * @return &#123;object&#125;</div><div class="line">   */</div><div class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;header id="header"&gt;</div><div class="line">        &lt;h1&gt;todos&lt;/h1&gt;</div><div class="line">        &lt;TodoTextInput</div><div class="line">          id="new-todo"</div><div class="line">          placeholder="What needs to be done?"</div><div class="line">          onSave=&#123;this._onSave&#125;</div><div class="line">        /&gt;</div><div class="line">      &lt;/header&gt;</div><div class="line">    );</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  /**</div><div class="line">   * Event handler called within TodoTextInput.</div><div class="line">   * Defining this here allows TodoTextInput to be used in multiple places</div><div class="line">   * in different ways.</div><div class="line">   * @param &#123;string&#125; text</div><div class="line">   */</div><div class="line">  _onSave: function(text) &#123;</div><div class="line">    if (text.trim())&#123;</div><div class="line">      TodoActions.create(text);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>我们之所以不在 TodoTextInput 中写死 <code>TodoActions.create(text)</code> 主要是考虑到组件的可扩展性。“输入域变动后的存储逻辑”更应当被设计为一种配置，通过在不同场景下指定其 <code>onSave</code> 属性（prop），使得 TodoTextInput 更加通用。</p>
<p>（3） 在 <code>TodoActions.create()</code> 中，我们将 Action 送到 Dispatcher，并由其派发一个 “创建 Action”到<br>TodoStore：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// js/actions/TodoActions.js</span></div><div class="line"> <span class="comment">/**</span></div><div class="line">   * @param  &#123;string&#125; text</div><div class="line">   */</div><div class="line">  create: <span class="function"><span class="keyword">function</span>(<span class="params">text</span>) </span>&#123;</div><div class="line">    AppDispatcher.dispatch(&#123;</div><div class="line">      <span class="attr">actionType</span>: TodoConstants.TODO_CREATE,</div><div class="line">      <span class="attr">text</span>: text</div><div class="line">    &#125;);</div><div class="line">  &#125;,</div></pre></td></tr></table></figure>
<p>（4） TodoStore 在接收到 Dispatcher 派发来的 Action 之后，其向 Dispatcher 注册的回调被调用, 新的 todo 会被持久化，并因此引起了 TodoStore 维护的 todos 的改变，所以 TodoStore 会抛出一个 change 事件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// js/stores/TodoStore.js</span></div><div class="line">AppDispatcher.register(<span class="function"><span class="keyword">function</span>(<span class="params">action</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> text;</div><div class="line"></div><div class="line">  <span class="keyword">switch</span>(action.actionType) &#123;</div><div class="line">    <span class="keyword">case</span> TodoConstants.TODO_CREATE:</div><div class="line">      text = action.text.trim();</div><div class="line">      <span class="keyword">if</span> (text !== <span class="string">''</span>) &#123;</div><div class="line">        create(text);</div><div class="line">        TodoStore.emitChange();</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line"></div><div class="line">  <span class="comment">// ...  </span></div><div class="line"></div><div class="line">    <span class="keyword">default</span>:</div><div class="line">      <span class="comment">// no op</span></div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>（5）由于 TodoApp 向 TodoStore 订阅了 change 事件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// js/components/TodoApp.react.js</span></div><div class="line">componentDidMount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    TodoStore.addChangeListener(<span class="keyword">this</span>._onChange);</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<p>此时，change 事件发生，回调 <code>onChange()</code> 被触发, TodoApp 维护的状态得到更新：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">  * Event handler for 'change' events coming from the TodoStore</div><div class="line">  */</div><div class="line"> _onChange: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">   <span class="keyword">this</span>.setState(getTodoState());</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>（6） 由于 MainSection 及 Footer 组件中的属性（prop）绑定了 TodoApp 维护的状态，所以在 TodoApp 刷新状态 <code>setState()</code> 后，二者将会被重新渲染。</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/05/29/深入理解-throttle-与-debounce/">深入理解 throttle 与 debounce</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          May 29, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <p>我们先来看一个前端开发中遇到的场景：</p>
<blockquote>
<p>在页面中，我们有一个 “查询” 按钮，单击该按钮，会通过 <strong>ajax</strong> 异步查询一些数据</p>
</blockquote>
<p>假设这个查询是耗时的，并且会给后端造成一定压力，那么如果短时间内我们频繁点击该按钮，请求就会不断发出，这样给后端造成的压力是难以想象的。因此，我们会想到控制我们的查询速率。</p>
          <div class="read-more">
            <a href="/2016/05/29/深入理解-throttle-与-debounce/" class="read-more-link">Read more..</a>
          </div>
        
      
    </div>

    

    

  </article>

    
  </section>

  
  <nav class="pagination">
    
      <a class="prev" href="/page/2/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text">Prev</span>
      </a>
    
    
      <a class="next" href="/page/4/">
        <span class="next-text">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>


          </div>
          

        </div>  
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:softshot37@gmail.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
        
          <a href="https://github.com/yoyoyohamapi" class="iconfont icon-github" title="github"></a>
        
      
    
      
    
      
        
          <a href="https://www.zhihu.com/people/wu-xiao-jun-64-55/activities" class="iconfont icon-zhihu" title="zhihu"></a>
        
      
    
      
    
    
    
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>


<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://hexo.io/">Hexo</a>
  </span>
  
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2015 - 
    
    2017

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">吴晓军</span>
  </span>
</div>
      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  


    <script type="text/javascript" src="/js/src/even.js?v=2.4.x"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.4.x"></script>

    
  <!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</body>
</html>
