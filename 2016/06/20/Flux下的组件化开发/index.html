<!DOCTYPE html>
<html lang="">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="Flux 下的组件化开发"/>




  <meta name="keywords" content="JavaScript, React, Flux, 吴小蛆的巣" />










  <link rel="alternate" href="/atom.xml" title="吴小蛆的巣">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.9.0" />



<link rel="canonical" href="http://yoyoyohamapi.me/2016/06/20/Flux下的组件化开发/"/>



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />




  <link rel="stylesheet" type="text/css" href="/lib/nprogress/nprogress.min.css" />



<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.9.0" />



  



  <script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>








<script>
  window.config = {"title":"吴小蛆的巣","subtitle":null,"description":"只要努力，蛆虫也能变成苍蝇翱翔于天际","author":"吴晓军","language":null,"timezone":null,"url":"http://yoyoyohamapi.me","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":true,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":true,"line_number":false,"tab_replace":"  "},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"page","theme":"even","deploy":{"type":"git","repo":"https://github.com/yoyoyohamapi/yoyoyohamapi.github.io.git","branch":"master"},"ignore":[],"math":{"engine":"mathjax"},"sitemap":{"path":"sitemap.xml"},"category_generator":{"per_page":10},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"feed":{"type":"atom","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"atom.xml"},"index_generator":{"per_page":10},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"sanitize":false,"tables":true,"breaks":true,"smartLists":true,"smartypants":true},"server":{"log":false,"ip":"0.0.0.0"},"since":2015,"favicon":"/favicon.ico","rss":"default","menu":{"Home":"/","Archives":"/archives/","Tags":"/tags","Categories":"/categories"},"color":"Default","toc":true,"fancybox":true,"pjax":true,"copyright":{"enable":true,"origin":"http://yoyoyohamapi.me","license":"本文采用<a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc/4.0/\" target=\"_blank\">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可"},"reward":{"enable":true,"qrCode":{"wechat":null,"alipay":null}},"social":{"email":"softshot37@gmail.com","stack-overflow":null,"twitter":null,"facebook":null,"linkedin":null,"google":null,"github":"https://github.com/yoyoyohamapi","weibo":null,"zhihu":"https://www.zhihu.com/people/wu-xiao-jun-64-55/activities","pocket":null,"tumblr":null,"instagram":null},"leancloud":{"app_id":null,"app_key":null},"baidu_analytics":null,"baidu_verification":null,"google_analytics":null,"google_verification":null,"disqus_shortname":"yoyoyohamapi","version":"2.9.0"};
</script>

    <title> Flux 下的组件化开发 - 吴小蛆的巣 </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">吴小蛆的巣</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            首页
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            归档
          
        </li>
      </a>
    
      <a href="/tags">
        <li class="mobile-menu-item">
          
          
            标签
          
        </li>
      </a>
    
      <a href="/categories">
        <li class="mobile-menu-item">
          
          
            分类
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">吴小蛆的巣</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              首页
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              归档
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            
            
              标签
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/categories">
            
            
              分类
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          Flux 下的组件化开发
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2016-06-20
        </span>
        
          <div class="post-category">
            
              <a href="/categories/React/">React</a>
            
          </div>
        
        
      </div>
    </header>

    
    
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Flux-构成"><span class="toc-text">Flux 构成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Action"><span class="toc-text">Action</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dispatcher"><span class="toc-text">Dispatcher</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Store"><span class="toc-text">Store</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#View"><span class="toc-text">View</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Todo-栗子"><span class="toc-text">Todo 栗子</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TodoApp"><span class="toc-text">TodoApp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Header"><span class="toc-text">Header</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Footer"><span class="toc-text">Footer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MainSection"><span class="toc-text">MainSection</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TodoItem"><span class="toc-text">TodoItem</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TodoTextInput"><span class="toc-text">TodoTextInput</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#组件结构"><span class="toc-text">组件结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#状态维护"><span class="toc-text">状态维护</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实现"><span class="toc-text">实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#目录结构"><span class="toc-text">目录结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Dispatcher-1"><span class="toc-text">Dispatcher</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Store-1"><span class="toc-text">Store</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Actions"><span class="toc-text">Actions</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Components"><span class="toc-text">Components</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#工作流程"><span class="toc-text">工作流程</span></a></li></ol></li></ol>
    </div>
  </div>



    <div class="post-content">
      
        <h2 id="Flux-构成"><a href="#Flux-构成" class="headerlink" title="Flux 构成"></a>Flux 构成</h2><p>首先要明确的是，Flux 并不是一个前端框架，而是前端的一个设计模式，一个状态管理机制，其把前端的一个交互流程简单的模拟成了一个单向数据流。</p>
<div style="text-align:center"><br><img src="http://facebook.github.io/flux/img/flux-simple-f8-diagram-1300w.png" width="500"><br></div>

<p>在上图中，我们可以看到 Flux 的四个核心构成：</p>
<a id="more"></a>
<h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p>一个交互动作, 更多的时候代表一个时间，比如用户在页面组件上的点击（click），失焦（blur），双击（doubleclick）等等。一个 Action 往往由如下两个部分组成：</p>
<ul>
<li>交互类型（type）：例如创建、删除、更新等</li>
<li>交互体（payload）：或者说交互的携带信息，例如创建的文本</li>
</ul>
<h3 id="Dispatcher"><a href="#Dispatcher" class="headerlink" title="Dispatcher"></a>Dispatcher</h3><p>Action 分发器。从上图的数据流中，我们可以看到，用户每次产生的 Action 将被送入 Dispatcher，Dispatcher 对 Action 进行简单的包裹之后将其派发到 <strong> 所有 </strong> Store 中。</p>
<blockquote>
<p>注意！Dispatcher 的这种广播行为有别于 <strong>Pub/Sub</strong> 模型，在 Pub/Sub 模型中，需要声明订阅的消息类型，然后发布者会像订阅者广播特定类型的消息。而在 Dispatcher 中，Store 向其注册的任意回调接口都不要声明订阅的 Action 类型，即 Store 只告诉 Dispatcher “如果 Action 到来，请你把它发送给我”。当 Dispatcher 派发 Action 时，所有注册到 Dispatcher 的 callback 都会得到响应。回调可以通过简单的 switch-case 来针对不对类型的 Action 做出不同的响应。</p>
</blockquote>
<h2 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h2><p>数据仓库，保存了我们某个前端 App 的数据以及对数据的操作。Store 会向 Dispatcher 注册一个回调函数，该回调函数接受一个 Action 作为参数。当 Action 被派发到 Store 时，该回调函数被调用，借由 Action 中描述的 <strong> 交互类型（type）</strong>，Store 进行不同处理，这些处理都将被持久化到 Store 维护的数据对象上。</p>
<p>Store 完成数据的变更后，由于 Flux 并不是双向数据绑定的，因而即便我们已经持久化了 Store 中的数据，但组件的数据并未得到更新，组件也不会重新渲染。所以，每次数据变动后，为了告知组件去更新数据，Store 会 emit 一个 change 事件。当监听到 change 事件发生，注册到监听器上的回调去完成各个组件的状态更新。</p>
<h2 id="View"><a href="#View" class="headerlink" title="View"></a>View</h2><p>顾名思义，这就是用户所能看到的视图。有别于传统的 MVC，在 Flux 中，View 并不会和数据模型（Model）产生交互，其只会产生各种交互行为（Actions），这些行为将会被送到 Dispatcher 中，如下图所示：</p>
<div style="text-align:center"><br><img src="http://facebook.github.io/flux/img/flux-simple-f8-diagram-with-client-action-1300w.png" width="500"><br></div>

<p>当 View 中维护的状态变动时，View 需要被重新渲染。</p>
<h2 id="Todo-栗子"><a href="#Todo-栗子" class="headerlink" title="Todo 栗子"></a>Todo 栗子</h2><p>下面我们分析一个用 React+Flux 实现的一个 Flux 栗子，其源码托管在 <a href="https://github.com/facebook/flux/tree/master/examples/flux-todomvc" target="_blank" rel="noopener">github</a>上。</p>
<p>在项目实践中，面向组件化开发的最佳场景我认为是 <strong> 交互驱动型的开发 </strong>，该定义可能不够准确，其描述的是一旦一个完善的交互设计稿产生后，我们就可以从交互稿中 <strong> 分割 </strong> 出组件，并进行组件的状态 <strong> 分析 </strong>。假设我们得到了 Todo 的交互原型：</p>
<div style="text-align:center"><br><img src="http://7pulhb.com2.z0.glb.clouddn.com/Flux-Todo%E4%BA%A4%E4%BA%92%E5%8E%9F%E5%9E%8B.png" width="800"><br></div>

<blockquote>
<p>这是交互设计师的给我们的原稿，并且，原稿可能远不止这样一幅简单的图像，可能还包括更多的交互效果</p>
</blockquote>
<p>我们将会把这个应用拆分为如下组件：</p>
<h3 id="TodoApp"><a href="#TodoApp" class="headerlink" title="TodoApp"></a>TodoApp</h3><div style="text-align:center"><br><img src="http://7pulhb.com2.z0.glb.clouddn.com/Flux-TodoApp.png" width="500"><br></div>

<p>通常，在前端面向组件化的开发过程中，我们往往需要一个顶部容器包裹住我们的组件，一个页面可以存在若干个这样的顶部容器，这个容器类似一个集装箱或者盒子，封装了某个页面应用的所有组件和状态。例如，在某视频网站中，视频播放窗口可以作为一个顶部容器，其包裹了播放窗口，进度条，播放选项等各个组件，同时，评论部分也可以作为一个顶部容器，其包裹了评论列表，评论框等组件。</p>
<p>在 Todo 中，TodoApp 作为一个顶部容器，包裹了所有 Todo 应用需要的组件，这样，我们在应用入口只需要从 TodoApp 开始渲染，进而逐个渲染其子组件。但更为重要的是，TodoApp 将会封装其下各个组件需要用到的状态，通过数据流，各个组件将会收到状态，并且在状态改变时，重新开始渲染自己，最终更新页面内容。</p>
<h3 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h3><div style="text-align:center"><br><img src="http://7pulhb.com2.z0.glb.clouddn.com/Flux-TodoHeader.png" width="500"><br></div>

<p>这是一个头部组件，根据交互设计，他除了将保有静态的 “todos” 文字标题以外，还将会具有如下行为：</p>
<ul>
<li>右侧输入框失焦或者按下回车键：创建新的 todo 任务</li>
</ul>
<p>可以看到，由于 Header 不维护任何状态，所以 Header 是一个 <strong> 无状态（Stateless）</strong> 的组件</p>
<h3 id="Footer"><a href="#Footer" class="headerlink" title="Footer"></a>Footer</h3><div style="text-align:center"><br><img src="http://7pulhb.com2.z0.glb.clouddn.com/Flux-TodoFooter.png" width="500"><br></div>

<p>这是一个底部组件，它将显示未完成 todo 数，并能删除所有已完成 todo。首先他需要维护这些 <strong> 状态 </strong>:</p>
<ul>
<li><p>所有任务：</p>
<ul>
<li>通过遍历任务的完成情况，能获得未完成 todo 任务数</li>
<li>通过遍历任务的完成情况，统计已完成 todo 任务的信息</li>
<li>如果当前无任务，隐藏 Footer</li>
</ul>
</li>
</ul>
<p>因此，在初步的设计中，Footer 是一个 <strong> 有状态（Stateful）</strong> 的组件。后面我们会谈到该做法的不恰当。</p>
<p>并且，他具有如下行为：</p>
<ul>
<li>单击右侧按钮（Clear completed）: 清除所有已完成 todo 任务</li>
</ul>
<h3 id="MainSection"><a href="#MainSection" class="headerlink" title="MainSection"></a>MainSection</h3><div style="text-align:center"><br><img src="http://7pulhb.com2.z0.glb.clouddn.com/TodoMainSection.png" width="500"><br></div>

<p>该组件将会负责渲染所有的以创建任务，因而他需要维护的状态为：</p>
<ul>
<li>所有任务</li>
</ul>
<p>其具有的行为：</p>
<ul>
<li>点击顶部左侧图标按钮：完成 / 取消完成所有任务，具体根据 <strong> 所有任务 </strong> 是否都完成了决定</li>
</ul>
<p>因此， MainSection 也是一个有状态的组件。</p>
<h3 id="TodoItem"><a href="#TodoItem" class="headerlink" title="TodoItem"></a>TodoItem</h3><div style="text-align:center"><br><img src="http://7pulhb.com2.z0.glb.clouddn.com/TodoItem.png" width="500"><br></div>

<p>这是 todo 项目，每个项目来源于 MainSection 中的迭代，并且该组件具有如下行为：</p>
<ul>
<li>单击左侧按钮：完成 / 取消完成该任务</li>
<li>单击右侧按钮：删除该 todo</li>
<li>双击 todo 文本：进入下面的编辑模式</li>
</ul>
<div style="text-align:center"><br><img src="http://7pulhb.com2.z0.glb.clouddn.com/%E5%8F%8C%E5%87%BB%E8%BF%9B%E5%85%A5%E7%BC%96%E8%BE%91.png" width="500"><br></div>

<p>我们不难发现，“是否处于编辑模式” 实际上可作为该组件的一个状态，该状态的切换直接影响了该组件的展示和行为，所以，TodoItem 组件应当维护一个状态：</p>
<ul>
<li>是否编辑模式</li>
</ul>
<p>在编辑模式中，具有如下行为：</p>
<ul>
<li>输入框失焦或者按下回车键：更新任务</li>
</ul>
<p>可以看到，Header 组件及 TodoItem 组件的中的输入框具有一致的交互行为，所以，我们可以将该输入框提出来作为单独的组件，这也侧面体现了，一份完善的交互设计原型将预测到实现过程中的复用和抽象，避免了一些代码重构的时间。</p>
<h3 id="TodoTextInput"><a href="#TodoTextInput" class="headerlink" title="TodoTextInput"></a>TodoTextInput</h3><p>现在，我们抽象出一个可复用的输入组件 TodoTextInput 供 Header 和 TodoItem 使用，他需要维护如下状态：</p>
<ul>
<li>输入值</li>
</ul>
<p>他具有如下行为：</p>
<ul>
<li>输入框失焦或者按下回车键：调用存储过程（创建，更新等等）</li>
</ul>
<h3 id="组件结构"><a href="#组件结构" class="headerlink" title="组件结构"></a>组件结构</h3><div style="text-align:center"><br><img src="https://www.lucidchart.com/publicSegments/view/0f5014ca-ef30-4eac-8e6a-74a76dfc18d6/image.png" width="500"><br></div>

<h3 id="状态维护"><a href="#状态维护" class="headerlink" title="状态维护"></a>状态维护</h3><div style="text-align:center"><br><img src="https://www.lucidchart.com/publicSegments/view/1c6988eb-cb2c-4092-8f7f-2cbc11e07c9e/image.png" width="500"><br></div>

<p>我们发现在 MainSection 和 Footer 组件中都需要维护 <strong>allTodos</strong> 这一状态。由于 MainSection 与 Footer 属于平级的组件，所以，当 MainSection 中的 allTodos 这一状态发生改变时，为使 Footer 中的状态也发生改变，MainSection 中需要保存有 Footer 的引用才能更新到 Footer 的状态，同理，Footer 中也需要保存有 MainSection 的引用。这样，两个组件将会是强耦合的，如下图所示：</p>
<div style="text-align:center"><br><img src="https://www.lucidchart.com/publicSegments/view/210b9a7b-f8db-4642-bee0-62b8a62dbb33/image.png" width="500"><br></div>

<p>设想，如果以后还有更多的组件需要 allTodos 这一状态，这一设计模式将会是十分糟糕的，任何一个组件的脱离将可能导致整个引用网络的崩溃。</p>
<p>既然 allTodos 被多个组件共享，那么我们可以将该状态提升到更上一次的组件中，然后通过 <code>props</code> 传递给子组件。所以，在本例中，最终将 allTodos 提到了顶部容器 TodoApp 中进行维护，这样，通过 TodoApp 的 <code>setState()</code> 方法，所有绑定到 TodoApp 的组件都获得了状态更新，避免了组件间的相互引用，如下图所示：</p>
<div style="text-align:center"><br><img src="https://www.lucidchart.com/publicSegments/view/0140d060-b037-4ab8-9357-61029d6a14ef/image.png" width="500"><br></div>

<p>在 React 中，我们应当尽量创建多的无状态（Stateless）的组件，而把共享状态放到上层组件中，使上层组件成为一个有状态（Stateful）的组件。这样，有状态组件封装了交互行为以及与行为互动的状态，子组件通过 <code>props</code> 共享状态并进行数据渲染。更多 <code>state</code> 与 <code>props</code> 的关系和区别可以参看<a href="https://facebook.github.io/react/docs/interactivity-and-dynamic-uis-zh-CN.html" target="_blank" rel="noopener">官方文档</a></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><div style="text-align:center"><br><img src="http://7pulhb.com2.z0.glb.clouddn.com/Flux-%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" width="500"><br></div>

<p>其中 app.js 为应用的入口文件，从入口开始，逐步构造我们的 App。</p>
<h4 id="Dispatcher-1"><a href="#Dispatcher-1" class="headerlink" title="Dispatcher"></a>Dispatcher</h4><p><strong>js/AppDispatcher.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Dispatcher = <span class="built_in">require</span>(<span class="string">'flux'</span>).Dispatcher;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">new</span> Dispatcher();</span><br></pre></td></tr></table></figure>
<p>可以看到，TodoMVC 中的 Dispatcher 实现来自于于官方的<a href="https://www.npmjs.com/package/flux" target="_blank" rel="noopener">实现</a>。我们可以看下 Flux 中的 Dispatcher 源码，首先看到 <code>Dispatcher()</code> 构造函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dispatcher</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    _classCallCheck(<span class="keyword">this</span>, Dispatcher);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>._callbacks = &#123;&#125;; <span class="comment">// 保存向 Dispatcher 注册回调函数</span></span><br><span class="line">    <span class="keyword">this</span>._isDispatching = <span class="literal">false</span>; <span class="comment">// 是否正在分派 Action</span></span><br><span class="line">    <span class="keyword">this</span>._isHandled = &#123;&#125;; <span class="comment">// 已经完成执行的回调列表</span></span><br><span class="line">    <span class="keyword">this</span>._isPending = &#123;&#125;; <span class="comment">// 正在执行中的回调列表</span></span><br><span class="line">    <span class="keyword">this</span>._lastID = <span class="number">1</span>; <span class="comment">// 回调 Id 的起始标志</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再看注册方法 <code>register(callback)</code> , 每个向 Dispatcher 的注册的回调（callback）都拥有唯一 Id 进行标识：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向 Dispatcher 注册回调函数, 每个回调函数都有唯一 id 进行标识</span></span><br><span class="line"><span class="comment"> * @param callback</span></span><br><span class="line"><span class="comment"> * @returns &#123;string&#125; 注册回调的 id</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">Dispatcher.prototype.register = <span class="function"><span class="keyword">function</span> <span class="title">register</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> id = _prefix + <span class="keyword">this</span>._lastID++;</span><br><span class="line">    <span class="keyword">this</span>._callbacks[id] = callback;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据 id 删除回调</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">Dispatcher.prototype.unregister = <span class="function"><span class="keyword">function</span> <span class="title">unregister</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    !<span class="keyword">this</span>._callbacks[id] ? process.env.NODE_ENV !== <span class="string">'production'</span> ? invariant(<span class="literal">false</span>, <span class="string">'Dispatcher.unregister(...): `%s` does not map to a registered callback.'</span>, id) : invariant(<span class="literal">false</span>) : <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>._callbacks[id];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>执行一个注册了的回调函数将经历如下过程：</p>
<ol>
<li>标识当前正在执行的回调为进行中（Pending）状态</li>
<li>将当前待处理的用户行为（payload）送至回调执行</li>
<li>执行完成，标识该回调已经完成（Handled）</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行回调函数, 该过程为:</span></span><br><span class="line"><span class="comment"> * 1. 标识当前正在执行的回调为 Pending 状态</span></span><br><span class="line"><span class="comment"> * 2. 将 payload 送入回调执行</span></span><br><span class="line"><span class="comment"> * 3. 执行完成, 标识该回调已经完成</span></span><br><span class="line"><span class="comment"> * @internal</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">Dispatcher.prototype._invokeCallback = <span class="function"><span class="keyword">function</span> <span class="title">_invokeCallback</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>._isPending[id] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">this</span>._callbacks[id](<span class="keyword">this</span>._pendingPayload);</span><br><span class="line">    <span class="keyword">this</span>._isHandled[id] = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>派发 <code>dispatch(payload)</code> 指定的用户行为 <code>payload</code> 到所有的 callback 将经历如下过程：</p>
<p>首先，需要明确的是能够进行派发的前提是当前 Dispatcher 为空闲状态，接下来</p>
<ol>
<li>派发前的预处理 <code>startDispatching()</code><ul>
<li>初始化所有回调的状态</li>
<li>设置当前正在分发的 <code>payload</code><ul>
<li>标识当前的 Dispatcher 状态为 “正在进行派发”</li>
</ul>
</li>
</ul>
</li>
<li>根据注册顺序依次执行回调 <code>invokeCallback(id)</code></li>
<li>派发结束后的收尾工作 <code>stopDispatching()</code><ul>
<li>清除派发对象</li>
<li>标识当前的 Dispatcher 状态为 “结束派发”</li>
</ul>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 派发一个 payload 到所以已注册的 callback 中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">Dispatcher.prototype.dispatch = <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">payload</span>) </span>&#123;</span><br><span class="line">    !!<span class="keyword">this</span>._isDispatching ? process.env.NODE_ENV !== <span class="string">'production'</span> ? invariant(<span class="literal">false</span>, <span class="string">'Dispatch.dispatch(...): Cannot dispatch in the middle of a dispatch.'</span>) : invariant(<span class="literal">false</span>) : <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">this</span>._startDispatching(payload);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> id <span class="keyword">in</span> <span class="keyword">this</span>._callbacks) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>._isPending[id]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>._invokeCallback(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>._stopDispatching();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分发 payload 前的初始化:</span></span><br><span class="line"><span class="comment"> * 1. 初始化所有回调的状态</span></span><br><span class="line"><span class="comment"> * 2. 设置当前正在分发的 payload</span></span><br><span class="line"><span class="comment"> * 3. 标识当前 "正在进行派发"</span></span><br><span class="line"><span class="comment"> * @internal</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">Dispatcher.prototype._startDispatching = <span class="function"><span class="keyword">function</span> <span class="title">_startDispatching</span>(<span class="params">payload</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> id <span class="keyword">in</span> <span class="keyword">this</span>._callbacks) &#123;</span><br><span class="line">        <span class="keyword">this</span>._isPending[id] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">this</span>._isHandled[id] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>._pendingPayload = payload;</span><br><span class="line">    <span class="keyword">this</span>._isDispatching = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 结束派发时的收尾工作</span></span><br><span class="line"><span class="comment"> * 1. 清除派发对象</span></span><br><span class="line"><span class="comment"> * 2. 标识当前 "结束派发"</span></span><br><span class="line"><span class="comment"> * @internal</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">Dispatcher.prototype._stopDispatching = <span class="function"><span class="keyword">function</span> <span class="title">_stopDispatching</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>._pendingPayload;</span><br><span class="line">    <span class="keyword">this</span>._isDispatching = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>waitFor</strong></p>
<p>再看 Dispatcher 中一个很重要的方法: <code>waitFor(ids)</code>, 顾名思义，该方法的作用是：等待其他向 Dispatcher 注册了的回调执行完成。因而，该方法主要保证了 dispatch 时，待响应的回调函数的执行的 <strong> 顺序性 </strong>。</p>
<p>例如，在一个航班订票系统中，我们首先要选择完国家（Country），才能选择城市（City），所以，当一个类型为 “更新所选国家”的交互被送到 <code>CityStore</code> 所注册的回调时，为了保证能正确的选择更新后国家的城市，我们需要这样做：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">CityStore.dispatchToken = flightDispatcher.register(<span class="function"><span class="keyword">function</span>(<span class="params">payload</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (payload.actionType === <span class="string">'country-update'</span>) &#123;</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 如果不执行 waitFor(), 由于程序的异步性，那么可能 CityStore 的回调先于 ContryStore 的回调执行 </span></span><br><span class="line"><span class="comment">        * 此时的国家尚未更新，得到的默认城市是错误的，而并不是最新的</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">       flightDispatcher.waitFor([CountryStore.dispatchToken]);</span><br><span class="line">       <span class="comment">// waitFor() 保证了 ContryStore 先响应了'country-update'，即保证了国家更新先于城市更新</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 此时我们能正确的选择该国家的城市</span></span><br><span class="line">       CityStore.city = getDefaultCityForCountry(CountryStore.country);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>下面我们看 <code>waitFor()</code> 的源码实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 等待指定的回调完成</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">Dispatcher.prototype.waitFor = <span class="function"><span class="keyword">function</span> <span class="title">waitFor</span>(<span class="params">ids</span>) </span>&#123;</span><br><span class="line">    !<span class="keyword">this</span>._isDispatching ? process.env.NODE_ENV !== <span class="string">'production'</span> ? invariant(<span class="literal">false</span>, <span class="string">'Dispatcher.waitFor(...): Must be invoked while dispatching.'</span>) : invariant(<span class="literal">false</span>) : <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> ii = <span class="number">0</span>; ii &lt; ids.length; ii++) &#123;</span><br><span class="line">        <span class="keyword">var</span> id = ids[ii];</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>._isPending[id]) &#123;</span><br><span class="line">            !<span class="keyword">this</span>._isHandled[id] ? process.env.NODE_ENV !== <span class="string">'production'</span> ? invariant(<span class="literal">false</span>, <span class="string">'Dispatcher.waitFor(...): Circular dependency detected while'</span> + <span class="string">'waiting for `%s`.'</span>, id) : invariant(<span class="literal">false</span>) : <span class="literal">undefined</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        !<span class="keyword">this</span>._callbacks[id] ? process.env.NODE_ENV !== <span class="string">'production'</span> ? invariant(<span class="literal">false</span>, <span class="string">'Dispatcher.waitFor(...): `%s` does not map to a registered callback.'</span>, id) : invariant(<span class="literal">false</span>) : <span class="literal">undefined</span>;</span><br><span class="line">        <span class="keyword">this</span>._invokeCallback(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="Store-1"><a href="#Store-1" class="headerlink" title="Store"></a>Store</h4><p>在 <strong>js/stores/TodoStore.js</strong> 中：</p>
<p>首先，我们维护我们的数据对象，并提供若干对于该数据的操作：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 保存 TODO 列表</span></span><br><span class="line"><span class="keyword">var</span> _todos = &#123;&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个 Todo</span></span><br><span class="line"><span class="comment"> * @param text &#123;string&#125; Todo 内容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 更新一个 TODO item</span></span><br><span class="line"><span class="comment"> * @param id &#123;string&#125;</span></span><br><span class="line"><span class="comment"> * @param updates &#123;object&#125; 待更新对象的属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params">id, updates</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据一个更新属性值对象更新所有 Todo</span></span><br><span class="line"><span class="comment"> * @param updates &#123;object&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateAll</span>(<span class="params">updates</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除 Todo</span></span><br><span class="line"><span class="comment"> * @param id &#123;string&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">destroy</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除所有的已完成的 TODO items</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">destroyCompleted</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后导出一个全局单例，该单例提供了常用的外部访问接口，并且通过 node 提供的 <code>EventEmitter</code> 来实现事件的派发和监听：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> TodoStore = assign(&#123;&#125;, EventEmitter.prototype, &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否所有 TODO 都已完成</span></span><br><span class="line"><span class="comment">     * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    areAllComplete: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得所有的 TODO</span></span><br><span class="line"><span class="comment">     * @returns &#123;object&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    getAll: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送变更事件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    emitChange: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加变更事件监听</span></span><br><span class="line"><span class="comment">     * @param callback</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    addChangeListener: <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 一旦受到变更事件, 触发回调</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         *   例如, 当我们创建一条 todo 时,</span></span><br><span class="line"><span class="comment">         *   TodoStore 将会发出一条变更事件,</span></span><br><span class="line"><span class="comment">         *   上游的状态维护器将会调用 callback 进行状态更新</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">this</span>.on(CHANGE_EVENT, callback);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除变更事件监听</span></span><br><span class="line"><span class="comment">     * @param callback</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    removeChangeListener: <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.removeListener(CHANGE_EVENT, callback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>最后，我们需要向 <code>AppDispatcher</code> 注册回调函数，以便在 <code>payload</code> 被分发到 TodoStore 时，TodoStore 能做出响应：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">AppDispatcher.register(<span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> text;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据不同的 action 类型(即不同的交互逻辑), 执行不同过程</span></span><br><span class="line">    <span class="keyword">switch</span> (action.actionType) &#123;</span><br><span class="line">        <span class="keyword">case</span> TodoConstants.TODO_CREATE:</span><br><span class="line">            text = action.text.trim();</span><br><span class="line">            <span class="keyword">if</span>( text!==<span class="string">''</span>) &#123;</span><br><span class="line">                create(text);</span><br><span class="line">                <span class="comment">// 一旦变更, 发出变更事件,</span></span><br><span class="line">                TodoStore.emitChange();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> TodoConstants.TODO_TOGGLE_COMPLETE_ALL:</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> TodoConstants.TODO_UNDO_COMPLETE:</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> TodoConstants.TODO_COMPLETE:</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> TodoConstants.TODO_UPDATE_TEXT:</span><br><span class="line">           <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> TodoConstants.TODO_DESTROY:</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> TodoConstants.TODO_DESTROY_COMPLETED:</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// no op</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>! 注意, 在回调执行过程中，如果发生状态的变动，需要抛出 change 事件，这样才能将组建的状态也更新（通过回调）。</p>
</blockquote>
<h4 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h4><p>我们将 TodoApp 中常见的 Action 都封装到了 <strong>js/TodoActions.js</strong> 中, 通过其中的 <code>AppDispatcher</code> 单例，我们可以将 Action 派发出去:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> TodoActions = &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建行为 </span></span><br><span class="line"><span class="comment">     * @param text &#123;string&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    create: <span class="function"><span class="keyword">function</span> (<span class="params">text</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 将创建行为送到 Dispatcher, Dispatcher 派发这个行为(action 对象) 到各个 Store</span></span><br><span class="line">        AppDispatcher.dispatch(&#123;</span><br><span class="line">            actionType: TodoConstants.TODO_CREATE,</span><br><span class="line">            text: text</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新行为</span></span><br><span class="line"><span class="comment">     * @param id &#123;string&#125;</span></span><br><span class="line"><span class="comment">     * @param text &#123;string&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    updateText: <span class="function"><span class="keyword">function</span> (<span class="params">id, text</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 全部设置为完成</span></span><br><span class="line"><span class="comment">     * @param todo</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    toggleComplete: <span class="function"><span class="keyword">function</span> (<span class="params">todo</span>) </span>&#123;</span><br><span class="line">       <span class="comment">// ...</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 标记所有的 Todo 为已完成</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    toggleCompleteAll: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    destroy: <span class="function"><span class="keyword">function</span> (<span class="params">id</span>) </span>&#123;</span><br><span class="line">       <span class="comment">// ...</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除所有已完成的 Todo</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    destroyCompleted: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="Components"><a href="#Components" class="headerlink" title="Components"></a>Components</h4><p>下面开始实现各个组件，个人偏向的流程是先在组件目录下创建好各个空白组件，之后再依序进行装填：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> React = <span class="built_in">require</span>(<span class="string">'react'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Header = React.createClass(&#123;</span><br><span class="line"></span><br><span class="line">    render: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span>:render</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Header;</span><br></pre></td></tr></table></figure>
<p>装填顺序我会选择先装填顶部容器（此例中即为 TodoApp ），之后按照 DOM 树 <strong> 自底向上 </strong> 地进行装填:</p>
<p><strong>TodoApp.react.js</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Footer = <span class="built_in">require</span>(<span class="string">'./Footer.react'</span>);</span><br><span class="line"><span class="keyword">var</span> Header = <span class="built_in">require</span>(<span class="string">'./Header.react'</span>);</span><br><span class="line"><span class="keyword">var</span> MainSection = <span class="built_in">require</span>(<span class="string">'./MainSection.react'</span>);</span><br><span class="line"><span class="keyword">var</span> React = <span class="built_in">require</span>(<span class="string">'react'</span>);</span><br><span class="line"><span class="keyword">var</span> TodoStore = <span class="built_in">require</span>(<span class="string">'../stores/TodoStore'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在根 DOM 下维护状态,</span></span><br><span class="line"><span class="comment">// 这样的状态往往是共享状态(会向下传递的状态)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTodoState</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        allTodos: TodoStore.getAll(),</span><br><span class="line">        areAllComplete: TodoStore.areAllComplete()</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> TodoApp = React.createClass(&#123;</span><br><span class="line">    getInitialState: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getTodoState();</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定生命期 -- 挂载</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    componentDidMount: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 挂载时再为 TodoStore 添加监听器</span></span><br><span class="line">        TodoStore.addChangeListener(<span class="keyword">this</span>._onChange);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    componentWillUnmount: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        TodoStore.removeChangeListener(<span class="keyword">this</span>._onChange);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    render: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;Header /&gt;</span><br><span class="line">                &lt;MainSection</span><br><span class="line">                    allTodos=&#123;<span class="keyword">this</span>.state.allTodos&#125;</span><br><span class="line">                    areAllComplete=&#123;<span class="keyword">this</span>.state.areAllComplete&#125;</span><br><span class="line">                /&gt;</span><br><span class="line">                &lt;Footer allTodos=&#123;<span class="keyword">this</span>.state.allTodos&#125;/&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    /</span>**</span><br><span class="line">     * Event handler <span class="keyword">for</span> <span class="string">'change'</span> events coming <span class="keyword">from</span> the TodoStore</span><br><span class="line">     *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">    _onChange: function() &#123;</span></span><br><span class="line"><span class="regexp">        this.setState(getTodoState());</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">module.exports = TodoApp;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>为了方便，TodoApp 不仅维护 allTodos 这个状态，还维护 areAllComplete，该状态主要服务于 MainSection 中的 “完成所有 / 取消完成所有任务” 这一用例，避免重复遍历 allTodos 的开销。</p>
</blockquote>
<p>我们可以看到，TodoApp 提供了一个 <code>onChange()</code> 方法作为 TodoStore 的 <code>change</code> 事件的回调，当 TodoStore 发出 change 事件时，TodoApp 将刷新状态，借此通知其下组件如 MainSection 等重新渲染。</p>
<p>更多组件的实现不再赘述。下面着重介绍 Flux 的工作流程</p>
<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>我们以 创建新的 Todo 这一工作流程为例展示 Flux 的工作过程。在 Flux 中，该流程如下图所示：</p>
<div style="text-align:center"><br><img src="https://www.lucidchart.com/publicSegments/view/49534565-8e62-4836-a6ca-e616269ba094/image.png" width="500"><br></div>

<p>（1） 我们在 TodoTextInput 中敲入数据，在输入框上，我们监听了 <strong> 失焦(onBlur)</strong> 和 <strong> 按下键盘按键(onKeyDown)</strong> 的事件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js/components/TodoTextInput.react.js</span></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @return &#123;object&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) /*<span class="title">object</span>*/ </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;input</span><br><span class="line">        className=&#123;<span class="keyword">this</span>.props.className&#125;</span><br><span class="line">        id=&#123;<span class="keyword">this</span>.props.id&#125;</span><br><span class="line">        placeholder=&#123;<span class="keyword">this</span>.props.placeholder&#125;</span><br><span class="line">        onBlur=&#123;<span class="keyword">this</span>._save&#125;</span><br><span class="line">        onChange=&#123;<span class="keyword">this</span>._onChange&#125;</span><br><span class="line">        onKeyDown=&#123;<span class="keyword">this</span>._onKeyDown&#125;</span><br><span class="line">        value=&#123;<span class="keyword">this</span>.state.value&#125;</span><br><span class="line">        autoFocus=&#123;<span class="literal">true</span>&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<p>当事件发生时，调用 <code>save()</code> 方法进行处理：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_save: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.props.onSave(<span class="keyword">this</span>.state.value);</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      value: <span class="string">''</span></span><br><span class="line">    &#125;);</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure>
<p>（2） 在 Header 组件中，我们通过为 TodoTextInput 指定 <code>onSave</code> 属性（props）来确定当输入域发生变化后的执行逻辑，使得我们在 TodoTextInput 的状态发生改变时，能够发出一个 “创建行为” 到 Dispatcher：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js/components/Header.react.js</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @return &#123;object&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;header id=<span class="string">"header"</span>&gt;</span><br><span class="line">        &lt;h1&gt;todos&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;TodoTextInput</span></span><br><span class="line"><span class="regexp">          id="new-todo"</span></span><br><span class="line"><span class="regexp">          placeholder="What needs to be done?"</span></span><br><span class="line"><span class="regexp">          onSave=&#123;this._onSave&#125;</span></span><br><span class="line"><span class="regexp">        /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/header&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  /</span>**</span><br><span class="line">   * Event handler called within TodoTextInput.</span><br><span class="line">   * Defining <span class="keyword">this</span> here allows TodoTextInput to be used <span class="keyword">in</span> multiple places</span><br><span class="line">   * <span class="keyword">in</span> different ways.</span><br><span class="line">   * @param &#123;string&#125; text</span><br><span class="line">   *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">  _onSave: function(text) &#123;</span></span><br><span class="line"><span class="regexp">    if (text.trim())&#123;</span></span><br><span class="line"><span class="regexp">      TodoActions.create(text);</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br></pre></td></tr></table></figure>
<p>我们之所以不在 TodoTextInput 中写死 <code>TodoActions.create(text)</code> 主要是考虑到组件的可扩展性。“输入域变动后的存储逻辑”更应当被设计为一种配置，通过在不同场景下指定其 <code>onSave</code> 属性（prop），使得 TodoTextInput 更加通用。</p>
<p>（3） 在 <code>TodoActions.create()</code> 中，我们将 Action 送到 Dispatcher，并由其派发一个 “创建 Action”到<br>TodoStore：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js/actions/TodoActions.js</span></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @param  &#123;string&#125; text</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  create: <span class="function"><span class="keyword">function</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">    AppDispatcher.dispatch(&#123;</span><br><span class="line">      actionType: TodoConstants.TODO_CREATE,</span><br><span class="line">      text: text</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<p>（4） TodoStore 在接收到 Dispatcher 派发来的 Action 之后，其向 Dispatcher 注册的回调被调用, 新的 todo 会被持久化，并因此引起了 TodoStore 维护的 todos 的改变，所以 TodoStore 会抛出一个 change 事件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js/stores/TodoStore.js</span></span><br><span class="line">AppDispatcher.register(<span class="function"><span class="keyword">function</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> text;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span>(action.actionType) &#123;</span><br><span class="line">    <span class="keyword">case</span> TodoConstants.TODO_CREATE:</span><br><span class="line">      text = action.text.trim();</span><br><span class="line">      <span class="keyword">if</span> (text !== <span class="string">''</span>) &#123;</span><br><span class="line">        create(text);</span><br><span class="line">        TodoStore.emitChange();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...  </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="comment">// no op</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>（5）由于 TodoApp 向 TodoStore 订阅了 change 事件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js/components/TodoApp.react.js</span></span><br><span class="line">componentDidMount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    TodoStore.addChangeListener(<span class="keyword">this</span>._onChange);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>此时，change 事件发生，回调 <code>onChange()</code> 被触发, TodoApp 维护的状态得到更新：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Event handler for 'change' events coming from the TodoStore</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> _onChange: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.setState(getTodoState());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>（6） 由于 MainSection 及 Footer 组件中的属性（prop）绑定了 TodoApp 维护的状态，所以在 TodoApp 刷新状态 <code>setState()</code> 后，二者将会被重新渲染。</p>

      
    </div>

    
      
      

  <div class="post-copyright">
    <p class="copyright-item">
      <span>原文作者: </span>
      <a href="http://yoyoyohamapi.me">吴晓军</a>
    </p>
    <p class="copyright-item">
      <span>原文链接: </span>
      <a href="http://yoyoyohamapi.me/2016/06/20/Flux下的组件化开发/">http://yoyoyohamapi.me/2016/06/20/Flux下的组件化开发/</a>
    </p>
    <p class="copyright-item">
      <span>许可协议: </span>
      
      本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可
    </p>
  </div>



      
      
  <div class="post-reward">
    <input type="checkbox" name="reward" id="reward" hidden />
    <label class="reward-button" for="reward">赞赏支持</label>
    <div class="qr-code">
      
      
      
    </div>
  </div>

    

    
      <footer class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/JavaScript/">JavaScript</a>
            
              <a href="/tags/React/">React</a>
            
              <a href="/tags/Flux/">Flux</a>
            
          </div>
        
        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2016/06/23/Redux-的中间件/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">Redux 中间件的实现</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/2016/05/29/深入理解-throttle-与-debounce/">
        <span class="next-text nav-default">深入理解 throttle 与 debounce</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

      </footer>
    

  </article>


          </div>
          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:softshot37@gmail.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
        
          <a href="https://github.com/yoyoyohamapi" class="iconfont icon-github" title="github"></a>
        
      
    
      
    
      
        
          <a href="https://www.zhihu.com/people/wu-xiao-jun-64-55/activities" class="iconfont icon-zhihu" title="zhihu"></a>
        
      
    
      
    
      
    
      
    
    
    
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>


<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2015 - 
    
    2019

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">吴晓军</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    
  
  <script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://yoyoyohamapi.me/2016/06/20/Flux下的组件化开发/';
        this.page.identifier = '2016/06/20/Flux下的组件化开发/';
        this.page.title = 'Flux 下的组件化开发';
    };
    (function() {
    var d = document, s = d.createElement('script');

    s.src = '//yoyoyohamapi.disqus.com/embed.js';

    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();  
  </script>

  

  



    
  



  
  





  
    <script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  

  
    <script type="text/javascript" src="/lib/pjax/jquery.pjax.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/nprogress/nprogress.min.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.9.0"></script>

  </body>
</html>
