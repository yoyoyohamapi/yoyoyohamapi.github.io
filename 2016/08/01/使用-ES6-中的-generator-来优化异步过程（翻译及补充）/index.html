<!DOCTYPE html>
<html lang="">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="使用 ES6 中的 generator 来优化异步过程"/>




  <meta name="keywords" content="JavaScript,ES6," />




  <link rel="alternate" href="/atom.xml" title="吴小蛆的巣">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.4.x" />



<link rel="canonical" href="http://yoyoyohamapi.me/2016/08/01/使用-ES6-中的-generator-来优化异步过程（翻译及补充）/"/>


<meta name="description" content="原文：Going Async With ES6 Generators本文在作者文章的基础上，适当补充了一些代码及说明  ES6 中的 generator 能够帮助我们提供一种类似同步一样的代码风格，来将异步过程的具体实现隐藏。这样的好处就是我们能够更加自然的表达自己的业务流程（work flow），而避免陷入异步的麻烦中。换言之，借助于 generator，我们既拥有了异步执行的能力，又不用再绞">
<meta name="keywords" content="JavaScript,ES6">
<meta property="og:type" content="article">
<meta property="og:title" content="使用 ES6 中的 generator 来优化异步过程">
<meta property="og:url" content="http://yoyoyohamapi.me/2016/08/01/使用-ES6-中的-generator-来优化异步过程（翻译及补充）/index.html">
<meta property="og:site_name" content="吴小蛆的巣">
<meta property="og:description" content="原文：Going Async With ES6 Generators本文在作者文章的基础上，适当补充了一些代码及说明  ES6 中的 generator 能够帮助我们提供一种类似同步一样的代码风格，来将异步过程的具体实现隐藏。这样的好处就是我们能够更加自然的表达自己的业务流程（work flow），而避免陷入异步的麻烦中。换言之，借助于 generator，我们既拥有了异步执行的能力，又不用再绞">
<meta property="og:updated_time" content="2017-04-30T03:44:14.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="使用 ES6 中的 generator 来优化异步过程">
<meta name="twitter:description" content="原文：Going Async With ES6 Generators本文在作者文章的基础上，适当补充了一些代码及说明  ES6 中的 generator 能够帮助我们提供一种类似同步一样的代码风格，来将异步过程的具体实现隐藏。这样的好处就是我们能够更加自然的表达自己的业务流程（work flow），而避免陷入异步的麻烦中。换言之，借助于 generator，我们既拥有了异步执行的能力，又不用再绞">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.4.x" />







<script>
  var CONFIG = {
    search: false,
    searchPath: "/search.xml",
    fancybox: false,
    toc: true,
  }
</script>




  



    <title> 使用 ES6 中的 generator 来优化异步过程 · 吴小蛆的巣 </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">吴小蛆的巣</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            Home
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            Archives
          
        </li>
      </a>
    
      <a href="/tags">
        <li class="mobile-menu-item">
          
          
            Tags
          
        </li>
      </a>
    
      <a href="/categories">
        <li class="mobile-menu-item">
          
          
            Categories
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">吴小蛆的巣</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              Home
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              Archives
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            
            
              Tags
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/categories">
            
            
              Categories
            
          </a>
        </li>
      
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          使用 ES6 中的 generator 来优化异步过程
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Aug 1, 2016
        </span>
      </div>
    </header>

    
    
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一个最简单的异步"><span class="toc-text">一个最简单的异步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#更好的异步流程控制"><span class="toc-text">更好的异步流程控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#generators-promise-下的错误处理"><span class="toc-text">generators+promise 下的错误处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#generators-promise-下的并行任务"><span class="toc-text">generators+promise 下的并行任务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ES7-中的-async"><span class="toc-text">ES7 中的 async</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li></ol>
    </div>
  </div>


    <div class="post-content">
      
        <blockquote>
<p>原文：<a href="https://davidwalsh.name/async-generators" target="_blank" rel="external">Going Async With ES6 Generators</a><br>本文在作者文章的基础上，适当补充了一些代码及说明</p>
</blockquote>
<p>ES6 中的 generator 能够帮助我们提供一种类似同步一样的代码风格，来将异步过程的具体实现隐藏。这样的好处就是我们能够更加自然的表达自己的业务流程（work flow），而避免陷入异步的麻烦中。换言之，借助于 generator，我们既拥有了异步执行的能力，又不用再绞尽脑汁的去维护异步代码。</p>
<p>继续阅读本文，你会发现这么做的结果简直太美妙了，以前那些糟糕的异步代码现在讲会想同步代码那样变得 <strong> 易于阅读 </strong> 和 <strong> 可维护 </strong>。需要知道的是，这个同步只是代码风格上的同步，他的执行过程仍然是异步的。</p>
<p>说了那么多，仍然有些抽象，现在我们由浅入深地看看到底怎么通过 ES6 来优化异步过程。</p>
<a id="more"></a>
<h2 id="一个最简单的异步"><a href="#一个最简单的异步" class="headerlink" title="一个最简单的异步"></a>一个最简单的异步</h2><p>假设我们的程序原来拥有这样的异步代码，这是最为朴实和原始的 JavaScript 异步流程控制：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeAjaxCall</span>(<span class="params">url,cb</span>) </span>&#123;</div><div class="line">    <span class="comment">// do some ajax fun</span></div><div class="line">    <span class="comment">// call `cb(result)` when complete</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">makeAjaxCall( <span class="string">"http://some.url.1"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">result1</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse( result1 );</div><div class="line"></div><div class="line">    makeAjaxCall( <span class="string">"http://some.url.2/?id="</span> + data.id, <span class="function"><span class="keyword">function</span>(<span class="params">result2</span>)</span>&#123;</div><div class="line">        <span class="keyword">var</span> resp = <span class="built_in">JSON</span>.parse( result2 );</div><div class="line">        <span class="built_in">console</span>.log( <span class="string">"The value you asked for:"</span> + resp.value );</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>可以看到，对于一次异步请求，我们获取异步结果的过程放到了回调当中。然而，借助 generator 来完成相同的任务：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 我们将真正的异步功能掩藏在 `request` 中，这样我们在 generator 中能专注同步写法</span></div><div class="line">    <span class="comment">// 通过 `it.next(..)` 来获得异步结果，并让 generator 的流程继续</span></div><div class="line">  makeAjaxCall(url, (result)=&gt;&#123;</div><div class="line">    it.next(result);</div><div class="line">  &#125;);</div><div class="line">  <span class="comment">// 注意，这里没有返回任何值，也就是说 `request()` 的执行结果会返回 `undefined`</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">main</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 在 generator 中，我们的异步处理流程摇身一变成了同步执行过程</span></div><div class="line">  <span class="keyword">const</span> result1 = <span class="keyword">yield</span> request(<span class="string">'http://some.url.1'</span>);</div><div class="line">  <span class="keyword">const</span> data =  <span class="built_in">JSON</span>.parse(result1);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> result2 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.2?id="</span> + data.id );</div><div class="line">    <span class="keyword">const</span> resp = <span class="built_in">JSON</span>.parse( result2 );</div><div class="line">    <span class="built_in">console</span>.log( <span class="string">"The value you asked for:"</span> + resp.value );</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// `main()` 方法执行后，generator 进入暂态，当 `makAjaxCall` 异步任务完成后，会让 `main()` 继续</span></div><div class="line">it = main();</div><div class="line">it.next();</div></pre></td></tr></table></figure>
<p>可以看到，generator 函数 <code>*main(..)</code> 自身非常纯净，我们在其中撰写业务流程就像我们在 PHP 或者 Java 等语言撰写业务流程，看不到任何的回调。</p>
<p>下面解释一下以上代码片是如何工作的：</p>
<p>helper 函数 <code>request(..)</code> 简单的包裹了异步任务 <code>makeAjaxCall(..)</code>，一旦 <code>makeAjaxCall(..)</code> 取得了结果，就调用 generator 迭代器的 <code>next(..)</code> 方法使 generator 继续运行。</p>
<p>当 <code>*main</code> 运行到 <code>yield ..</code> 后，他会被暂停在 <code>yield</code> 发生的位置，直到遇到了在 <code>makeAjaxCall(..)</code> 的回调中声明的 <code>it.next(..)</code> 才会继续执行。注意到，我们把 Ajax 请求到的结果 <code>result</code> 传递给了 <code>it.next(..)</code>，那么之后，<code>result</code> 就会被返回到的 <code>*main</code> 暂停了的位置，作为 <code>yield ..</code> 表达式的输出，所以，<code>result1</code> 不会是 <code>undefined</code>（默认情况下，<code>yield</code> 返回 <code>undefined</code>），而是拿到的异步结果。</p>
<p>这就是真正牛逼的地方。语句 <code>result1 = yield request(..)</code> 所表达的意图是要去请求一个值，但是，这个请求过程却被隐藏了。利用 <code>yield</code> 实现 <strong> 暂停 </strong> 功能，然后将 <strong> 继续 </strong> 功能放到 generator 函数以外地方，更准确地说，是放到了 generator 以外的异步回调中，从而保证了我们能够在 generator 中利用 <strong> 同步 </strong> 方式撰写业务流程。</p>
<blockquote>
<p><strong> 暂停 - 继续 </strong> 这样串行执行的过程模拟了 <strong> 同步 </strong> 的过程，使得这条语句在语法风格上实现了同步，但其内部实现又是异步的。</p>
</blockquote>
<p>别高兴的太早，上面的代码还存在一些问题。在上面的代码中，我们总是执行一个异步 Ajax 调用，但是，如果我们之后将 Ajax 的返回结果缓存到了内存来提升性能，这意味着我们下一次请求不再需要去服务端获得数据，而可以立即从内存上获取。为了满足这个需求，我们可能就会将代码改成如下形式:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> cache = &#123;&#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span>(cache[url]) &#123;</div><div class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</div><div class="line">      it.next(cacheUrl);</div><div class="line">    &#125;,<span class="number">0</span>);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    makeAjaxCall(url, (resp)=&gt;&#123;</div><div class="line">      it.next(resp);</div><div class="line">      cache[url] = resp;</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意：这里用到了 <code>setTimeout(..0)</code> 这个小技巧来强行进入异步过程，如果我们直接调用 <code>it.next(cacheUrl)</code>，就会出错，原因在于执行语句 <code>yield request(..)</code> 时，我们先执行 <code>request(..)</code>，之后 generator 函数才会暂停（后执行 <code>yield</code> ）。所以，如果我们直接调用 <code>it.next(cacheUrl)</code>，则流程如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">next()-&gt;request()-&gt;next()</div></pre></td></tr></table></figure>
<p>由于此时 generator 已经运行了，程序会抛出错误 <code>Generator is already running</code>。而通过 <code>setTimeout(..0)</code> 包裹后，我们的执行流程如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">next()-&gt;request()-&gt;yield-&gt;next()-&gt; 继续</div></pre></td></tr></table></figure>
<p>整个业务才能继续执行。</p>
<p>现在，我们的 generator 是这样的:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> result1 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.1"</span> );</div><div class="line"><span class="keyword">const</span> data = <span class="built_in">JSON</span>.parse( result1 );</div></pre></td></tr></table></figure>
<p>牛逼吧？尽管我们新添加了缓存的逻辑，但丝毫不影响我们的 generator 函数，仍旧是在专心的写业务。在 <code>*main()</code> 中，其过程仍然是非常清晰的业务流：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">请求值 --&gt; 暂停（等待请求完成）--&gt; 获得值 --&gt; 继续</div></pre></td></tr></table></figure>
<blockquote>
<p>在该场景下，暂停的持续时间变得很微妙，他可能很长（比如向服务器请求值），也可能很短（比如从内存缓存中请求值），但在我们的 <code>*main()</code> 中，还是只关注工作流（flow），无论异步过程的实现细节是否变得复杂。</p>
</blockquote>
<h2 id="更好的异步流程控制"><a href="#更好的异步流程控制" class="headerlink" title="更好的异步流程控制"></a>更好的异步流程控制</h2><p>上面的代码已经满足了一些简单的异步场景。但是很快，他的功能就会显得捉襟见肘，我们需要一个更加强大的异步机制来结合我们的 generator 去满足更大的业务场景。这个机制就是 <strong>Promises</strong>。</p>
<blockquote>
<p>对于 ES6 中 Promise 尚存疑惑的读者可以看下作者关于此的<a href="http://blog.getify.com/promises-part-1/" target="_blank" rel="external">博客</a>。</p>
</blockquote>
<p>首先，我们反思一下之前的设计缺陷：</p>
<ul>
<li>缺乏清晰的错误处理</li>
</ul>
<p>在 <a href="https://davidwalsh.name/es6-generators-dive#error-handling" target="_blank" rel="external">作者之前撰写的文章</a> 中，我们能够知道一些在 Ajax 调用过程中检测错误的手段：通过 <code>it.throw(..)</code> 将错误返回的 generator 中，而在 generator 中，我们又通过 <code>try..catch</code> 来俘获错误，进行错误处理:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>) </span>&#123;</div><div class="line">  makeAjaxCall(url, (err,result)=&gt;&#123;</div><div class="line">    <span class="keyword">if</span>(err) it.throw(err);</div><div class="line">    <span class="keyword">else</span> it.next(result);</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">main</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">const</span> result1 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.1"</span> );</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (err) &#123;</div><div class="line">        <span class="built_in">console</span>.log( <span class="string">"Error:"</span> + err );</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">const</span> data = <span class="built_in">JSON</span>.parse( result1 );</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">const</span> result2 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.2?id="</span> + data.id );</div><div class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</div><div class="line">        <span class="built_in">console</span>.log( <span class="string">"Error:"</span> + err );</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">const</span> resp = <span class="built_in">JSON</span>.parse( result2 );</div><div class="line">    <span class="built_in">console</span>.log( <span class="string">"The value you asked for:"</span> + resp.value );</div><div class="line">&#125; );</div></pre></td></tr></table></figure>
<p>这样做的坏处就是，我们把错误抛出耦合到了 Ajax 流程中，设想，我们有还有其他的 generator 也用到了 <code>request(..)</code>，我们的错误控制就会变成这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>) </span>&#123;</div><div class="line">    makeAjaxCall(url, (err,result)=&gt;&#123;</div><div class="line">        <span class="keyword">if</span>(err) &#123;</div><div class="line">            it1.throw(err);</div><div class="line">            it2.throw(err);</div><div class="line">            it3.throw(err);</div><div class="line">            <span class="comment">// ..</span></div><div class="line">            itn.throw(err);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这使得 <code>request(..)</code> 难以复用。</p>
<ul>
<li>如果 <code>makeAjaxCall(..)</code> 是一个并不受我们的控制的第三方库</li>
</ul>
<p>我们如果要在其中做诸如 <code>it.next(..)</code> 这样对 generator 的控制，就不得不修改这个库的实现，耗费人力不说，随意破坏第三方库也会使得代码难以移植。</p>
<ul>
<li>并行任务。</li>
</ul>
<p>由于 generator 中的 <code>yield</code> 是一个单步暂停点，同一时刻就只能跑一个任务。所以，我们渴望一个新的方式去执行并行任务，并且不需要太多的人工介入。</p>
<p>要解决上述的问题就需要我们探索新的设计模式了，结合这个新的设计模式，能让我们的基于 generator 的异步过程变得更加优雅。这个新的设计模式将会引入 <strong>Promise</strong>，其流程大致如下：</p>
<p><code>yield</code> 一个 Promise 对象后暂停，直至这些 Promise 对象被 <strong> 履行（fulfill）</strong> 的时候才继续我们的 generator。由于并行的 <code>Promise.all([..])</code> 也是一个 Promise 对象，所以在这种设计模式下，也能执行并行任务。</p>
<p>让我们对之前的 <code>request(..)</code> 函数加以修改，使之基于 Promise：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</div><div class="line">      <span class="comment">// 现在，`makeAjaxCall(..)` 不再耦合 `it.next(..)`</span></div><div class="line">        makeAjaxCall( url, (result)=&gt;resolve(result));</div><div class="line">    &#125; );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>request(..)</code> 构造了一个 Promise 对象并返回，该 Promise 对象将会在 Ajax 请求完成后被 resolved。现在，generator 中的 <code>yield</code> 最终也将产出这个 Promise 对象。我们还需要一个工具函数来控制我们的 generator 的迭代器，完成我们 generator 函数的自动执行。我们暂且将这个工具函数称之为 <code>runGenerator(..)</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// `runGenerator` 函数将运行一个 generator 函数 `g` 直至其完成</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">runGenerator</span>(<span class="params">g</span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> it = g(), ret;</div><div class="line">    <span class="comment">// 执行迭代过程的函数，首次立即执行的目的是为了启动 generator</span></div><div class="line">    (<span class="function"><span class="keyword">function</span> <span class="title">iterate</span>(<span class="params">val</span>)</span>&#123;</div><div class="line">        <span class="comment">// 获得最近迭代结果, 启动时 val 是 undefined</span></div><div class="line">        ret = it.next( val );</div><div class="line"></div><div class="line">    <span class="comment">// 如果 generator 没有执行完毕</span></div><div class="line">        <span class="keyword">if</span> (!ret.done) &#123;</div><div class="line">            <span class="comment">// 是否 `ret` 仍然是一个 Promise 对象，如果是，意味着 generator 还在不断 yield</span></div><div class="line">            <span class="keyword">if</span> (<span class="string">"then"</span> <span class="keyword">in</span> ret.value) &#123;</div><div class="line">                <span class="comment">// 将 `iterate(val)` 注册为该 Promise 的 `then(..)` 的回调，</span></div><div class="line">                <span class="comment">// 借此，获得一个 Promise 链</span></div><div class="line">                ret.value.then( iterate );</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 如果不是 Promise 对象，而是立即数, 将该结果返回</span></div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// avoid synchronous recursion</span></div><div class="line">                setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">                    iterate( ret.value ); <span class="comment">// 相当于 `it.next(立即数)`</span></div><div class="line">                &#125;, <span class="number">0</span> );</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;)();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以分析一下该工具函数的执行过程：</p>
<ol>
<li>我们首先初始化了传入的 generator 的迭代器 <code>it</code>，并且创建了一个迭代函数 <code>iterate</code>，该迭代函数用来 <strong> 继续 </strong> generator 的流程，从而让 generator 的自动执行至完毕。</li>
<li>每次我们执行 <code>iterator(val)</code>，就会调用 <code>it.next(val)</code>，并且获得结果 <code>ret</code>。假设我们 generator 中的执行语句是 <code>yield request( &quot;http://some.url.1&quot; )</code>，<code>request(..)</code> 会返回一个 Promise 对象，此时，<code>ret</code> 也就是该 Promise 对象，我们向其 <code>then(..)</code> 方法注册 <code>iterator</code>，使得该 Promise 对象完成后能够进入下一个 Promise 对象的流程，并且每次完成都会继续 generator。</li>
<li>当 <code>iterator(val)</code> 不停流转，直至 <code>val</code> 是一个立即数时，暗示 Promise 链执行完毕，获得了结果，将其返回到 generator 使 generator 得以继续执行。</li>
</ol>
<blockquote>
<p>简言之，结合了 Promise 的 generator 异步流程就是：每次 <code>yield</code> 一个 Promise 进入暂停态，在 Promise 完成后 generator 得以继续执行。</p>
</blockquote>
<p>下面我们看看怎么使用 <code>runGenerator</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">runGenerator( <span class="function"><span class="keyword">function</span> *<span class="title">main</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">const</span> result1 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.1"</span> );</div><div class="line">    <span class="keyword">const</span> data = <span class="built_in">JSON</span>.parse( result1 );</div><div class="line"></div><div class="line">    <span class="keyword">const</span> result2 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.2?id="</span> + data.id );</div><div class="line">    <span class="keyword">const</span> resp = <span class="built_in">JSON</span>.parse( result2 );</div><div class="line">    <span class="built_in">console</span>.log( <span class="string">"The value you asked for:"</span> + resp.value );</div><div class="line">&#125; );</div></pre></td></tr></table></figure>
<p>简直碉堡了，有没有！我们的业务逻辑仍然没什么变化！</p>
<p>设想，如果我们不做 <code>runGenerator</code> 函数，就需要手动控制 generator 的流程：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> it = main(); <span class="comment">// 获得 generator 的迭代器</span></div><div class="line"><span class="comment">// 不断用 `then(..)` 修饰 Promise</span></div><div class="line">it.next().value.then(<span class="function">(<span class="params">result1</span>)=&gt;</span>&#123;</div><div class="line">  it.next(result1).value.then(<span class="function">(<span class="params">result2</span>)=&gt;</span>&#123;</div><div class="line">    <span class="comment">// 最终的结果返回</span></div><div class="line">    it.next(result2);</div><div class="line">  &#125;)</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>如果业务流非常漫长，则撰写的嵌套是非常恐怖的。</p>
<p>现在，我们已经使用了 Promise 来管理基于 generator 的异步流程，它将我们从充满了诸如回调陷阱（callback hell）中解放了出来。通过 generators+promise 这个设计模式，我们阐述一下如何解决上面提到的三个问题：</p>
<ol>
<li>现在，我们拥有内置的错误处理。虽然这点没有在上面的 <code>runGenerator(..)</code> 进行揭示，但是，后文会讲到，在新的设计模式下，从 Promise 中监听所有的错误并不困难。最终通过将错误绑定到 <code>it.throw(..)</code>，我们就可以放心的在 generator 中使用 <code>try..catch</code> 语句来捕获和处理错误。</li>
<li>我们拥有了 Promise 提供的 <a href="https://blog.getify.com/promises-part-2/#uninversion" target="_blank" rel="external">control/trustability</a>。</li>
<li>Promise 已经做了大量抽象帮助我们方便的操纵多个 “并行的” 任务。</li>
</ol>
<p>例如，<code>yield Promise.all([..])</code> 将会利用传入的并行的任务数组（数组元素都是 Promise 对象），产出单一的 Promise 对象供 generator 操纵，generator 会等待所有的子 Promise 对象完成（无论完成顺序是怎样的）才继续进行。最后，我们真正返回给 generator 流程的是所有子 Promise 的响应构成的数组，数组元素的顺序会与请求顺序一致。</p>
<h2 id="generators-promise-下的错误处理"><a href="#generators-promise-下的错误处理" class="headerlink" title="generators+promise 下的错误处理"></a>generators+promise 下的错误处理</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</div><div class="line">        makeAjaxCall( url, (err,text)=&gt;&#123;</div><div class="line">            <span class="keyword">if</span> (err) reject( err );</div><div class="line">            <span class="keyword">else</span> resolve( text );</div><div class="line">        &#125; );</div><div class="line">    &#125; );</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">runGenerator</span>(<span class="params">g</span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> it = g(), ret;</div><div class="line">    <span class="comment">// 现在，传入了 `err` 作为第一个参数</span></div><div class="line">    (<span class="function"><span class="keyword">function</span> <span class="title">iterate</span>(<span class="params">err, val</span>)</span>&#123;</div><div class="line">        <span class="comment">// generator 迭代过程中遇到错误就 `throw`</span></div><div class="line">        <span class="keyword">if</span>(err) &#123;</div><div class="line">          setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</div><div class="line">            it.throw(err);</div><div class="line">          &#125;,<span class="number">0</span>);</div><div class="line">          <span class="keyword">return</span>;</div><div class="line">      &#125;</div><div class="line">        ret = it.next( val );</div><div class="line"></div><div class="line">    <span class="comment">// 如果 generator 没有执行完毕</span></div><div class="line">        <span class="keyword">if</span> (!ret.done) &#123;</div><div class="line">            <span class="comment">// 是否 `ret` 仍然是一个 Promise 对象，如果是，意味着 generator 还在不断 `yield`</span></div><div class="line">            <span class="keyword">if</span> (<span class="string">"then"</span> <span class="keyword">in</span> ret.value) &#123;</div><div class="line">                <span class="comment">// 将 `iterate(val)` 注册为该 Promise 的 `then(..)` 的回调，</span></div><div class="line">                <span class="comment">// 借此，获得一个 Promise 链</span></div><div class="line">                ret.value.then( iterate );</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 如果不是 Promise 对象，而是立即数，暗示 Promise 链已经获得最终结果，将该结果返回</span></div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// avoid synchronous recursion</span></div><div class="line">                setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">                    iterate( ret.value ); <span class="comment">// 相当于 it.next(立即数)</span></div><div class="line">                &#125;, <span class="number">0</span> );</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;)();</div><div class="line">&#125;</div><div class="line"></div><div class="line">runGenerator(<span class="function"><span class="keyword">function</span> *<span class="title">main</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">const</span> result1 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.1"</span> );</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (err) &#123;</div><div class="line">        <span class="built_in">console</span>.log( <span class="string">"Error:"</span> + err );</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">const</span> data = <span class="built_in">JSON</span>.parse( result1 );</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">const</span> result2 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.2?id="</span> + data.id );</div><div class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</div><div class="line">        <span class="built_in">console</span>.log( <span class="string">"Error:"</span> + err );</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">const</span> resp = <span class="built_in">JSON</span>.parse( result2 );</div><div class="line">    <span class="built_in">console</span>.log( <span class="string">"The value you asked for:"</span> + resp.value );</div><div class="line">&#125; );</div></pre></td></tr></table></figure>
<p>如果一个 Promise 的 reject 发生，那么该 reject 对应到的错误会映射到 generator 中的能够捕获的一个错误，这个映射过程是通过 <code>runGenerator(..)</code> 中声明的 <code>it.throw(..)</code> 来完成的。</p>
<h2 id="generators-promise-下的并行任务"><a href="#generators-promise-下的并行任务" class="headerlink" title="generators+promise 下的并行任务"></a>generators+promise 下的并行任务</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</div><div class="line">        makeAjaxCall( url, resolve );</div><div class="line">    &#125; )</div><div class="line">    <span class="comment">// 当获得返回的 `text`，可以做一些后置处理</span></div><div class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">text</span>)</span>&#123;</div><div class="line">        <span class="comment">// did we just get a (redirect) URL back?</span></div><div class="line">        <span class="keyword">if</span> (<span class="regexp">/^https?:\/\/.+/</span>.test( text )) &#123;</div><div class="line">            <span class="comment">// make another sub-request to the new URL</span></div><div class="line">            <span class="keyword">return</span> request( text );</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// otherwise, assume text is what we expected to get back</span></div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> text;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">runGenerator( <span class="function"><span class="keyword">function</span> *<span class="title">main</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">const</span> search_terms = <span class="keyword">yield</span> <span class="built_in">Promise</span>.all( [</div><div class="line">        request( <span class="string">"http://some.url.1"</span> ), <span class="comment">// 每个元素也是 promise 对象</span></div><div class="line">        request( <span class="string">"http://some.url.2"</span> ),</div><div class="line">        request( <span class="string">"http://some.url.3"</span> )</div><div class="line">    ] );</div><div class="line"></div><div class="line">    <span class="keyword">const</span> search_results = <span class="keyword">yield</span> request(</div><div class="line">        <span class="string">"http://some.url.4?search="</span> + search_terms.join( <span class="string">"+"</span> )</div><div class="line">    );</div><div class="line">    <span class="keyword">const</span> resp = <span class="built_in">JSON</span>.parse( search_results );</div><div class="line"></div><div class="line">    <span class="built_in">console</span>.log( <span class="string">"Search results:"</span> + resp.value );</div><div class="line">&#125; );</div></pre></td></tr></table></figure>
<p>在上面代码中，<code>Promise.all([ .. ])</code> 创建了一个 Promise 对象，该对象会等待三个子 Promise 对象完成。最终，返回的到 generator 的，恢复 generator 执行的，会是该 Promise 对象的执行结果。</p>
<h3 id="ES7-中的-async"><a href="#ES7-中的-async" class="headerlink" title="ES7 中的 async"></a>ES7 中的 <code>async</code></h3><p>尚未发布的 ES7 标准中提出了一个 <code>async</code> 函数，该函数就像我们上面撰写被 <code>runGenerator(..)</code> 所包裹的 generator。通过 <code>await</code> 关键字，你能够发出 Promise 对象，他会等待这些对象完成后才继续下去（我们甚至都不再需要借助迭代器了）。</p>
<p>aysnc 函数的大致使用过程如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> result1 = <span class="keyword">await</span> request( <span class="string">"http://some.url.1"</span> );</div><div class="line">    <span class="keyword">const</span> data = <span class="built_in">JSON</span>.parse( result1 );</div><div class="line"></div><div class="line">    <span class="keyword">const</span> result2 = <span class="keyword">await</span> request( <span class="string">"http://some.url.2?id="</span> + data.id );</div><div class="line">    <span class="keyword">const</span> resp = <span class="built_in">JSON</span>.parse( result2 );</div><div class="line">    <span class="built_in">console</span>.log( <span class="string">"The value you asked for:"</span> + resp.value );</div><div class="line">&#125;</div><div class="line"></div><div class="line">main();</div></pre></td></tr></table></figure>
<p>正如你所看到的那样，一个 <code>async function</code> 能够被直接调用，而不需要再包裹上 <code>runGenerator(..)</code>。其次，我们将用新的关键字 <code>await</code> 来替代 <code>yield</code> 告诉 <code>async function</code> 在继续前需要等待当前的 Promise 处理完成。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>generator+promise 的设计模式集成了强大而优雅的同步式的异步流程控制的优势。通过简单的 wrapper 函数，我们能够自动地运行我们的 generator 直至完成，包括清晰明了的同步式的错误控制。</p>
<p>而在 ES7 以上的版本，我们还能有 <code>async function</code> 来完成同样的任务。</p>

      
    </div>

    
      
      

  <div class="post-copyright">
    <p class="copyright-item">
      <span>作者: </span>
      <span>吴晓军</span>
    </p>
    <p class="copyright-item">
      <span>来源: </span>
      <a href="http://yoyoyohamapi.me">http://yoyoyohamapi.me</a>
    </p>
    <p class="copyright-item">
      <span>链接: </span>
      <a href="http://yoyoyohamapi.me/2016/08/01/使用-ES6-中的-generator-来优化异步过程（翻译及补充）/">http://yoyoyohamapi.me/2016/08/01/使用-ES6-中的-generator-来优化异步过程（翻译及补充）/</a>
    </p>

    <p class="copyright-item lincese">
      
      本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可
    </p>
  </div>



      
      
    

    
      <footer class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/JavaScript/">JavaScript</a>
            
              <a href="/tags/ES6/">ES6</a>
            
          </div>
        
        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2016/06/28/JavaScript-中的递归优化/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">JavaScript 中的递归优化</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    
    
      <a class="next" href="/2016/08/02/thunkify/">
        <span class="next-text nav-default">thunkify</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

      </footer>
    

  </article>


          </div>
          
  <div class="comments" id="comments">
    
  </div>


        </div>  
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:softshot37@gmail.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
        
          <a href="https://github.com/yoyoyohamapi" class="iconfont icon-github" title="github"></a>
        
      
    
      
    
      
        
          <a href="https://www.zhihu.com/people/wu-xiao-jun-64-55/activities" class="iconfont icon-zhihu" title="zhihu"></a>
        
      
    
      
    
    
    
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>


<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://hexo.io/">Hexo</a>
  </span>
  
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2015 - 
    
    2017

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">吴晓军</span>
  </span>
</div>
      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    
  

  
  




    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  


    <script type="text/javascript" src="/js/src/even.js?v=2.4.x"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.4.x"></script>

    
  </body>
</html>
