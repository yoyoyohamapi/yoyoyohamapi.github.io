<!DOCTYPE html>
<html lang="">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="深入理解 throttle 与 debounce"/>




  <meta name="keywords" content="函数式编程, 吴小蛆的巣" />










  <link rel="alternate" href="/atom.xml" title="吴小蛆的巣">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.9.0" />



<link rel="canonical" href="http://yoyoyohamapi.me/2016/05/29/深入理解-throttle-与-debounce/"/>



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />




  <link rel="stylesheet" type="text/css" href="/lib/nprogress/nprogress.min.css" />



<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.9.0" />



  



  <script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>








<script>
  window.config = {"title":"吴小蛆的巣","subtitle":null,"description":"只要努力，蛆虫也能变成苍蝇翱翔于天际","author":"吴晓军","language":null,"timezone":null,"url":"http://yoyoyohamapi.me","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":true,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":true,"line_number":false,"tab_replace":"  "},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"page","theme":"even","deploy":{"type":"git","repo":"https://github.com/yoyoyohamapi/yoyoyohamapi.github.io.git","branch":"master"},"ignore":[],"math":{"engine":"mathjax"},"sitemap":{"path":"sitemap.xml"},"category_generator":{"per_page":10},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"feed":{"type":"atom","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"atom.xml"},"index_generator":{"per_page":10},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"sanitize":false,"tables":true,"breaks":true,"smartLists":true,"smartypants":true},"server":{"log":false,"ip":"0.0.0.0"},"since":2015,"favicon":"/favicon.ico","rss":"default","menu":{"Home":"/","Archives":"/archives/","Tags":"/tags","Categories":"/categories"},"color":"Default","toc":true,"fancybox":true,"pjax":true,"copyright":{"enable":true,"origin":"http://yoyoyohamapi.me","license":"本文采用<a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc/4.0/\" target=\"_blank\">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可"},"reward":{"enable":true,"qrCode":{"wechat":null,"alipay":null}},"social":{"email":"softshot37@gmail.com","stack-overflow":null,"twitter":null,"facebook":null,"linkedin":null,"google":null,"github":"https://github.com/yoyoyohamapi","weibo":null,"zhihu":"https://www.zhihu.com/people/wu-xiao-jun-64-55/activities","pocket":null,"tumblr":null,"instagram":null},"leancloud":{"app_id":null,"app_key":null},"baidu_analytics":null,"baidu_verification":null,"google_analytics":null,"google_verification":null,"disqus_shortname":"yoyoyohamapi","version":"2.9.0"};
</script>

    <title> 深入理解 throttle 与 debounce - 吴小蛆的巣 </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">吴小蛆的巣</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            首页
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            归档
          
        </li>
      </a>
    
      <a href="/tags">
        <li class="mobile-menu-item">
          
          
            标签
          
        </li>
      </a>
    
      <a href="/categories">
        <li class="mobile-menu-item">
          
          
            分类
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">吴小蛆的巣</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              首页
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              归档
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            
            
              标签
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/categories">
            
            
              分类
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          深入理解 throttle 与 debounce
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2016-05-29
        </span>
        
          <div class="post-category">
            
              <a href="/categories/JavaScript-函数式编程/">JavaScript 函数式编程</a>
            
          </div>
        
        
      </div>
    </header>

    
    
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#独占型提交"><span class="toc-text">独占型提交</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#节制型提交"><span class="toc-text">节制型提交</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Underscore-中的-throttle"><span class="toc-text">Underscore 中的 throttle</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#leading-edge-与-trailing-edge"><span class="toc-text">leading edge 与 trailing edge</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#debounce"><span class="toc-text">debounce</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#应用场景"><span class="toc-text">应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#debounce-1"><span class="toc-text">debounce</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#throttle"><span class="toc-text">throttle</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考资料"><span class="toc-text">参考资料</span></a></li></ol>
    </div>
  </div>



    <div class="post-content">
      
        <p>我们先来看一个前端开发中遇到的场景：</p>
<blockquote>
<p>在页面中，我们有一个 “查询” 按钮，单击该按钮，会通过 <strong>ajax</strong> 异步查询一些数据</p>
</blockquote>
<p>假设这个查询是耗时的，并且会给后端造成一定压力，那么如果短时间内我们频繁点击该按钮，请求就会不断发出，这样给后端造成的压力是难以想象的。因此，我们会想到控制我们的查询速率。</p>
<a id="more"></a>
<h2 id="独占型提交"><a href="#独占型提交" class="headerlink" title="独占型提交"></a>独占型提交</h2><p>通过设置一个 <code>flag</code> 来标识当前状态为正在请求中，如果已在请求中，则不允许再次请求，请求完成，刷新该 <code>flag</code> 来允许新的请求提交：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isQuerying = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sendQuery = <span class="function"><span class="keyword">function</span>(<span class="params">complete</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果已经在查询了，那么需要等待 </span></span><br><span class="line">  <span class="keyword">if</span>(isQuerying)&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"waiting"</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"send query"</span>);</span><br><span class="line">  <span class="comment">// 标识当前正在查询中 </span></span><br><span class="line">  isQuerying = <span class="literal">true</span>;</span><br><span class="line">  <span class="comment">// 我们模拟一个耗时操作 </span></span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   complete &amp;&amp; complete();    </span><br><span class="line">  &#125;,<span class="number">2000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> complete = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 在回调中， 我们刷新标记量 </span></span><br><span class="line">   isQuerying = <span class="literal">false</span>;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"completed"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$(<span class="string">"#queryBtn"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;sendQuery(complete);&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试一下， 可以看到新的请求不再立即被送出 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++) &#123;</span><br><span class="line">  $(<span class="string">"#queryBtn"</span>).click();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="节制型提交"><a href="#节制型提交" class="headerlink" title="节制型提交"></a>节制型提交</h2><p>在独占型提交中，如果一个请求已经在进行中，那么再多的点击都会被废弃。如果我们只是想限制请求速率，而不想废弃掉之后的点击，那我们得考虑新的提交方式。回归到限制提交的问题本质：</p>
<blockquote>
<p>控制回调发生的速率, 不需要回调发生那么快</p>
</blockquote>
<p>但是，如果我们新建一个 wrapper 来包裹一下 <code>sendQuery</code> 业务：在 <code>click</code> 事件后，不会直接调用 <code>sendQuery</code>，而是调用 wrapper，在 wrapper 的执行过程中，我们有选择地考虑是否执行 <code>sendQuery</code>，借此控制住 <code>sendQuery</code> 的调用频率。</p>
<p>假设我们想至少等待 1s 才能发出一次新的查询请求，即请求的调用频次不能超过 <strong>1 次 / 秒 </strong>，可以这样设计：</p>
<ol>
<li>开始：<code>click</code> 事件到来， wrapper 被调用<br>.    获得当前时间，比较当前时间距上次 <code>sendQuery</code> 执行的时间是否已经足够 <code>1s</code> 。<br>.    如果已经足够，那么这次查询请求可以立即被执行，否则计算应该等待的时间，延后执行该请求。</li>
</ol>
<p>看代码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> previous = <span class="number">0</span>； <span class="comment">// 记录上次执行的时间点 </span></span><br><span class="line"><span class="keyword">var</span> waiting = <span class="number">1000</span>; <span class="comment">// 需要等待的时间 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sendQuery = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 执行的时候， 刷新 previous</span></span><br><span class="line">  previous = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"sending query"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获得当前时间 </span></span><br><span class="line">  <span class="keyword">var</span> now = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();</span><br><span class="line">  <span class="comment">// 获得需要等待的时间 </span></span><br><span class="line">  <span class="keyword">var</span> remain = waiting-(now-previous);</span><br><span class="line">  <span class="comment">// 判断是否立即执行 </span></span><br><span class="line">  <span class="keyword">if</span>(remain&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">    sendQuery();		</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    setTimeout(sendQuery, remain);</span><br><span class="line">  &#125;		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了防止变量的全局污染， 我们再用一个立即执行函数包裹下作用域：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> delayedQuery = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> previous = <span class="number">0</span>; <span class="comment">// 记录上次执行的时间点 </span></span><br><span class="line">  <span class="keyword">var</span> waiting = <span class="number">1000</span>; <span class="comment">// 需要等待的时间 </span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> sendQuery = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 执行的时候， 刷新 previous</span></span><br><span class="line">    previous = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"sending query"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获得当前时间 </span></span><br><span class="line">    <span class="keyword">var</span> now = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();</span><br><span class="line">    <span class="comment">// 获得需要等待的时间 </span></span><br><span class="line">    <span class="keyword">var</span> remain = waiting - (now - previous);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"need waiting"</span> + remain + <span class="string">"ms"</span>);</span><br><span class="line">    <span class="comment">// 判断是否立即执行 </span></span><br><span class="line">    <span class="keyword">if</span> (remain &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"immediately"</span>);</span><br><span class="line">      sendQuery();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"delayed"</span>);</span><br><span class="line">      setTimeout(sendQuery, remain);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">$(<span class="string">"#queryBtn"</span>).click(delayedQuery);</span><br></pre></td></tr></table></figure>
<p>但是，我们的业务代码 <code>sendQuery</code> 还是耦合了刷新 <code>previous</code> 的逻辑。其次，如果每个延迟执行的诉求都要去做这样一个包裹，样板代码就显得太多了。现在我们撰写一个通用函数，我们将（1）<strong> 需要控制调用频度的函数 </strong> 和（2）<strong> 对调用频度的限制平率 </strong> 告诉通用函数，它返回一个限制了执行频率的函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * throttle</span></span><br><span class="line"><span class="comment"> * @param &#123;Function&#125; func 待控制频率的函数 </span></span><br><span class="line"><span class="comment"> * @param &#123;Number&#125; waiting 每次调用的最小等待周期 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func,waiting</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> previous = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个 func 的 wrapper，如要是解耦 func 与 previous 等变量 </span></span><br><span class="line">  <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 刷新 previous</span></span><br><span class="line">    previous = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();</span><br><span class="line">    <span class="comment">// 执行调用 </span></span><br><span class="line">    func();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回一个被控制了调用频率的 </span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获得当前时间 </span></span><br><span class="line">      <span class="keyword">var</span> now = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();</span><br><span class="line">      <span class="comment">// 获得需要等待的时间 </span></span><br><span class="line">      <span class="keyword">var</span> remain = waiting - (now - previous);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"need waiting"</span> + remain + <span class="string">"ms"</span>);</span><br><span class="line">      <span class="comment">// 判断是否立即执行 </span></span><br><span class="line">      <span class="keyword">if</span> (remain &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"immediately"</span>);</span><br><span class="line">        later();</span><br><span class="line"> 	    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"delayed"</span>);</span><br><span class="line">        setTimeout(later, remain);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在，刷新 previous 不再需要耦合到 sendQuery 中 </span></span><br><span class="line"><span class="keyword">var</span> sendQuery = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"sending query"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">delayedQuery = throttle(sendQuery,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p><a href="https://jsfiddle.net/softshot/r6uh3xug/2/" target="_blank" rel="noopener">查看演示</a></p>
<h2 id="Underscore-中的-throttle"><a href="#Underscore-中的-throttle" class="headerlink" title="Underscore 中的 throttle"></a>Underscore 中的 throttle</h2><p>可以看出来， 这里我已经用了 <code>throttle</code> 来命名我们的函数了，<code>throttle</code>，也就是节流阀的意思，很形象是吧，通过这样一个阀门，我们限制函数的执行频次。</p>
<p>但是在上面的代码中，还有一点小问题，一些查询请求虽然被延迟执行了，但是在某个时间点，他们好像一起执行了，这是因为 <code>setTimeout(func, wait)</code> 并不能保证 <code>func</code> 的执行开始时间，只能保证 <code>func</code> 在不早于从现在起到 <code>wait</code> 毫秒后发生。所以被延后执行的那些查询在某个相近的时间点同时发生了。</p>
<p>出现这个错误的原因就是：</p>
<blockquote>
<p>我们只保障了 <strong> 第一次回调 </strong> 和 <strong> 接下来所有回调 </strong> 的间隔执行，而没有保障到各个回调间相互的间隔执行。</p>
</blockquote>
<p>下面可以看一下 Underscore 中 <code>throttle</code> 的实现，比刚才我们写的 throttle 函数健壮许多。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.throttle = <span class="function"><span class="keyword">function</span> (<span class="params">func, wait, options</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// timeout 标识最近一次被追踪的调用 </span></span><br><span class="line">    <span class="comment">// context 和 args 缓存 func 执行时需要的上下文，result 缓存 func 执行结果 </span></span><br><span class="line">    <span class="keyword">var</span> timeout, context, args, result;</span><br><span class="line">    <span class="comment">// 最近一次 func 被调用的时间点 </span></span><br><span class="line">    <span class="keyword">var</span> previous = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!options) options = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个延后执行的函数包裹住 func 的执行过程 </span></span><br><span class="line">    <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 执行时，刷新最近一次调用时间 </span></span><br><span class="line">        previous = options.leading === <span class="literal">false</span> ? <span class="number">0</span> : _.now();</span><br><span class="line">        <span class="comment">// 清空为此次执行设置的定时器 </span></span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">        result = func.apply(context, args);</span><br><span class="line">        <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个 throttle 化的函数 </span></span><br><span class="line">    <span class="keyword">var</span> throttled = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 我们尝试调用 func 时，会首先记录当前时间戳 </span></span><br><span class="line">        <span class="keyword">var</span> now = _.now();</span><br><span class="line">        <span class="comment">// 是否是第一次调用 </span></span><br><span class="line">        <span class="keyword">if</span> (!previous &amp;&amp; options.leading === <span class="literal">false</span>) previous = now;</span><br><span class="line">        <span class="comment">// func 还要等待多久才能被调用 = 预设的最小等待期 -（当前时间 - 上一次调用的时间）</span></span><br><span class="line">        <span class="keyword">var</span> remaining = wait - (now - previous);</span><br><span class="line">        <span class="comment">// 记录执行时需要的上下文和参数 </span></span><br><span class="line">        context = <span class="keyword">this</span>;</span><br><span class="line">        args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="comment">// 如果计算后能被立即执行 </span></span><br><span class="line">        <span class="keyword">if</span> (remaining &lt;= <span class="number">0</span> || remaining &gt; wait) &#123;</span><br><span class="line">            <span class="comment">// 清除之前的设置的延时执行，就不存在某些回调一同发生的情况了 </span></span><br><span class="line">            <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">                clearTimeout(timeout);</span><br><span class="line">                timeout = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 刷新最近一次 func 调用的时间点 </span></span><br><span class="line">            previous = now;</span><br><span class="line">            <span class="comment">// 执行 func 调用 </span></span><br><span class="line">            result = func.apply(context, args);</span><br><span class="line">            <span class="comment">// 再次检查 timeout，因为 func 执行期间可能有新的 timeout 被设置，如果 timeout 被清空了，代表不再有等待执行的 func，也清空 context 和 args</span></span><br><span class="line">            <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!timeout &amp;&amp; options.trailing !== <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果设置了 trailing edge，那么暂缓此次调用尝试的执行 </span></span><br><span class="line">            timeout = setTimeout(later, remaining);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不再控制函数执行调用频率 </span></span><br><span class="line">    throttled.cancel = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">        previous = <span class="number">0</span>;</span><br><span class="line">        timeout = context = args = <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> throttled;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>与我们所写的 <code>throttle</code> 不同的是，Underscore 中的 <code>throttle</code> 并不需要为每次回调都设置一个定时器来延后执行。他的定时器只记录最新一次的调用尝试。比如 <code>waiting</code> 为 <code>1s</code>，在 <code>1.5s</code> 内我们单击了查询按钮 <code>20</code> 次，真正会被送出的查询只有至多两次，分别是第一次和最后一次。这就不会出现上面延时中出现的 “某时刻一些延时函数同时发生” 的情况了。</p>
<p>在 Underscore 的 <code>throttle</code> 实现中，有个令人疑惑的判断条件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (remaining &lt;= <span class="number">0</span> || remaining &gt; wait) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当该条件成立时， 可以立即执行 <code>func</code>，<code>remaining&lt;=0</code> 的条件很容易理解，就是 <strong> 不再需要等待时 </strong> 可以执行，那么如何理解 <code>remaining &gt; wait</code> 呢?</p>
<p>显然，<code>remaining&gt;wait</code> 等同于 <code>now&lt;previous</code>， 亦即：<code>previous</code> 的被刷新晚于 <code>now</code> 的被设置。</p>
<p>这种情况就发生在我们当前尝试调用时，并且设置了当前时间点 <code>now</code> 之后，上次延时的函数 <code>later</code> 开始了执行， 并刷新了 <code>previous</code>，此时出现了 <code>now</code> 早于 <code>previous</code> 的情况。举个栗子：</p>
<ol>
<li>开始时，我们 <code>click</code> 了一次查询按钮，我们将之命名为 <code>click1</code>，此时 <code>previous==0</code><br>.    在 <code>0.4s</code> 时我们 <code>click</code> 了一次查询按钮 <code>click2</code>，<code>now==0.4</code>, <code>previous==0</code>, 则这次点击的查询会至少等待 <code>0.6s</code> 才送出，也就是最快要在 <code>1s</code> 的时候 <code>click2</code> 的查询请求才送出。（由于 <code>setTimeout(func, wait)</code> 并不能保证 <code>func</code> 的执行开始时间，只能保证 <code>func</code> 不早于从现在起到 <code>wait</code> 毫秒后发生， 所以 <code>click2</code> 的查询请求并不一定在 <code>1s</code> 时就能够被送出）<br>.    在 <code>1.2s</code> 时，产生 <code>click3</code>，<code>now==1.2</code></li>
</ol>
<p>那么就会存在如下两种情况：</p>
<ul>
<li><code>click2</code> 的查询先于 <code>click3</code> 发生，比如在 <code>1.1s</code> 时 <code>click2</code> 的回调被执行，那么 <code>click3</code> 的回调要等 <code>1-(1.2-1.1)==0.9s</code> 才发生<br>   <code>1.3s</code> 时 <code>click2</code> 的查询请求开始执行，<code>previous==1.3</code>，<code>remaining=1-(1.2-1.3)==1.1&gt;1</code>，此时，Underscore 会让 <code>click3</code> 的查询请求也开始执行（既不会停止 <code>click</code> 的查询请求，也不会停止 <code>click3</code> 的查询请求），<code>click3</code> 和 <code>click2</code> 的返回结果取最近一次。</li>
</ul>
<h3 id="leading-edge-与-trailing-edge"><a href="#leading-edge-与-trailing-edge" class="headerlink" title="leading edge 与 trailing edge"></a>leading edge 与 trailing edge</h3><p>underscore 中的 <code>throttle</code> 函数提供了第三个参数 <code>options</code> 来进行选项配置，并且支持如下两个参数：</p>
<ol>
<li><code>leading</code>：是否设置 <strong> 节流前缘 </strong> – <code>leading edge</code>。前缘的作用是保证第一次尝试调用的 <code>func</code> 会被立即执行，否则第一次调用也必须等待 <code>wait</code> 时间，默认为 <code>true</code>。<br>.    <code>trailing</code>：是否设置 <strong> 节流后缘 </strong> – <code>trailing edge</code>。后缘的作用是：当最近一次尝试调用 <code>func</code> 时，如果 <code>func</code> 不能立即执行，会延后 <code>func</code> 的执行，默认为 <code>true</code>。</li>
</ol>
<p>这两个配置会带来总共四种组合，通过 <a href="https://jsfiddle.net/softshot/Lakgk99q/9/" target="_blank" rel="noopener">这个演示</a>，观察不同组合的效果。</p>
<h2 id="debounce"><a href="#debounce" class="headerlink" title="debounce"></a>debounce</h2><p>在实际项目中，我们还有一种需求，就是如果过于频繁的尝试调用某个函数时，只允许一次调用成功执行。仍然以点击查询按钮异步查询为例，假设我们每次点击的时间间隔都在 <code>1s</code> 内，那么所有的点击只有一次能送出请求，要么是第一次，要么是最后一次。显然，<code>throttle</code> 是做不到这点的，<code>throttle</code> 会至少送出两次请求。针对于此，Underscore 又撰写了 <code>debounce</code> 函数。</p>
<p>顾名思义， <code>debounce</code> – 防反跳，就是不再跳起，不再响应的意思。</p>
<blockquote>
<p><code>throttle</code> 和 <code>debounce</code> 并非 Underscore 独有，他们不仅仅是函数，也是解决问题的方式，诸如 jquery，lodash 等知名库都提供了这两个方法。</p>
</blockquote>
<p>从下面的 <code>debounce</code> 实现我们可以看到，不同于 <code>throttle</code>，<code>debounce</code> 不再计算 <code>remain</code> 时间，其提供的 <code>immediate</code> 参数类似于 <code>throttle</code> 中的对于 <code>leading-edge</code> 和 <code>trailing-edge</code> 的控制：</p>
<ul>
<li><code>immediate === true</code>，开启 <code>leading-edge</code>，可以执行时立即执行<br>   <code>immediate === false</code>（默认）开启 <code>trailing-edge</code>，可以执行时也必须延后至少 <code>wait</code> 个时间才能执行。</li>
</ul>
<p>因此，<code>debounce</code> 后的 <code>func</code> 要么立即获得响应，要么延迟一段时间才响应，<a href="https://jsfiddle.net/softshot/gamLjgcn/" target="_blank" rel="noopener">查看演示</a>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.debounce = <span class="function"><span class="keyword">function</span> (<span class="params">func, wait, immediate</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> timeout, result;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span> (<span class="params">context, args</span>) </span>&#123;</span><br><span class="line">            timeout = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (args) result = func.apply(context, args);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> debounced = restArgs(<span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 每次新的尝试调用 func，会使抛弃之前等待的 func</span></span><br><span class="line">            <span class="keyword">if</span> (timeout) clearTimeout(timeout);</span><br><span class="line">            <span class="comment">// 如果允许新的调用尝试立即执行，</span></span><br><span class="line">            <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">                <span class="comment">// 如果之前尚没有调用尝试，那么此次调用可以立马执行，否则就需要等待 </span></span><br><span class="line">                <span class="keyword">var</span> callNow = !timeout;</span><br><span class="line">                <span class="comment">// 刷新 timeout</span></span><br><span class="line">                timeout = setTimeout(later, wait);</span><br><span class="line">                <span class="comment">// 如果能被立即执行，立即执行 </span></span><br><span class="line">                <span class="keyword">if</span> (callNow) result = func.apply(<span class="keyword">this</span>, args);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 否则，这次尝试调用会延时 wait 个时间 </span></span><br><span class="line">                timeout = _.delay(later, wait, <span class="keyword">this</span>, args);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        debounced.cancel = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            clearTimeout(timeout);</span><br><span class="line">            timeout = <span class="literal">null</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> debounced;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="debounce-1"><a href="#debounce-1" class="headerlink" title="debounce"></a>debounce</h3><p>一定要记住，<code>debounce</code> 满足的是：</p>
<blockquote>
<p>高频下只响应一次</p>
</blockquote>
<ol>
<li>遇上疯狂打字员，在输入框快速输入文字（高频），但是我们只想在其完全停止输入时再对输入文字做出处理（一次）。<br>.    AJAX，多数场景下，每个异步请求在短时间只能响应一次。比如下拉刷新，不停的到底（高频），但只发送一次 ajax 请求（一次）。</li>
</ol>
<h3 id="throttle"><a href="#throttle" class="headerlink" title="throttle"></a>throttle</h3><p>相比 <code>debounce</code>，<code>throttle</code> 要更加宽松一些，其目的在于:</p>
<blockquote>
<p>按频率执行调用。</p>
</blockquote>
<ol>
<li>游戏中的按键响应，比如格斗，比如射击，需要控制出拳和射击的速率。<br>.    自动完成，按照一定频率分析输入，提示自动完成。<br>.    鼠标移动和窗口滚动，鼠标稍微移动一下，窗口稍微滚动一下会带来大量的事件，因而需要控制回调的发生频率。</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://drupalmotion.com/article/debounce-and-throttle-visual-explanation" target="_blank" rel="noopener">Debounce and Throttle: a visual explanation</a><br>   <a href="https://www.zhihu.com/question/19805411" target="_blank" rel="noopener">知乎 @长天之云的回答</a><br>   <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setTimeout" target="_blank" rel="noopener">MDN setTimeout</a><br>   <a href="https://blog.coding.net/blog/the-difference-between-throttle-and-debounce-in-underscorejs" target="_blank" rel="noopener">浅谈 Underscore.js 中 <em>.throttle 和 </em>.debounce 的差异</a><br>   <a href="http://www.easyui.info/archives/1853.html" target="_blank" rel="noopener">Underscore 之 throttle 函数源码分析以及使用注意事项</a></li>
</ul>

      
    </div>

    
      
      

  <div class="post-copyright">
    <p class="copyright-item">
      <span>原文作者: </span>
      <a href="http://yoyoyohamapi.me">吴晓军</a>
    </p>
    <p class="copyright-item">
      <span>原文链接: </span>
      <a href="http://yoyoyohamapi.me/2016/05/29/深入理解-throttle-与-debounce/">http://yoyoyohamapi.me/2016/05/29/深入理解-throttle-与-debounce/</a>
    </p>
    <p class="copyright-item">
      <span>许可协议: </span>
      
      本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可
    </p>
  </div>



      
      
  <div class="post-reward">
    <input type="checkbox" name="reward" id="reward" hidden />
    <label class="reward-button" for="reward">赞赏支持</label>
    <div class="qr-code">
      
      
      
    </div>
  </div>

    

    
      <footer class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/函数式编程/">函数式编程</a>
            
          </div>
        
        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2016/06/20/Flux下的组件化开发/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">Flux 下的组件化开发</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/2016/03/18/闭包的一个经典实例和认识误区/">
        <span class="next-text nav-default">闭包的一个经典实例和认识误区</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

      </footer>
    

  </article>


          </div>
          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:softshot37@gmail.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
        
          <a href="https://github.com/yoyoyohamapi" class="iconfont icon-github" title="github"></a>
        
      
    
      
    
      
        
          <a href="https://www.zhihu.com/people/wu-xiao-jun-64-55/activities" class="iconfont icon-zhihu" title="zhihu"></a>
        
      
    
      
    
      
    
      
    
    
    
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>


<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2015 - 
    
    2019

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">吴晓军</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    
  
  <script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://yoyoyohamapi.me/2016/05/29/深入理解-throttle-与-debounce/';
        this.page.identifier = '2016/05/29/深入理解-throttle-与-debounce/';
        this.page.title = '深入理解 throttle 与 debounce';
    };
    (function() {
    var d = document, s = d.createElement('script');

    s.src = '//yoyoyohamapi.disqus.com/embed.js';

    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();  
  </script>

  

  



    
  



  
  





  
    <script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  

  
    <script type="text/javascript" src="/lib/pjax/jquery.pjax.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/nprogress/nprogress.min.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.9.0"></script>

  <!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</body>
</html>
