<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>吴小蛆的巣</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoyoyohamapi.me/"/>
  <updated>2018-10-14T10:01:00.488Z</updated>
  <id>http://yoyoyohamapi.me/</id>
  
  <author>
    <name>吴晓军</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>更好用的 Redux</title>
    <link href="http://yoyoyohamapi.me/2018/09/04/%E6%9B%B4%E5%A5%BD%E7%94%A8%E7%9A%84_Redux/"/>
    <id>http://yoyoyohamapi.me/2018/09/04/更好用的_Redux/</id>
    <published>2018-09-04T15:15:00.000Z</published>
    <updated>2018-10-14T10:01:00.488Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2018/09/04/更好用的_Redux/cover.png" alt="cover"></p><blockquote><p>本文是 《使用 RxJS + Redux 管理应用状态》系列第三篇文章，将介绍我们在使用 Redux 时的困惑，如何重新思考 Redux 定下的范式，以及我们能为此做出的努力。返回第一篇：<a href="http://yoyoyohamapi.me/2018/08/18/%E4%BD%BF%E7%94%A8_redux-observable_%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6%E8%87%AA%E6%B2%BB/">使用 redux-observable 实现组件自治</a></p><p>本系列的文章地址汇总：</p><ul><li><a href="http://yoyoyohamapi.me/2018/08/18/%E4%BD%BF%E7%94%A8_redux-observable_%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6%E8%87%AA%E6%B2%BB/">使用 redux-observable 实现组件自治</a></li><li><a href="http://yoyoyohamapi.me/2018/08/21/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA_redux-observable/">如何实现一个 redux-observable</a></li><li><a href="http://yoyoyohamapi.me/2018/09/04/%E6%9B%B4%E5%A5%BD%E7%94%A8%E7%9A%84_Redux/">更好用的 Redux</a></li></ul></blockquote><a id="more"></a><h2 id="为什么我们需要-Redux？"><a href="#为什么我们需要-Redux？" class="headerlink" title="为什么我们需要 Redux？"></a>为什么我们需要 Redux？</h2><p>首先要明确的是，Redux 并不是 React 独有的一个插件，它是顺应前端组件化开发潮流而诞生的一种状态管理模型，你在 Vue 或者 Angular 中也可以使用这个模型。</p><p>目前，大家都比较认可的是，某一时刻的应用或者组件状态，将对应此时应用或者组件的 UI：</p><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">UI = f(<span class="keyword">state</span>)</span><br></pre></td></tr></table></figure><p>那么，在前端组件化开发的时候，就需要思考两个问题：</p><ol><li><strong> 状态来源 </strong></li><li><strong> 状态管理 </strong></li></ol><p>组件所具有的状态，一搬来源于两个方面：</p><ol><li><strong> 自身具有的状态 </strong>：例如一个 Button 组件自身含有一个计数状态 count，表示自己被点击的次数。</li><li><strong> 外部注入的状态 </strong>：例如一个 Modal 组件，就需要由外部注入一个是否显示的状态 visible。React 将外部注入的状态称为 <strong>props</strong>。</li></ol><p>状态源为组件输送了其需要的状态，进而，组件的外观形态也得到了确认。在简单工程和简单组件中，我们思考了状态来源也就行了，如果引入额外的状态管理方案（例如我们为一个使用 Redux 管理一个按钮组件的状态），反而会加重每个组件的负担，造成了多余的抽象和依赖。</p><p>而对于 <strong> 大型前端工程 </strong> 和复杂组件来说，其往往具有如下特点：</p><ol><li><strong> 数据复杂 </strong></li><li><strong> 组件丰富 </strong></li></ol><p>在这种场景下，朴素的状态管理就显得捉襟见肘了，主要体现在下面几个方面：</p><ol><li>当组件 <strong> 层级过深 </strong> 时，如何优雅得呈递组件需要的状态，或者说组件如何更方便取得自己需要的状态</li><li>如何 <strong> 回溯 </strong> 到某个状态</li><li>如何更好的 <strong> 测试 </strong> 状态管理</li></ol><p>Redux 正是要去解决这些问题，从而让大型前端工程的状态更加可控。Redux 提出了一套约定模型，让状态的更新和派发都集中了：</p><p><img src="/2018/09/04/更好用的_Redux/redux.png" alt="redux"></p><p>Redux 所使用的模型是受到了 Elm 的启发：</p><p><img src="/2018/09/04/更好用的_Redux/elm.png" alt="Elm 架构"></p><p>在 Elm 中，流动于应用中的是 <strong> 消息（msg）</strong> ：一个由 <strong> 消息类型（type）</strong> 所标识，并且携带了 <strong> 内容（payload）</strong> 的数据结构。消息决定了数据模型（<strong>model</strong>）怎么更新，而数据又决定了 UI 形态。</p><p>而在 Redux 中，消息被称替代为 <strong> 动作（action）</strong>，并且使用 <strong>reducer</strong> 来描述状态随行为的变迁。另外，与 Elm 不同的是，Redux 专注于状态管理，而不再处理视图（View），因此 ，Redux 也不是分型的（关于分型架构的介绍，可以看 的 <a href="https://staltz.com/unidirectional-user-interface-architectures.html" target="_blank" rel="noopener">博文</a>）。</p><p>在了解到 Redux 的利好，或者被 Redux 的流行所吸引后，我们引入 Redux 作为应用的状态管理器，这让整个应用的状态变动都变得无比清晰，状态在一条链路上涌动，我们甚至可以回到或者前进到某个状态。然而，Redux 就真的完美无缺吗？</p><h2 id="不完美的-Redux"><a href="#不完美的-Redux" class="headerlink" title="不完美的 Redux"></a>不完美的 Redux</h2><p>Redux 当然不完美，它最困扰我们的就是下面两个方面：</p><ol><li>啰嗦的样板代码</li><li>低下的异步任务处理能力</li></ol><p>假定前端需要从服务端拉取一些数据并进行展示，在 Redux 的模式下，完成从数据拉取到状态更新，就需要经历：</p><p>（1）定义若干的 <strong>action type</strong>:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> FETCH_START = <span class="string">'FETCH_START'</span></span><br><span class="line"><span class="keyword">const</span> FETCH_SUCCESS = <span class="string">'FETCH_SUCCESSE'</span></span><br><span class="line"><span class="keyword">const</span> FETCH_ERROR = <span class="string">'FETCH_ERROR'</span></span><br></pre></td></tr></table></figure><p>（2）定义若干 <strong>action creator</strong>，这里假定我们使用 redux-thunk 驱动异步任务：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fetchSuccess = <span class="function"><span class="params">data</span> =&gt;</span> (&#123;</span><br><span class="line">  type: FETCH_START,</span><br><span class="line">  payload: &#123; data &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fetchError = <span class="function"><span class="params">error</span> =&gt;</span> (&#123;</span><br><span class="line">  type: FETCH_ERROR,</span><br><span class="line">  payload: &#123; error &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fetchData = <span class="function">(<span class="params">params</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">dispatch, getState</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> api.fetch(params)</span><br><span class="line">      .then(fetchSuccess)</span><br><span class="line">    .catch(fetchError)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）在 <strong>reducer</strong> 中，对不同 action type，通过 switch-case 声明不同的状态更新方式：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state = initialState, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; type, payload &#125; = action</span><br><span class="line">  <span class="keyword">switch</span>(action.type)&#123;</span><br><span class="line">    <span class="keyword">case</span> FETCH_START: &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, <span class="attr">loading</span>: <span class="literal">true</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> FETCH_SUCCESS: &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, <span class="attr">loading</span>: <span class="literal">false</span>, <span class="attr">data</span>: payload.data &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> FETCH_ERROR: &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, <span class="attr">loading</span>: <span class="literal">false</span>, <span class="attr">data</span>: <span class="literal">null</span>, <span class="attr">error</span>: payload.error&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个流程带来的问题是：</p><ol><li><strong> 个人开发不够专注 </strong>：工程中，我们是 <strong> 分散管理 </strong> action type、action 及 reducer 的，走完一套流程，需要在当中不停的跳跃，思路不够集中。</li><li><strong> 多人协作不够高效 </strong>：同样是因为 action type、action 及 reducer 的分散，多人协作时就会出现名字冲突，相似业务的流程重复等问题。这对我们的应用状态设计提出了比较高的要求。优秀的设计是状态易于定位，变迁流程清晰，无冗余状态，而低下的设计就会让状态膨胀难于定位，变迁流程错综复杂，冗余状态随处可见。</li></ol><h2 id="怎么用好-Redux"><a href="#怎么用好-Redux" class="headerlink" title="怎么用好 Redux"></a>怎么用好 Redux</h2><p>当我们受困于 Redux 的负面影响时，切到其他的状态管理方案（例如 <a href="https://github.com/mobxjs/mobx" target="_blank" rel="noopener">mobx</a> 或者 <a href="https://github.com/mobxjs/mobx-state-tree" target="_blank" rel="noopener">mobx-state-stree）</a>，也不太现实，一方面是迁移成本大，一方面你也不知道新的状态管理方案是否就是银弹。但是，对 Redux 的负面影响无动于衷或者忍气吞声，也只会让问题越滚越大，直到失控。</p><p>在开始讨论如何更好地 Redux 之前，我们需要明确一点，样板代码和异步能力的缺乏，<strong> 是 Redux 自身设计的结果，而非目的 </strong>，换句话说，Redux 设计出来，并不是要让开发者去撰写样本代码，或者去纠结怎么处理异步状态更新。</p><p>我们需要再定义一个角色，让他来代替我们去写样板代码，让他给予我们最优秀的异步任务处理能力，让他负责一切 Redux 中恶心的事儿。因此，这个角色就是一个让 Redux 变得更加优雅的框架，至于如何创建这个角色，需要我们从单个组件开始，重新梳理下应用形态，并着眼于：</p><ol><li>如何打掉 Redux 的样板代码</li><li>如何更优雅地处理异步任务</li></ol><h3 id="组件的样子"><a href="#组件的样子" class="headerlink" title="组件的样子"></a>组件的样子</h3><p>一个组件的生态大概是这样的：</p><p><img src="/2018/09/04/更好用的_Redux/component.png" alt=""></p><p>即：<strong> 数据经处理形成页面状态，页面状态决定  UI 渲染 </strong>。</p><h3 id="应用的样子"><a href="#应用的样子" class="headerlink" title="应用的样子"></a>应用的样子</h3><p>而组件生态（UI + 状态 + 状态管理方式）的组合就构成了我们应用：</p><p><img src="/2018/09/04/更好用的_Redux/components.png" alt="生态组合"></p><p>这里组件生态特意只展示了 <strong> 数据到状态 </strong> 这一步，因为 Redux 处理的正是这个部分。我们暂且可以定义数据到状态的过程为 <strong>flow</strong>，即一个业务流的意思。</p><h3 id="应用划分"><a href="#应用划分" class="headerlink" title="应用划分"></a>应用划分</h3><p>借鉴于 Elm，我们可以按数据模型对应用进行划分：</p><p><img src="/2018/09/04/更好用的_Redux/architecture.png" alt="应用划分"></p><p>其中，模型具有的属性有：</p><ul><li><code>name</code>: 模型名称</li><li><code>state</code>：模型的初始状态</li><li><code>reducers</code>：处理当前模型状态的 state</li><li><code>selectors</code>：服务于当前模型的 state selectors</li><li><code>flows</code>：当前模型涉及的业务流（副作用）</li></ul><blockquote><p>这个经典的划分模型正是 <a href="https://github.com/dvajs/dva" target="_blank" rel="noopener">Dva</a> 的应用划分手段，只是模型属性略有不同。</p></blockquote><p>假定我们创建了 user 模型和 post 模型，那么框架将挂载他们的状态到 user 和 post 状态子树下：</p><p><img src="/2018/09/04/更好用的_Redux/model_state_tree.png" alt=""></p><h3 id="约定-——-打掉样板代码"><a href="#约定-——-打掉样板代码" class="headerlink" title="约定 —— 打掉样板代码"></a>约定 —— 打掉样板代码</h3><p>有了模型这个概念后，框架就能定义一系列的约定去减少样板代码的书写。首先，我们回顾下以前我们是怎么定义的一个 action type 的：</p><ul><li>action 名称</li><li>指定一个 namespace 防止名字冲突</li></ul><p>例如，我们这样定义用户数据拉取相关的 action type：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> FETCH = <span class="string">'USRE/FETCH'</span></span><br><span class="line"><span class="keyword">const</span> FETCH_SUCCESS = <span class="string">'USER/FETCH_SUCCESSE'</span></span><br><span class="line"><span class="keyword">const</span> FETCH_ERROR = <span class="string">'USER/FETCH_ERROR'</span></span><br></pre></td></tr></table></figure><p>其中， <code>FETCH</code> 对应的是一个 <strong> 异步 </strong> 拉取数据的 action，<code>FETCH_SUCCESS</code> 和 <code>FETCH_ERROR</code> 则对应两个 <strong> 同步 </strong> 修改状态的 action。</p><p><strong> 同步 action 约定 </strong></p><p>对于同步的、不包含副作用的 action，我们直接将其呈递到 reducer，是不会破坏 reducer 纯度的。 因此，我们不妨约定： model 下 reducer 的 <strong> 名字 </strong> 映射一个直接对状态操作的 action type：</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">SYNC_ACTION_TYPE</span> = MODEL_NAME/REDUCER_NAME</span><br></pre></td></tr></table></figure><p>例如下面这个 user model：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> userModel = &#123;</span><br><span class="line">  name: <span class="string">'user'</span>,</span><br><span class="line">  state: &#123;</span><br><span class="line">    list: [],</span><br><span class="line">    total: <span class="number">0</span>,</span><br><span class="line">    loading: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  reducers: &#123;</span><br><span class="line">    fetchStart(state, payload) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, <span class="attr">loading</span>:<span class="literal">true</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们派发了一个类型为 <code>user/fetchStart</code> 的 action 之后，action 就带着其 payload 进入到 <code>user.fetchStart</code> 这个 reducer 下，进行状态变更。</p><p><strong> 异步 action 约定 </strong></p><p>对于异步的 action，我们就不能直接在 reducer 进行异步任务处理，而 model 中的 flow 就是异步任务的集装箱：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ASYNC_ACTION_TYPE = MODEL_NAME/FLOW_NAME</span><br></pre></td></tr></table></figure><p>例如下面这个 model：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  name: <span class="string">'user'</span>,</span><br><span class="line">  state: &#123;</span><br><span class="line">    list: [],</span><br><span class="line">    total: <span class="number">0</span>,</span><br><span class="line">    loading: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  flows: &#123;</span><br><span class="line">    fetch() &#123;</span><br><span class="line">      <span class="comment">// ... 处理一些异步任务 </span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们在 UI 里面发出了个 <code>user/fetch</code>，由于 user model 中存在一个名为 fetch 的 flow，那么就进入到这个 flow 中进行异步任务的处理。</p><p><strong> 状态的覆盖与更新 </strong></p><p>如果每个状态的更新都去撰写一个对应的 reducer 就太累了，因此，我们可以考虑为每个模型定义一个 change reducer，用于 <strong> 直接 </strong> 更新状态：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> userModel = &#123;</span><br><span class="line">  name: <span class="string">'user'</span>,</span><br><span class="line">  state: &#123;</span><br><span class="line">    list: [],</span><br><span class="line">    pagination: &#123;</span><br><span class="line">      page: <span class="number">1</span>,</span><br><span class="line">      total: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    loading: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  reducers: &#123;</span><br><span class="line">    change(state, action) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, ...action.payload &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，当我们派发了下面的一个 action，就将能够将 <code>loading</code> 状态置为 true：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">dispatch(&#123;</span><br><span class="line">  type: <span class="string">'user/change'</span>,</span><br><span class="line">  payload: &#123;</span><br><span class="line">    loading: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>但是，这种更新是 <strong> 覆盖式 </strong> 的，假定我们想要更新状态中的当前页面信息：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">dispatch(&#123;</span><br><span class="line">  type: <span class="string">'user/change'</span>,</span><br><span class="line">  payload: &#123;</span><br><span class="line">    pagination: &#123; <span class="attr">page</span>: <span class="number">1</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>状态就会变为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  list: [],</span><br><span class="line">  pagination: &#123;</span><br><span class="line">  page: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  loading: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>pagination</code> 状态被整个覆盖掉了，其中的总数状态 <code>total</code> 就丢失了。</p><p>因此，我们还要定义一个 patch reducer，意为对状态的 <strong> 补丁更新 </strong>，它只会影响到 action payload 中声明的子状态：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; merge &#125; <span class="keyword">from</span> <span class="string">'lodash.merge'</span></span><br><span class="line"><span class="keyword">const</span> userModel = &#123;</span><br><span class="line">  name: <span class="string">'user'</span>,</span><br><span class="line">  state: &#123;</span><br><span class="line">    list: [],</span><br><span class="line">    pagination: &#123;</span><br><span class="line">      page: <span class="number">1</span>,</span><br><span class="line">      total: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    loading: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  reducers: &#123;</span><br><span class="line">    change(state, action) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        &#123; ...state, ...action.payload &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    patch(state, action) &#123;</span><br><span class="line">      <span class="keyword">return</span> deepMerge(state, action.payload)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们尝试只更新分页：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">dispatch(&#123;</span><br><span class="line">  type: <span class="string">'user/patch'</span>,</span><br><span class="line">  payload: &#123;</span><br><span class="line">    pagination: &#123; <span class="attr">page</span>: <span class="number">1</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>新的状态就是：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  list: [],</span><br><span class="line">  pagination: &#123;</span><br><span class="line">  page: <span class="number">1</span>,</span><br><span class="line">    total: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  loading: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：这里的实现不是生产环境的实现，直接使用 lodash 的 merge 是不够的，实际项目中还要进行一定改造。</p></blockquote><h3 id="异步任务的组织"><a href="#异步任务的组织" class="headerlink" title="异步任务的组织"></a>异步任务的组织</h3><p>Dva 使用了 redux-saga 进行副作用（主要是异步任务）的组织，Rematch 则使用了 async/await 进行组织。从长期的实践来看，我更偏向于使用 redux-observable，尤其是在其 1.0 版本的发布之后，更是带来了可观察的 <code>state$</code>，使得我们能更加透彻地实践响应式编程。我们回顾下前文中提到的该模式的好处：</p><ul><li>统一数据源，observable 之间可组合</li><li>声明式编程，代码直爽简洁</li><li>优秀的竞态处理能力</li><li>测试友好</li><li>便于实现组件自治</li></ul><p>因此，对于模型异步任务的处理，我们选择 redux-observable：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> user:Model&lt;UserState&gt; = &#123;</span><br><span class="line">  name: <span class="string">'user'</span>,</span><br><span class="line">  state: &#123;</span><br><span class="line">    list: [],</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  reducers: &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  flows: &#123;</span><br><span class="line">    fetch(flow$, action$, state$) &#123;</span><br><span class="line">      <span class="comment">// ....</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与 epic 的函数签名略有不同的是，每个 flow 多了一个 <code>flow$</code> 参数，以上例来说，它就相当于：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">action$.ofType(<span class="string">'user/fetch'</span>)</span><br></pre></td></tr></table></figure><p>这个参数便于我们更快的取到需要的 action。</p><h3 id="处理加载态与错误态"><a href="#处理加载态与错误态" class="headerlink" title="处理加载态与错误态"></a>处理加载态与错误态</h3><p>前端工程中经常会有错误展示和加载展示的需求，</p><p><img src="/2018/09/04/更好用的_Redux/loading&amp;error.png" alt="loading 与 error"></p><p>如果我们手动管理每个模型的加载态和错误态就太麻烦了，因此在根状态下，单独划分两棵状态子树用于处理加载态与错误态，这样，便于框架去治理加载与错误，开发者直接在状态树上取用即可：</p><ul><li>loading </li><li>error</li></ul><p><img src="/2018/09/04/更好用的_Redux/state_tree.png" alt=""></p><p>如图，加载态和错误态还需要根据粒度进行划分，有大粒度的 flow 级别，用于标识一个 flow 是否正在进行中；也有小粒度的 service 级别，用于标识某个异步服务是否在进行中。</p><p>例如，若：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">loading.flows[<span class="string">'user/fetch'</span>] === <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>即表示 user model 下的 <code>fetch</code> flow 正在进行中。</p><p>若：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">loading.services[<span class="string">'/api/fetchUser'</span>] === <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>即表示 <code>/api/fetchUser</code> 这个服务正在进行中。</p><h3 id="响应式的服务治理"><a href="#响应式的服务治理" class="headerlink" title="响应式的服务治理"></a>响应式的服务治理</h3><p>前端调用后端服务操纵数据是一个广泛的需求，因此，我们还希望所谓的中间角色（框架）能够在我们的业务流中注入服务，完成服务和应用状态的交互：观察调用状况，自动捕获调用异常，适时地修改应用 loading 态和 error 态，方便用户直接在顶层状态取用服务运行状况。</p><p>另外，在响应式编程的范式下，框架提供的服务治理，在处理服务的成功和错误时应该也是响应式的，即成功和错误将是预定义的流（observable 对象），从而让开发者能更好的利用到响应式编程的能力：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> user:Model&lt;UserState&gt; = &#123;</span><br><span class="line">  name: <span class="string">'user'</span>,</span><br><span class="line">  state: &#123;</span><br><span class="line">    list: [],</span><br><span class="line">    total: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  reducers: &#123;</span><br><span class="line">    fetchSuccess(state, payload) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, list: payload.list, total: payload.total &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    fetchError(state, payload) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, list:&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  flows: &#123;</span><br><span class="line">    fetch(flow$, action$, state$, dependencies) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; service &#125; = dependencies</span><br><span class="line">      <span class="keyword">return</span> flow$.pipe(</span><br><span class="line">        withLatestFrom(state$, <span class="function">(<span class="params">action, state</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 拼装请求参数 </span></span><br><span class="line">          <span class="keyword">return</span> params</span><br><span class="line">        &#125;),</span><br><span class="line">        switchMap(<span class="function"><span class="params">params</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> [success$, error$] = service(getUsers(params))</span><br><span class="line">          <span class="keyword">return</span> merge(</span><br><span class="line">            success$.pipe(</span><br><span class="line">              map(<span class="function"><span class="params">resp</span> =&gt;</span> (&#123;</span><br><span class="line">                <span class="keyword">type</span>: <span class="string">'user/fetchSuccess'</span>,</span><br><span class="line">                payload: &#123;</span><br><span class="line">                  list: resp.list,</span><br><span class="line">                  total: resp.total</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;))</span><br><span class="line">            ),</span><br><span class="line">            error$.pipe(</span><br><span class="line">              map(<span class="function"><span class="params">error</span> =&gt;</span> (&#123;</span><br><span class="line">              <span class="keyword">type</span>: <span class="string">'user/fetchError'</span></span><br><span class="line">            &#125;))</span><br><span class="line">            )</span><br><span class="line">          )</span><br><span class="line">        &#125;)</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="reobservable"><a href="#reobservable" class="headerlink" title="reobservable"></a>reobservable</h2><p>上面的种种思考，概括下来其实就是 Dva architecture + redux-observable，前者能够打掉 Redux 冗长啰嗦的样板代码，后者则负责异步任务治理。</p><p>比较遗憾的是，Dva 没有使用 redux-observable 进行副作用管理，也没有相关插件实现使用 redux-observable 或者 RxJS 进行副作用管理，并且，通过 Dva 暴露的 hook 去实现一个 redux-observable 的 Dva 中间件也颇为不畅，因此，笔者尝试撰写了一个 <a href="https://github.com/reobservable/reobservable" target="_blank" rel="noopener">reobservable</a> 来实现上面提到框架，它与 Dva 不同的是：</p><ol><li>只关注应用状态，不涉及组件路由的其他生态</li><li>集成 loading 和 error 处理</li><li>使用 redux-observable 而不是 redux-saga 处理副作用</li><li>响应式的服务处理，支持应用自定义服务细节</li></ol><p>如果你的应用使用了 Redux，你苦于 Redux 种种负面影响，并且你还是一个响应式编程和 RxJS 的爱好者，你可以尝试下 reobservable。但是如果你偏爱 saga，或者 async await，你还是应该选择 Dva 或者 Rematch，术业有专攻。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://hackernoon.com/redesigning-redux-b2baee8b8a38" target="_blank" rel="noopener">Redesigning Redux</a></li><li><a href="https://guide.elm-lang.org/architecture/" target="_blank" rel="noopener">The Elm Architecture</a></li><li><a href="https://staltz.com/unidirectional-user-interface-architectures.html" target="_blank" rel="noopener">UNIDIRECTIONAL USER INTERFACE ARCHITECTURES</a></li></ul><h2 id="关于本系列"><a href="#关于本系列" class="headerlink" title="关于本系列"></a>关于本系列</h2><ul><li>本系列将从介绍 redux-observable 1.0 开始，阐述自己在结合 RxJS 到 Redux 中的心得体会。涉及内容会有 redux-observable 实践介绍，redux-observable 实现原理探究，最后会介绍下自己当前基于 redux-observble + dva architecture 的一个 state 管理框架 reobservable。</li><li>本系列不是 RxJS 或者 Redux 入门，不再讲述他们的基础概念，宣扬他们的核心优势。如果你搜索 RxJS 不小心进到了这个系列，对 RxJS 和 FRP 程序设计产生了兴趣，那么入门我会推荐：<ul><li><a href="https://www.learnrxjs.io/" target="_blank" rel="noopener">learnrxjs.io</a></li><li>Andre Staltz 在 <a href="https://egghead.io/courses/introduction-to-reactive-programming" target="_blank" rel="noopener">egghead.io</a> 上的一系列课程</li><li>程墨的 <a href="https://item.jd.com/12336101.html" target="_blank" rel="noopener">《深入浅出 RxJS》</a></li></ul></li><li>本系列更不是教程，只是介绍自己在 Redux 中应用 RxJS 的一些思路，希望更多人能指出当中存在的误区，或者交流更优雅的实践。</li><li>由衷的感谢实践路上一些师兄的帮助，尤其感谢腾讯云的 questguo 学长在模式上的指导。reobservable 脱胎于腾讯云 questguo 主导的 React 框架 —— TCFF，期待未来 TCFF 的开源。</li><li>感谢小雨的设计支援。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2018/09/04/更好用的_Redux/cover.png&quot; alt=&quot;cover&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文是 《使用 RxJS + Redux 管理应用状态》系列第三篇文章，将介绍我们在使用 Redux 时的困惑，如何重新思考 Redux 定下的范式，以及我们能为此做出的努力。返回第一篇：&lt;a href=&quot;http://yoyoyohamapi.me/2018/08/18/%E4%BD%BF%E7%94%A8_redux-observable_%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6%E8%87%AA%E6%B2%BB/&quot;&gt;使用 redux-observable 实现组件自治&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本系列的文章地址汇总：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://yoyoyohamapi.me/2018/08/18/%E4%BD%BF%E7%94%A8_redux-observable_%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6%E8%87%AA%E6%B2%BB/&quot;&gt;使用 redux-observable 实现组件自治&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://yoyoyohamapi.me/2018/08/21/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA_redux-observable/&quot;&gt;如何实现一个 redux-observable&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://yoyoyohamapi.me/2018/09/04/%E6%9B%B4%E5%A5%BD%E7%94%A8%E7%9A%84_Redux/&quot;&gt;更好用的 Redux&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="React" scheme="http://yoyoyohamapi.me/categories/React/"/>
    
    
      <category term="React" scheme="http://yoyoyohamapi.me/tags/React/"/>
    
      <category term="Redux" scheme="http://yoyoyohamapi.me/tags/Redux/"/>
    
      <category term="RxJS" scheme="http://yoyoyohamapi.me/tags/RxJS/"/>
    
  </entry>
  
  <entry>
    <title>如何实现一个 redux-observable</title>
    <link href="http://yoyoyohamapi.me/2018/08/21/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA_redux-observable/"/>
    <id>http://yoyoyohamapi.me/2018/08/21/实现一个_redux-observable/</id>
    <published>2018-08-21T07:06:18.000Z</published>
    <updated>2018-11-18T04:26:15.782Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2018/08/21/实现一个_redux-observable/cover.png" alt=""></p><blockquote><p>本文是 《使用 RxJS + Redux 管理应用状态》系列第二篇文章，将会介绍 redux-observable 的设计哲学和实现思路。返回第一篇：<a href="http://yoyoyohamapi.me/2018/08/18/%E4%BD%BF%E7%94%A8_redux-observable_%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6%E8%87%AA%E6%B2%BB/">使用 redux-observable 实现组件自治</a></p><p>本系列的文章地址汇总：</p><ul><li><a href="http://yoyoyohamapi.me/2018/08/18/%E4%BD%BF%E7%94%A8_redux-observable_%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6%E8%87%AA%E6%B2%BB/">使用 redux-observable 实现组件自治</a></li><li><a href="http://yoyoyohamapi.me/2018/08/21/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA_redux-observable/">如何实现一个 redux-observable</a></li></ul></blockquote><a id="more"></a><h2 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h2><p>Redux 脱胎于 Elm 架构，其状态管理视角和流程非常清晰和明确：</p><p><img src="/2018/08/21/实现一个_redux-observable/redux.png" alt=""></p><ol><li>dispatch 了一个 action</li><li>reducer 俘获 action，并根据 action 类型进行不同的状态更新逻辑</li><li>周而复始地进行这个过程</li></ol><p>这个过程是同步的，Redux 为了保护 reducer 的纯度是不推荐在 reducer 中处理副作用的（如 HTTP 请求）。因此，就出现了 redux-thunk、redux-saga 这样的 Redux 中间件去处理副作用。</p><p>这些中间件本质都是俘获 dispatch 的内容，并在这个过程中进行副作用处理，最终 dispatch 一个新的 action 给 reducer，让 reducer 专心做一个纯的状态机。</p><h2 id="用-observable-管理副作用"><a href="#用-observable-管理副作用" class="headerlink" title="用 observable 管理副作用"></a>用 observable 管理副作用</h2><p>假定我们在 UI 层能派发出一个数据拉取的 <code>FETCH</code> action，拉取数据后，将派发拉取成功的 <code>FETCH_SUCCESS</code> action 或者是数据拉取失败的 <code>FETCH_ERROR</code> action 到 reducer。</p><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">          FETCH</span><br><span class="line">            <span class="string">|</span></span><br><span class="line">      fetching data...</span><br><span class="line">            <span class="string">|</span></span><br><span class="line">           / \</span><br><span class="line">          /   \</span><br><span class="line">FETCH_SUCCESS FETCH_ERROR</span><br></pre></td></tr></table></figure><p>如果我们用 FRP 模式来思考这个过程，FETCH 就不是一个独立的个体，而是存在于一条会派发 FETCH action 的流上（observable）：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span><span class="meta">---</span> <span class="string">FETCH</span> <span class="bullet">----</span> <span class="string">FETCH</span> <span class="bullet">----</span> </span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span><span class="meta">---</span> <span class="string">FETCH_SUCCESS</span> <span class="bullet">----</span> <span class="string">FETCH_SUCCESS</span> <span class="bullet">----</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span><span class="meta">---</span> <span class="string">FETCH_ERROR</span> <span class="bullet">----</span> <span class="string">FETCH_ERROR</span> <span class="bullet">----</span></span><br></pre></td></tr></table></figure><p>若我们将 FETCH 流定义为 <code>fetch$</code>，则 FETCH_SUCCESS 和 FETCH_ERROR 都将来自于 <code>fetch$</code>：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fetch$: Observable&lt;FetchAction&gt; = <span class="comment">//....</span></span><br><span class="line">fetch$.pipe(</span><br><span class="line">  switchMap(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">from</span>(api.fetch).pipe(</span><br><span class="line">    <span class="comment">// 拉取数据成功 </span></span><br><span class="line">    switchMap(<span class="function"><span class="params">resp</span> =&gt;</span> (&#123;</span><br><span class="line">      <span class="keyword">type</span>: FETCH_SUCCESS,</span><br><span class="line">      payload: &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// 拉取数据失败 </span></span><br><span class="line">    catchError(<span class="function"><span class="params">error</span> =&gt;</span> of(&#123;</span><br><span class="line">      <span class="keyword">type</span>: FETCH_ERROR,</span><br><span class="line">      payload: &#123;</span><br><span class="line">        <span class="comment">// ....</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;))</span><br><span class="line">  ))</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>除此之外，我们可以用一个流来承载页面所有的 action：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> action$: Observable&lt;Action&gt;</span><br></pre></td></tr></table></figure><p>那么， <code>fetch$</code> 亦可以由 <code>action$</code> 流转得到：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fetch$ = action$.pipe(</span><br><span class="line">  filter(<span class="function">(<span class="params">&#123;<span class="keyword">type</span>&#125;</span>) =&gt;</span> <span class="keyword">type</span> === FETCH)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这样，我们就形成了使用 observable 流转 action 的模式：</p><p><img src="/2018/08/21/实现一个_redux-observable/使用 observable 流转 action.png" alt="使用 observable 流转 action"></p><p>接下来，我们尝试讲这个模式整合到 Redux 中，让 observable 来负责应用的 action 流转和副作用处理。</p><h2 id="构建中间件"><a href="#构建中间件" class="headerlink" title="构建中间件"></a>构建中间件</h2><p>Redux 提供的中间件机制能让我们干预每个到来的 action， 借此处理一些业务逻辑，然后再返还一个 action 给 reducer：</p><p><img src="/2018/08/21/实现一个_redux-observable/middleware.png" alt="middleware"></p><p>中间件的函数构成如下：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> middleware: Middleware = <span class="function"><span class="params">store</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 初始化中间件 </span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">next</span> =&gt;</span> action =&gt; &#123; </span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(</span><br><span class="line">  rootReducer,</span><br><span class="line">  applyMiddleware(middleware)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>现在，当中间件初始化时，我们进行 <code>action$</code> 。当新的 action 到来时：</p><ol><li>将 action 交给 reducer 处理</li><li>想 <code>action$</code> 中放入 action</li><li><code>action$</code> 可以转化另一个的 action 流</li></ol><p>因此，<code>action$</code> 既是观察者又是可观察对象，是一个 Subject 对象：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> createMiddleware = (): <span class="function"><span class="params">Middleware</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> action$ = <span class="keyword">new</span> Subject()</span><br><span class="line">  <span class="keyword">const</span> middleware: Middleware = <span class="function"><span class="params">store</span> =&gt;</span> next =&gt; <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 将 action 交给 reducer 处理 </span></span><br><span class="line">    <span class="keyword">const</span> result = next(action)</span><br><span class="line">    <span class="comment">// 将 action 放到 action$ 中进行流转 </span></span><br><span class="line">    action$.next(action)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> middleware</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="流的转换器"><a href="#流的转换器" class="headerlink" title="流的转换器"></a>流的转换器</h2><p>现在，在中间件中，我们初始化了 <code>action$</code>，但是如何得到 <code>fetch$</code> 这些由 <code>action$</code> 派生的流呢？因此，我们还需要告知中间件如果通过 <code>action$</code> 生成更多的流，不妨定义一个转换器，由它负责 <code>action$</code> 的流转，并在当中处理副作用：</p><p><img src="/2018/08/21/实现一个_redux-observable/transformer.png" alt=""></p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Transformer &#123;</span><br><span class="line">  (action$: Observable&lt;Action&gt;): Observable&lt;Action&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fetchTransformer: Transformer = <span class="function">(<span class="params">action$</span>) =&gt;</span> &#123;</span><br><span class="line">  action$.pipe(</span><br><span class="line">    filter(<span class="function">(<span class="params">&#123;<span class="keyword">type</span>&#125;</span>) =&gt;</span> <span class="keyword">type</span> === FETCH),</span><br><span class="line">    switchMap(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">from</span>(api.fetch).pipe(</span><br><span class="line">      switchMap(<span class="function"><span class="params">resp</span> =&gt;</span> (&#123;</span><br><span class="line">        <span class="keyword">type</span>: FETCH_SUCCESS,</span><br><span class="line">        payload: &#123;</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;),</span><br><span class="line">      catchError(<span class="function"><span class="params">error</span> =&gt;</span> of(&#123;</span><br><span class="line">        <span class="keyword">type</span>: FETCH_ERROR,</span><br><span class="line">        payload: &#123;</span><br><span class="line">          <span class="comment">// ....</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;))</span><br><span class="line">    ))</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用中，我们可能定义不同的转换器，从而得到派发不同 action 的流：</p><p><img src="/2018/08/21/实现一个_redux-observable/transformers.png" alt="多个 transformer "></p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> newActionsStreams: Observable&lt;Action&gt;[] = transformers.map(<span class="function"><span class="params">transformer</span> =&gt;</span> transformer(action$))</span><br></pre></td></tr></table></figure><p>由于这些 action 还具有一致的数据结构，因此我们可以将这些流进行合并，由合并后的流负责派发 action 到 reducer：</p><p><img src="/2018/08/21/实现一个_redux-observable/merge.png" alt="合并多个流"></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> newAction$ = merge(newActionStreams)</span><br></pre></td></tr></table></figure><p>那么，修改我们的中间件实现：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> createMiddleware = (...transformers): <span class="function"><span class="params">Middleware</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> action$ = <span class="keyword">new</span> Subject()</span><br><span class="line">  <span class="comment">// 运行各个 transformer，并将转换的流进行合并 </span></span><br><span class="line">  <span class="keyword">const</span> newAction$ = merge(tramsformer.map(<span class="function"><span class="params">transformer</span> =&gt;</span> transformer(action$)))</span><br><span class="line">  <span class="keyword">const</span> middleware: Middleware = <span class="function"><span class="params">store</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 订阅 newAction$</span></span><br><span class="line">    newAction$.subscribe(<span class="function"><span class="params">action</span> =&gt;</span> store.dispatch(action))</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">next</span> =&gt;</span> action =&gt; &#123;</span><br><span class="line">      <span class="comment">// 将 action 交给 reducer 处理 </span></span><br><span class="line">      <span class="keyword">const</span> result = next(action)</span><br><span class="line">      <span class="comment">// 将 action 放到 action$ 中进行流转 </span></span><br><span class="line">      action$.next(action)</span><br><span class="line">      <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> middleware</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优化：ofType-operator"><a href="#优化：ofType-operator" class="headerlink" title="优化：ofType operator"></a>优化：<code>ofType</code> operator</h2><p>由于我们总是需要 <code>filter(action =&gt; action.type === SOME_TYPE)</code> 来过滤 action，因此可以封装一个 operator 来优化这个过程：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ofType: OperatorFunction&lt;Observable&lt;Action&gt;, Observable&lt;Action&gt;&gt; = <span class="function">(<span class="params"><span class="keyword">type</span>: <span class="built_in">String</span></span>) =&gt;</span> pipe(</span><br><span class="line">  filter(<span class="function"><span class="params">action</span> =&gt;</span> action.type === <span class="keyword">type</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fetchTransformer: Transformer = (action$) &#123;</span><br><span class="line">  <span class="keyword">return</span> action$.pipe(</span><br><span class="line">    filter(<span class="function">(<span class="params">&#123;<span class="keyword">type</span>&#125;</span>) =&gt;</span> <span class="keyword">type</span> === FETCH),</span><br><span class="line">    switchMap(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">from</span>(api.fetch)),</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再考虑到我们可能不只过滤一个 action type，因此可以优化我们的 <code>ofType</code> operator 为：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ofType: OperatorFunction&lt;Observable&lt;Action&gt;, Observable&lt;Action&gt;&gt; = </span><br><span class="line">  (...types: <span class="built_in">String</span>[]) =&gt; pipe(</span><br><span class="line">    filter(<span class="function">(<span class="params">action: Action</span>) =&gt;</span> types.indexOf(action.type) &gt; <span class="number">-1</span>)</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> counterTransformer: Transformer = (action$) &#123;</span><br><span class="line">  <span class="keyword">return</span> action$.pipe(</span><br><span class="line">    ofType(INCREMENT, DECREMENT),</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面这个测试用例将用来测试我们的中间件是否能够工作了：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'should transform action'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">const</span> reducer: Reducer = <span class="function">(<span class="params">state = 0, action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span>(action.type) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'PONG'</span>:</span><br><span class="line">        <span class="keyword">return</span> state + <span class="number">1</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> state</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> transformer: Transformer = <span class="function">(<span class="params">action$</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> action$.pipe(</span><br><span class="line">        ofType(<span class="string">'PING'</span>),</span><br><span class="line">        mapTo(&#123;<span class="keyword">type</span>: <span class="string">'PONG'</span>&#125;)</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> middleware = createMiddleware(transformer)</span><br><span class="line">  <span class="keyword">const</span> store = createStore(reducer, applyMiddleware(middleware))</span><br><span class="line">  store.dispatch(&#123;<span class="keyword">type</span>: <span class="string">'PING'</span>&#125;)</span><br><span class="line">  expect(store.getState()).to.be.equal(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="优化：获得-state"><a href="#优化：获得-state" class="headerlink" title="优化：获得 state"></a>优化：获得 state</h2><p>在 action 的流转过程可能还需要获得应用状态，例如，<code>fetch$</code> 中获取数据前，需要封装请求参数，部分参数可能来自于应用状态。因此，我们可以考虑为每个 transformer 再传递当前的 store 对象，使它能拿到当前的应用状态：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Transformer &#123;</span><br><span class="line">  (action$: Observable&lt;Action&gt;, store: Store): Observable&lt;Action&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> createMiddleware = (...transformers): <span class="function"><span class="params">Middleware</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> action$ = <span class="keyword">new</span> Subject()</span><br><span class="line">  <span class="keyword">const</span> middleware: Middleware = <span class="function"><span class="params">store</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 将 store 也传递给 transformer</span></span><br><span class="line">    <span class="keyword">const</span> newAction$ = merge(tramsformer.map(<span class="function"><span class="params">transformer</span> =&gt;</span> transformer(action$, store)))</span><br><span class="line">    newAction$.subscribe(<span class="function"><span class="params">action</span> =&gt;</span> store.dispatch(action))</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">next</span> =&gt;</span> action =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> result = next(action)</span><br><span class="line">      action$.next(action)</span><br><span class="line">      <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> middleware</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，当需要取用状态的时候，就通过 <code>store.getState()</code> 拿取：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fetchTransformer: Transformer = (action$, store) &#123;</span><br><span class="line">  <span class="keyword">return</span> action$.pipe(</span><br><span class="line">    filter(<span class="function">(<span class="params">&#123;<span class="keyword">type</span>&#125;</span>) =&gt;</span> <span class="keyword">type</span> === FETCH),</span><br><span class="line">    switchMap(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; query, page, pageSize &#125; = store.getState()</span><br><span class="line">      <span class="keyword">const</span> params = &#123; query, page, pageSize &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">from</span>(api.fetch, params)</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优化：观察状态"><a href="#优化：观察状态" class="headerlink" title="优化：观察状态"></a>优化：观察状态</h2><p>在响应式编程体系下，一切数据源都应当是可被观察的，而上面我们对状态的取值确是主动的（proactive）的，正确的方式是应当观察状态的变化，并在变化时作出决策：</p><p><img src="/2018/08/21/实现一个_redux-observable/state$.png" alt="state$"></p><p>为此，类似 <code>action$</code>，我们也将 state 流化，使得应用状态成为一个可观察对象，并将 <code>state$</code> 传递给 transformer：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Transformer &#123;</span><br><span class="line">  (action$: Observable&lt;Action&gt;, state$: Observable&lt;State&gt;): Observable&lt;Action&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> createMiddleware = (...transformers): <span class="function"><span class="params">Middleware</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> action$ = <span class="keyword">new</span> Subject()</span><br><span class="line">  <span class="keyword">const</span> state$ = <span class="keyword">new</span> Subject()</span><br><span class="line">  <span class="keyword">const</span> middleware: Middleware = <span class="function"><span class="params">store</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 由各个 transformer 获得应用的 action$</span></span><br><span class="line">    <span class="keyword">const</span> newAction$ = merge(tramsformer.map(<span class="function"><span class="params">transformer</span> =&gt;</span> transformer(action$, state$)))</span><br><span class="line">    <span class="comment">// 新的 action 到来时，将其又 dispatch 到 Redux 生态 </span></span><br><span class="line">    newAction$.subscribe(<span class="function"><span class="params">action</span> =&gt;</span> store.dispatch(action))</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">next</span> =&gt;</span> action =&gt; &#123;</span><br><span class="line">      <span class="comment">// 将 action 交给 reducer</span></span><br><span class="line">      <span class="keyword">const</span> result = next(action)</span><br><span class="line">      <span class="comment">// 获得 reducer 处理后的新状态 </span></span><br><span class="line">      state$.next(state)</span><br><span class="line">      <span class="comment">// 将 action 放入 action$</span></span><br><span class="line">      action$.next(action)</span><br><span class="line">      <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> middleware</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当业务流程需要状态时，就可以自由组合 <code>state$</code> 得到：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fetchTransformer: Transformer = (action$, state$) &#123;</span><br><span class="line">  <span class="keyword">return</span> action$.pipe(</span><br><span class="line">    filter(<span class="function">(<span class="params">&#123;<span class="keyword">type</span>&#125;</span>) =&gt;</span> <span class="keyword">type</span> === FETCH),</span><br><span class="line">    withLatestFrom(state$),</span><br><span class="line">    switchMap(<span class="function">(<span class="params">[action, state]</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; query, page, pageSize &#125; = state</span><br><span class="line">      <span class="keyword">const</span> params = &#123; query, page, pageSize &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">from</span>(api.fetch, params)</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>乍看之下，似乎不如 <code>store.getState()</code> 来的方便，为了获得当前状态，我们还额外引入了一个 operator <code>withLatestFrom</code>。但是，要注意到，我们引入 <code>state$</code> 不只为了获得状态和统一模式，更重要是为了 <strong> 观察 </strong> 状态。</p><p>举个例子，我们有一个备忘录组件，每次内容变动时，我们就存储一下草稿。如果我们能观察状态变动，通过响应式编程模式，当状态变动时，自动形成草稿存储的业务：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> saveDraft$: Observable&lt;Action&gt; = state$.pipe(</span><br><span class="line">  <span class="comment">// 选出当前 </span></span><br><span class="line">  pluck(<span class="string">'content'</span>),</span><br><span class="line">  <span class="comment">// 只有当内容变动时才考虑存储草稿 </span></span><br><span class="line">  distinctUntilChanged(),</span><br><span class="line">  <span class="comment">// 只在 1 s 内保存一次 </span></span><br><span class="line">  throttleTime(<span class="number">1000</span>),</span><br><span class="line">  <span class="comment">// 调用服务存储草稿 </span></span><br><span class="line">  switchMap(<span class="function"><span class="params">content</span> =&gt;</span> <span class="keyword">from</span>(api.saveDraft(content)))</span><br><span class="line">  <span class="comment">// ....</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>大家也可以在回顾系列第一篇所介绍的内容，正是由于 redux-observable 在 1.0 版本引入了 <code>state$</code>，我们才得以解耦组件的业务关系，实现单个组件的自治。</p><h2 id="优化：响应初始状态"><a href="#优化：响应初始状态" class="headerlink" title="优化：响应初始状态"></a>优化：响应初始状态</h2><p>现在，我们可以测试一下现在的中间件，看能否观察应用状态了：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'should observe state'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">const</span> reducer: Reducer = <span class="function">(<span class="params">state = &#123;step: 10, counter: 0&#125;, action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span>(action.type) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'PONG'</span>:</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          ...state,</span><br><span class="line">          counter: action.counter</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> state</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> transformer: Transformer = <span class="function">(<span class="params">action$, state$</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> action$.pipe(</span><br><span class="line">        ofType(<span class="string">'PING'</span>),</span><br><span class="line">      withLatestFrom(state$, <span class="function">(<span class="params">action, state</span>) =&gt;</span> state.step + state.counter),</span><br><span class="line">        map(<span class="function"><span class="params">counter</span> =&gt;</span> (&#123;<span class="keyword">type</span>: <span class="string">'PONG'</span>, counter&#125;))</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> middleware = createMiddleware(transformer)</span><br><span class="line">  <span class="keyword">const</span> store = createStore(reducer, applyMiddleware(middleware))</span><br><span class="line">  store.dispatch(&#123;<span class="keyword">type</span>: <span class="string">'PING'</span>&#125;)</span><br><span class="line">  expect(store.getState().counter).to.be.equal(<span class="number">10</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>遗憾的是，这个测试用例将不会通过，通过调试发现，当我们 dispatch 了 PING action 后，<code>withLatestFrom</code> 没有拿到最近一次的 state。这是为什么呢？原来是因为 Redux 的 init action 并没有暴露给中间件进行拦截，因此，应用的初始状态没能被送入 <code>state$</code> 中，观察者无法观察到初始状态。</p><p>为了解决这个问题，在创建了 store 后，我们可以尝试 dispatch 一个无意义的 action 给中间件，强制将初始状态先送入 <code>state$</code> 中：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> middleware = createMiddleware(transformer)</span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer, applyMiddleware(middleware))</span><br><span class="line"><span class="comment">// 派发一个 action 去获得初始状态 </span></span><br><span class="line">store.dispatch(&#123;<span class="keyword">type</span>: <span class="string">'@@INIT_STATE'</span>&#125;)</span><br></pre></td></tr></table></figure><p>这个方式虽然能让测试通过，但缺不是很优雅，我们让用户手动去派发一个无意义的 action，这会让用户感觉很困惑。因此，我们考虑为中间件单独设置一个 API，用以在 store 创建后，完成一些任务：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置一个 store 副本 </span></span><br><span class="line"><span class="keyword">let</span> cachedStore: Store</span><br><span class="line"><span class="keyword">const</span> createMiddleware = (...transformers): <span class="function"><span class="params">Middleware</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> action$ = <span class="keyword">new</span> Subject()</span><br><span class="line">  <span class="keyword">const</span> state$ = <span class="keyword">new</span> Subject()</span><br><span class="line">  <span class="keyword">const</span> newAction$ = merge(transformers.map(<span class="function"><span class="params">transformer</span> =&gt;</span> transformer(action$, state$)))</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> middleware: Middleware = <span class="function"><span class="params">store</span> =&gt;</span> &#123;</span><br><span class="line">    cachedStore = store</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">next</span> =&gt;</span> action =&gt; &#123;</span><br><span class="line">      <span class="comment">// 将 action 交给 reducer</span></span><br><span class="line">      <span class="keyword">const</span> result = next(action)</span><br><span class="line">      <span class="comment">// 获得 reducer 处理后的新状态 </span></span><br><span class="line">      state$.next(state)</span><br><span class="line">      <span class="comment">// 将 action 放入 action$</span></span><br><span class="line">      action$.next(action)</span><br><span class="line">      <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  middleware.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 开始对 action 的订阅 </span></span><br><span class="line">    newAction$.subscribe(cachedStore.dispatch)</span><br><span class="line">    <span class="comment">// 2. 将初始状态传递给 state$</span></span><br><span class="line">    state$.next(cachedStore.getState())</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> middleware</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们为中间件提供了一个 <code>run</code> 方法，来让中间件在 store 创建以后完成一些工作。当我们创建好 store 后，运行 <code>run</code> 方法来运行中间件：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> middleware = createMiddleware(transformer)</span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer, applyMiddleware(middleware))</span><br><span class="line"><span class="comment">// 运行我们的中间件 </span></span><br><span class="line">middleware.run()</span><br></pre></td></tr></table></figure><h2 id="优化：相互关联的-transformer"><a href="#优化：相互关联的-transformer" class="headerlink" title="优化：相互关联的 transformer"></a>优化：相互关联的 transformer</h2><p>再考虑一个更加场景，各个 transformer 之间可能存在关联，各个 trasformer 也可能直接发出 action，而不需要依赖于 <code>action$</code>：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'should queue synchronous actions'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> reducer = <span class="function">(<span class="params">state = [], action</span>) =&gt;</span> state.concat(action)</span><br><span class="line">    <span class="keyword">const</span> transformer1 = <span class="function">(<span class="params">action$, state$</span>) =&gt;</span> action$.pipe(</span><br><span class="line">      ofType(<span class="string">'FIRST'</span>),</span><br><span class="line">      mergeMap(<span class="function"><span class="params">()</span> =&gt;</span> of(&#123; <span class="keyword">type</span>: <span class="string">'SECOND'</span> &#125;, &#123; <span class="keyword">type</span>: <span class="string">'THIRD'</span>&#125; ))</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">const</span> transformer2 = <span class="function">(<span class="params">action$, state$</span>) =&gt;</span> action$.pipe(</span><br><span class="line">        ofType(<span class="string">'SECOND'</span>),</span><br><span class="line">        mapTo(&#123;<span class="keyword">type</span>: <span class="string">'FORTH'</span>&#125;)</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> middleware = createMiddleware(transformer1, transformer2)</span><br><span class="line">    <span class="keyword">const</span> store = createStore(reducer, applyMiddleware(middleware))</span><br><span class="line">    middleware.run()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> actions = store.getState()</span><br><span class="line">    actions.shift() <span class="comment">// remove redux init action</span></span><br><span class="line">    expect(actions).to.deep.equal([</span><br><span class="line">      &#123; <span class="keyword">type</span>: <span class="string">'FIRST'</span> &#125;,</span><br><span class="line">      &#123; <span class="keyword">type</span>: <span class="string">'SECOND'</span> &#125;,</span><br><span class="line">      &#123; <span class="keyword">type</span>: <span class="string">'THIRD'</span> &#125;,</span><br><span class="line">      &#123; <span class="keyword">type</span>: <span class="string">'FORTH'</span> &#125;</span><br><span class="line">    ])</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在这个测试用例中，我们看到的 action 序列是：</p><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">FIRST</span></span><br><span class="line"><span class="attribute">SECOND</span></span><br><span class="line"><span class="attribute">THIRD</span></span><br><span class="line"><span class="attribute">FORTH</span></span><br></pre></td></tr></table></figure><p>但是，在当前的实现中，你将得到：</p><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">FIRST</span></span><br><span class="line"><span class="attribute">SECOND</span></span><br><span class="line"><span class="attribute">FORTH</span></span><br><span class="line"><span class="attribute">THIRD</span></span><br></pre></td></tr></table></figure><p>这并不符合预期。但是，问题又出在哪里呢？我们分析下程序执行过程：</p><ol><li>发出 first action</li><li>调度 first action，派生出 second action 及 third action 的 observable</li><li>调度 second action，派生出 forth action 的 observable</li><li>调度 forth action</li><li>调度 third action</li></ol><p>问题显然就出在第 2、3 步，如果第 2 步中，我们控制 observable <strong> 吐出值 </strong> 的速度，将同时到来的 second 和 third action 缓存到队列，并依次执行，就能得到我们期望的输出。</p><p>幸运的是，RxJS 中提供了 <a href="http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-observeOn" target="_blank" rel="noopener"> <code>observeOn</code></a> 这个 operator 来控制 <strong> 数据源发出值的节奏 </strong>。其第一个参数接收一个调度器，用于告知数据源以怎样的速录调度任务，这里我们将使用 <a href="https://rxjs-dev.firebaseapp.com/api/index/const/queueScheduler" target="_blank" rel="noopener"><strong>Queue Scheduler</strong></a> 将各个 action 缓存到队列，当此时再无 action 时，各个 action 出队并被调度：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createEpicMiddleware = <span class="function">(<span class="params">...epics</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> action$ = <span class="keyword">new</span> Subject().pipe(observeOn(queueScheduler)) <span class="keyword">as</span> Subject&lt;Action&gt;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> middleware</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，再次运行测试用例，你讲看到符合期望的 action 序列：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">FIRST</span><br><span class="line">SECOND</span><br><span class="line">THIRD</span><br><span class="line">FORTH</span><br></pre></td></tr></table></figure><p>这是因为：</p><ol><li>发出 first action</li><li>调度 first action，入队</li><li>此时没有 action，first action 出队，<code>store.dispatch(first)</code>，派生出 second action 及 third action 的 observable</li><li>second action 入队，third action 入队</li><li>此时没有等待的 action，则 second action 出队，<code>store.dispatch(second)</code>，派生出 forth action 的 observable</li><li>forth action 入队</li><li>此时没有等待的 action，队首元素 third action 出队，<code>store.dispatch(third)</code></li><li>forth action 出队，<code>store.dispatch(forth)</code></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>截止目前，我们的中间件已经允许我们通过 FRP 模式梳理应用状态了，这个中间件的实现已经非常类似于 redux-observable 的实现了。当然，大家生产环境还是用更流行，更稳定的 redux-observable，本文旨在帮助大家更好的理解如何在 Redux 中集成 RxJS 更好的管理状态，通过一步一步对中间件的优化，也让大家理解了了 redux-observable 的设计哲学和实现原理。本文实现的 mini redux-observable 我也放到了我的 <a href="https://github.com/yoyoyohamapi/toys/tree/master/redux-observable" target="_blank" rel="noopener">github</a> 上，包含了一些测试用例和一个小的 demo。</p><p>接下来，我们将探索将 redux-observable 以及 FRP 这套模式集成到 dva 架构的前端框架中，dva 架构帮助砍掉 Redux 冗长的样板代码，而 redux-observable 则专注于副作用处理。</p><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html" target="_blank" rel="noopener">RxJS API document</a></li><li><a href="https://staltz.com/primer-on-rxjs-schedulers.html" target="_blank" rel="noopener">PRIMER ON RXJS SCHEDULERS</a></li><li><a href="https://github.com/redux-observable/redux-observable/pull/493" target="_blank" rel="noopener">redux-observable #493 pull request</a></li><li><a href="https://www.youtube.com/watch?v=AL8dG1tuH40&amp;t=2366s" target="_blank" rel="noopener">Gerard Sans — Bending time with Schedulers and RxJS 5</a></li></ul><h2 id="关于本系列"><a href="#关于本系列" class="headerlink" title="关于本系列"></a>关于本系列</h2><ul><li>本系列将从介绍 redux-observable 1.0 开始，阐述自己在结合 RxJS 到 Redux 中的心得体会。涉及内容会有 redux-observable 实践介绍，redux-observable 实现原理探究，最后会介绍下自己当前基于 redux-observble + dva architecture 的一个 state 管理框架 reobservable。</li><li>本系列不是 RxJS 或者 Redux 入门，不再讲述他们的基础概念，宣扬他们的核心优势。如果你搜索 RxJS 不小心进到了这个系列，对 RxJS 和 FRP 程序设计产生了兴趣，那么入门我会推荐：<ul><li><a href="https://www.learnrxjs.io/" target="_blank" rel="noopener">learnrxjs.io</a></li><li>Andre Staltz 在 <a href="https://egghead.io/courses/introduction-to-reactive-programming" target="_blank" rel="noopener">egghead.io</a> 上的一系列课程</li><li>程墨的 <a href="https://item.jd.com/12336101.html" target="_blank" rel="noopener">《深入浅出 RxJS》</a></li></ul></li><li>本系列更不是教程，只是介绍自己在 Redux 中应用 RxJS 的一些思路，希望更多人能指出当中存在的误区，或者交流更优雅的实践。</li><li>由衷的感谢实践路上一些师兄的帮助，尤其感谢腾讯云的 questguo 学长在模式上的指导。reobservable 脱胎于腾讯云 questguo 主导的 React 框架 —— TCFF，期待未来 TCFF 的开源。</li><li>感谢小雨的设计支援。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2018/08/21/实现一个_redux-observable/cover.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文是 《使用 RxJS + Redux 管理应用状态》系列第二篇文章，将会介绍 redux-observable 的设计哲学和实现思路。返回第一篇：&lt;a href=&quot;http://yoyoyohamapi.me/2018/08/18/%E4%BD%BF%E7%94%A8_redux-observable_%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6%E8%87%AA%E6%B2%BB/&quot;&gt;使用 redux-observable 实现组件自治&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本系列的文章地址汇总：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://yoyoyohamapi.me/2018/08/18/%E4%BD%BF%E7%94%A8_redux-observable_%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6%E8%87%AA%E6%B2%BB/&quot;&gt;使用 redux-observable 实现组件自治&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://yoyoyohamapi.me/2018/08/21/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA_redux-observable/&quot;&gt;如何实现一个 redux-observable&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="React" scheme="http://yoyoyohamapi.me/categories/React/"/>
    
    
      <category term="React" scheme="http://yoyoyohamapi.me/tags/React/"/>
    
      <category term="Redux" scheme="http://yoyoyohamapi.me/tags/Redux/"/>
    
      <category term="RxJS" scheme="http://yoyoyohamapi.me/tags/RxJS/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoyoyohamapi.me/2018/08/18/RxJS+Redux-1/"/>
    <id>http://yoyoyohamapi.me/2018/08/18/RxJS+Redux-1/</id>
    <published>2018-08-18T05:44:00.066Z</published>
    <updated>2018-08-18T05:44:20.531Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用 redux-observable 实现组件自治</title>
    <link href="http://yoyoyohamapi.me/2018/08/18/%E4%BD%BF%E7%94%A8_redux-observable_%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6%E8%87%AA%E6%B2%BB/"/>
    <id>http://yoyoyohamapi.me/2018/08/18/使用_redux-observable_实现组件自治/</id>
    <published>2018-08-18T02:35:00.000Z</published>
    <updated>2018-08-26T14:56:10.040Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2018/08/18/使用_redux-observable_实现组件自治/cover.png" alt=""></p><h1 id="使用-redux-observable-实现组件自治"><a href="#使用-redux-observable-实现组件自治" class="headerlink" title="使用 redux-observable 实现组件自治"></a>使用 redux-observable 实现组件自治</h1><blockquote><p>本文是 《使用 RxJS + Redux 管理应用状态》系列第一篇文章，旨在介绍 redux-obervable v1 版本为 React + Redux 带来的组件自治能力。</p><p>本系列的文章地址汇总：</p><ul><li><a href="http://yoyoyohamapi.me/2018/08/18/%E4%BD%BF%E7%94%A8_redux-observable_%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6%E8%87%AA%E6%B2%BB/">使用 redux-observable 实现组件自治</a></li><li><a href="http://yoyoyohamapi.me/2018/08/21/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA_redux-observable/">如何实现一个 redux-observable</a></li></ul></blockquote><a id="more"></a><h2 id="redux-observable-简介"><a href="#redux-observable-简介" class="headerlink" title="redux-observable 简介"></a>redux-observable 简介</h2><p><a href="https://github.com/redux-observable/redux-observable" target="_blank" rel="noopener">redux-observable</a> 是 redux 一个中间件，使用了 RxJs 来驱动 action 副作用。与其目的类似的有大家比较熟悉的 <a href="https://github.com/reduxjs/redux-thunk" target="_blank" rel="noopener">redux-thunk</a> 和 <a href="https://github.com/redux-saga/redux-saga" target="_blank" rel="noopener">redux-saga</a>。通过集成 redux-observable，我们可以在 Redux 中使用到 RxJS 所提供的函数响应式编程（FRP）的能力，从而更轻松的管理我们的异步副作用（前提是你熟悉了 RxJS）。</p><p><strong>Epic</strong> 是 redux-observable 的核心概念和基础类型，几乎承载了 redux-observable 的所有。从形式上看，Epic 是一个函数，其接收一个 <strong>action stream</strong>，输出一个新的 action stream：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">action$: Observable&lt;Action&gt;, state$: StateObservable&lt;State&gt;</span>): <span class="title">Observable</span>&lt;<span class="title">Action</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，Epic 扮演了 stream 转换器的能力。</p><p>在 redux-observable 的视角下，Redux 作为中央状态收集器，当一个 action 被 dispatch，历经某个同步或者异步任务，将 dispatch 一个新的 action，携带着它的负载（payload）到 reducer，如此反复。这么看的话，Epic 定义了 action 因果关系。</p><p>同时，FRP 模式的 RxJS 还带来了如下能力：</p><ul><li><strong> 竞态处理能力 </strong></li><li><strong> 声明式地任务处理 </strong></li><li><strong> 测试友好 </strong></li><li><strong> 组件自治 </strong>（redux-observable 1. 0 开始支持）</li></ul><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>本系列是假定读者有了 FRP 和 RxJS 的基础，因此，关于 RxJS 和 redux-observable 不再赘述。</p><p>现在，我们实践一个常见的业务需求 —— 列表页。通过这个例子，将展示 redux-observable 1.0 新的特性，并展示在 1.0 下实现的组件自治。</p><blockquote><p><strong> 组件自治 </strong>：组件只用关注如何治理自己。</p></blockquote><p>先看到列表页的诉求：</p><ul><li>间隔一段时间轮询数据列表</li><li>支持搜索，触发搜索时，重新轮询</li><li>支持字段排序，排序状况变动，重新轮询</li><li>支持分页，页面容量修改，分页状况变动，重新轮询</li><li>组件卸载时，结束轮询</li></ul><p>在前端组件化开发的思路下，我们可能会设计如下容器组件（Container），其中基础组件基于 <a href="https://ant.design/" target="_blank" rel="noopener">ant design</a>：</p><ul><li><p><strong> 数据表格（含分页）</strong>：基于 <strong>Table</strong> 组件</p></li><li><p><strong> 搜索框：</strong>：基于 <strong>Input</strong> 组件</p></li><li><p><strong> 排序选择框：</strong> 基于 <strong>Select </strong> 组件</p></li></ul><p>在 React + Redux 的架构下，容器组件通过 <code>connect</code> 方法从状态树上采摘自己所需要的状态，因此，先要认识到，这些容器组件必定存在一个 <strong> 耦合 </strong>—— Redux：</p><p><img src="/2018/08/18/使用_redux-observable_实现组件自治/rxjs_redux_list_page.png" alt="列表页"></p><p>接下来将会讨论两种不同的模式下，列表应用的状态管理和副作用处理，它们分别是基于 redux-thunk 或者 redux-saga 的传统模式，以及基于 redux-observable 的 FRP 模式。大家可以看到不同模式下，除了基础的对于 Redux 的耦合，组件及其数据生态（状态与副作用）上耦合状况的差异。</p><p>当然，为了让大家更好的理解文章，我也撰写了一个 <strong><a href="https://github.com/yoyoyohamapi/self-government-component-with-redux-observable" target="_blank" rel="noopener">demo</a></strong>，大家可以 clone &amp; run。接下来的代码也都来源于这个 demo。demo 一个 github 小应用，其中你看到用户列表背后是基于 FRP 模式的，Repo 列表则是基于传统模式的：</p><p><img src="/2018/08/18/使用_redux-observable_实现组件自治/rxjs_redux_demo.png" alt="demo screenshot"></p><h2 id="传统模式下组件的耦合"><a href="#传统模式下组件的耦合" class="headerlink" title="传统模式下组件的耦合"></a>传统模式下组件的耦合</h2><p>在传统的模式下，我们需要面对一个现实，对于状态的获取是 <strong> 主动式（proactive）</strong> 的：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> state = store.getState()</span><br></pre></td></tr></table></figure><p>亦即我们需要 <strong> 主动取用状态 </strong>，而无法监听状态变化。因此，在这种模式下，我们组件化开发的思路会是：</p><ul><li>组件挂载，开启轮询<ul><li>搜索时，结束上次轮询，构建新的请求参数，开始新的轮询</li><li>排序变动时，结束上次轮询，构建新的请求参数，开始新的轮询</li><li>分页变动时，结束上次轮询，构建新的请求参数，开始新的轮询</li></ul></li><li>组件卸载，结束轮询</li></ul><p>在这种思路下，我们撰写搜索，排序，分页等容器时，当容器涉及的取值变动时，不仅需要在状态树上更新这些值，还需要去重启一下轮询。</p><p><img src="/2018/08/18/使用_redux-observable_实现组件自治/rxjs_redux_traditional.png" alt="组件耦合"></p><p>假定我们使用 redux-thunk 来处理副作用，代码大致如下：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> pollingTimer: <span class="built_in">number</span> = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchUsers</span>(<span class="params"></span>): <span class="title">ThunkResult</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">dispatch, getState</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> delay = pollingTimer === <span class="literal">null</span> ? <span class="number">0</span> : <span class="number">15</span> * <span class="number">1000</span></span><br><span class="line">    pollingTimer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      dispatch(&#123;</span><br><span class="line">        <span class="keyword">type</span>: FETCH_START,</span><br><span class="line">        payload: &#123;&#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">const</span> &#123; repo &#125;: &#123; repo: IState &#125; = getState()</span><br><span class="line">      <span class="keyword">const</span> &#123; pagination, sort, query &#125; = repo</span><br><span class="line">      <span class="comment">// 封装参数 </span></span><br><span class="line">      <span class="keyword">const</span> param: ISearchParam = &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 进行请求 </span></span><br><span class="line">      <span class="comment">// fetch(param)...</span></span><br><span class="line">  &#125;, delay)</span><br><span class="line">&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">polling</span>(<span class="params"></span>): <span class="title">ThunkResult</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</span><br><span class="line">    dispatch(stopPolling())</span><br><span class="line">    dispatch(&#123;</span><br><span class="line">      <span class="keyword">type</span>: POLLING_START,</span><br><span class="line">      payload: &#123;&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    dispatch(fetchUsers())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">stopPolling</span>(<span class="params"></span>): <span class="title">IAction</span> </span>&#123;</span><br><span class="line">  clearTimeout(pollingTimer)</span><br><span class="line">  pollingTimer = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="keyword">type</span>: POLLING_STOP,</span><br><span class="line">    payload: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">changePagination</span>(<span class="params">pagination: IPagination</span>): <span class="title">ThunkResult</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</span><br><span class="line">    dispatch(&#123;</span><br><span class="line">      <span class="keyword">type</span>: CHANGE_PAGINATION,</span><br><span class="line">      payload: &#123;</span><br><span class="line">        pagination</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    dispatch(polling())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">changeQuery</span>(<span class="params">query: <span class="built_in">string</span></span>): <span class="title">ThunkResult</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</span><br><span class="line">    dispatch(&#123;</span><br><span class="line">      <span class="keyword">type</span>: CHANGE_QUERY,</span><br><span class="line">      payload: &#123;</span><br><span class="line">        query</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    dispatch(polling())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">changeSort</span>(<span class="params">sort: <span class="built_in">string</span></span>): <span class="title">ThunkResult</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</span><br><span class="line">    dispatch(&#123;</span><br><span class="line">      <span class="keyword">type</span>: CHANGE_SORT,</span><br><span class="line">      payload: &#123;</span><br><span class="line">        sort</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    dispatch(polling())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，涉及到 <strong> 请求参数 </strong> 的几个组件，如筛选项目，分页，搜索等，当它们 dispatch 了一个 action 修改对应的业务状态后，<strong> 还需要手动 dispatch 一个重启轮询的 action 结束上一次轮询，开启下一次轮询 </strong>。</p><p>或许这个场景的复杂程度你觉得也还能接受，但是假想我们有一个更大的项目，或者现在的项目未来会扩展得很大，那么组件势必会越来越多，参与协作的开发者也会越来越多。协作的开发者就需要时刻关注到自己撰写的组件是否会是其他开发者撰写的组件的影响因子，如果是的话，影响有多大，又该怎么处理？</p><blockquote><p>这里提到的组件不单纯指 UI Component，还包括了组件涉及的数据生态。因为绝大部分前端开发者撰写业务组件时，除了 UI，还要实现 UI 涉及的业务逻辑。</p></blockquote><p>我们归纳下使用传统模式梳理数据流以及副作用面临的问题：</p><ol><li><strong> 过程式编程 </strong>，代码啰嗦</li><li><strong> 竞态处理 </strong> 需要人为地通过标志量等进行控制</li><li><strong> 组件间耦合 </strong> 大，彼此牵连。</li></ol><h2 id="FRP-模式与组件自治"><a href="#FRP-模式与组件自治" class="headerlink" title="FRP 模式与组件自治"></a>FRP 模式与组件自治</h2><p>在 FRP 模式下，遵循 <strong>passive</strong> 模式，state 应当被观察和响应，而不是主动获取。因此，redux-observable 从 <a href="https://github.com/redux-observable/redux-observable/blob/master/CHANGELOG.md#100-alpha0-2018-04-04" target="_blank" rel="noopener">1.0</a>  开始，不再推荐使用 <code>store.getState()</code> 进行状态获取，Epic 有了新的函数签名， 第二个参数为 <code>state$</code>：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">action$: Observable&lt;Action&gt;, state$: StateObservable&lt;State&gt;</span>): <span class="title">Observable</span>&lt;<span class="title">Action</span>&gt;</span></span><br></pre></td></tr></table></figure><p>state$ 的引入，让 redux-observable 达到了它的里程碑，现在，我们能在 Redux 中更进一步地实践 FRP。比如下面这个例子（来源自 redux-observable 官方），当 <code>googleDocument</code> 状态变动时，我们就自动存储 google 文档：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> autoSaveEpic = <span class="function">(<span class="params">action$, state$</span>) =&gt;</span></span><br><span class="line">  action$.pipe(</span><br><span class="line">    ofType(AUTO_SAVE_ENABLE),</span><br><span class="line">    exhaustMap(<span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">      state$.pipe(</span><br><span class="line">        pluck(<span class="string">'googleDocument'</span>),</span><br><span class="line">        distinctUntilChanged(),</span><br><span class="line">        throttleTime(<span class="number">500</span>, &#123; <span class="attr">leading</span>: <span class="literal">false</span>, <span class="attr">trailing</span>: <span class="literal">true</span> &#125;),</span><br><span class="line">        concatMap(<span class="function"><span class="params">googleDocument</span> =&gt;</span></span><br><span class="line">          saveGoogleDoc(googleDocument).pipe(</span><br><span class="line">            map(<span class="function"><span class="params">()</span> =&gt;</span> saveGoogleDocFulfilled()),</span><br><span class="line">            catchError(<span class="function"><span class="params">e</span> =&gt;</span> <span class="keyword">of</span>(saveGoogleDocRejected(e)))</span><br><span class="line">          )</span><br><span class="line">        ),</span><br><span class="line">        takeUntil(action$.pipe(</span><br><span class="line">          ofType(AUTO_SAVE_DISABLE)</span><br><span class="line">        ))</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  );</span><br></pre></td></tr></table></figure><p>回过头来，我们还可以将列表页的需求概括为：</p><ul><li>间隔一段时间轮询数据列表</li><li>参数（排序，分页等）变动时，重新发起轮询</li><li>主动进行搜索时，重新发起轮询</li><li>组件卸载时结束轮询</li></ul><p>在 FRP 模式下，我们定义一个轮询 epic：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pollingEpic: Epic = <span class="function">(<span class="params">action$, state$</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> stopPolling$ = action$.ofType(POLLING_STOP)</span><br><span class="line">  <span class="keyword">const</span> params$: Observable&lt;ISearchParam&gt; = state$.pipe(</span><br><span class="line">    map(<span class="function">(<span class="params">&#123;user&#125;: &#123;user: IState&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; pagination, sort, query &#125; = user</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        q: <span class="string">`<span class="subst">$&#123;query ? query + '' :''&#125;</span>language:javascript`</span>,</span><br><span class="line">        language: <span class="string">'javascript'</span>,</span><br><span class="line">        page: pagination.page,</span><br><span class="line">        per_page: pagination.pageSize,</span><br><span class="line">        sort,</span><br><span class="line">        order: EOrder.Desc</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    distinctUntilChanged(isEqual)</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> action$.pipe(</span><br><span class="line">    ofType(LISTEN_POLLING_START, SEARCH),</span><br><span class="line">    combineLatest(params$, <span class="function">(<span class="params">action, params</span>) =&gt;</span> params),</span><br><span class="line">    switchMap(<span class="function">(<span class="params">params: ISearchParam</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> polling$ = merge(</span><br><span class="line">        interval(<span class="number">15</span> * <span class="number">1000</span>).pipe(</span><br><span class="line">          takeUntil(stopPolling$),</span><br><span class="line">          startWith(<span class="literal">null</span>),</span><br><span class="line">          switchMap(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">from</span>(fetch(params)).pipe(</span><br><span class="line">            map(<span class="function">(<span class="params">&#123;data&#125;: ISearchResp</span>) =&gt;</span> (&#123;</span><br><span class="line">              <span class="keyword">type</span>: FETCH_SUCCESS,</span><br><span class="line">              payload: &#123;</span><br><span class="line">                total: data.total_count,</span><br><span class="line">                list: data.items</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;)),</span><br><span class="line">            startWith(&#123;</span><br><span class="line">              <span class="keyword">type</span>: FETCH_START,</span><br><span class="line">              payload: &#123;&#125;</span><br><span class="line">            &#125;),</span><br><span class="line">            catchError(<span class="function">(<span class="params">error: AxiosError</span>) =&gt;</span> of(&#123;</span><br><span class="line">              <span class="keyword">type</span>: FETCH_ERROR,</span><br><span class="line">              payload: &#123;</span><br><span class="line">                error: error.response.statusText</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;))</span><br><span class="line">          )),</span><br><span class="line">          startWith(&#123;</span><br><span class="line">            <span class="keyword">type</span>: POLLING_START,</span><br><span class="line">            payload: &#123;&#125;</span><br><span class="line">          &#125;)</span><br><span class="line">      ))</span><br><span class="line">      <span class="keyword">return</span> polling$</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是对这个 Epic 的一些解释。</p><ul><li>首先我们声明轮询结束流，当轮询结束流有值产生时，轮询会被终止：</li></ul><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> stopPolling$ = action$.ofType(POLLING_STOP)</span><br></pre></td></tr></table></figure><ul><li>参数来源于状态，由于现在状态可观测，我们可以从状态流 <code>state$</code> 派发一个下游 —— <strong> 参数流 </strong>：</li></ul><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> params$: Observable&lt;ISearchParam&gt; = state$.pipe(</span><br><span class="line">  map(<span class="function">(<span class="params">&#123;user&#125;: &#123;user: IState&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; pagination, sort, query &#125; = user</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">// 构造参数 </span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;),</span><br><span class="line">  distinctUntilChanged(isEqual)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><blockquote><p>我们预期参数流都是最新的参数，因此使用了 <code>dinstinctUntilChanged(isEqual)</code> 来判断两次参数的异同</p></blockquote><ul><li>主动进行搜索，或者参数变动时，将创建轮询流（借助到了 <code>combineLatest</code> operator），最终，新的 action 仰仗于数据拉取结果：</li></ul><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> action$.pipe(</span><br><span class="line">  ofType(LISTEN_POLLING_START, SEARCH),</span><br><span class="line">  combineLatest(params$, <span class="function">(<span class="params">action, params</span>) =&gt;</span> params),</span><br><span class="line">  switchMap(<span class="function">(<span class="params">params: ISearchParam</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> polling$ = merge(</span><br><span class="line">      interval(<span class="number">15</span> * <span class="number">1000</span>).pipe(</span><br><span class="line">        takeUntil(stopPolling$),</span><br><span class="line">        <span class="comment">// 自动开始轮询 </span></span><br><span class="line">        startWith(<span class="literal">null</span>),</span><br><span class="line">        switchMap(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">from</span>(fetch(params)).pipe(</span><br><span class="line">          map(<span class="function">(<span class="params">&#123;data&#125;: ISearchResp</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// ... 处理响应 </span></span><br><span class="line">          &#125;),</span><br><span class="line">          startWith(&#123;</span><br><span class="line">            <span class="keyword">type</span>: FETCH_START,</span><br><span class="line">            payload: &#123;&#125;</span><br><span class="line">          &#125;),</span><br><span class="line">          catchError(<span class="function">(<span class="params">error: AxiosError</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">          &#125;)</span><br><span class="line">        )),</span><br><span class="line">        startWith(&#123;</span><br><span class="line">          <span class="keyword">type</span>: POLLING_START,</span><br><span class="line">          payload: &#123;&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      ))</span><br><span class="line">    <span class="keyword">return</span> polling$</span><br><span class="line">  &#125;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>OK，我们现在 <strong> 只需要 </strong> 在数据表格这个容器组件挂载时 dispatch 一个 <code>LISTEN_POLLING_START</code> 事件，即可开始我们的轮询，在其对应的 Epic 中，它完全知道什么时候去结束轮询，什么时候去重启轮询。我们的分页组件，排序选择组件都不再需要关心重启轮询这个需求。例如分页组件的状态变动的 action 就只需要修改状态即可，而不用再去关注轮询：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">changePagination</span>(<span class="params">pagination: IPagination</span>): <span class="title">IAction</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="keyword">type</span>: CHANGE_PAGINATION,</span><br><span class="line">    payload: &#123;</span><br><span class="line">      pagination</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 FRP 模式下，passive 模型让我们观测了 state，声明了轮询的诱因，让轮询收归到了数据表格组件中， 解除了轮询和数据表格与分页，搜索，排序等组件的耦合。实现了数据表格的 <strong> 组件自治 </strong>。</p><p><img src="/2018/08/18/使用_redux-observable_实现组件自治/rxjs_redux_frp.png" alt=""></p><p>总结，利用 FRP 进行副作用处理带来了：</p><ul><li><strong> 声明式地（declarative）</strong> 描述异步任务，代码简洁</li><li>使用 <code>switchMap</code> operator 处理 <strong> 竞态 </strong> 任务</li><li>尽可能减少组件耦合，来达到 <strong> 组件自治 </strong>。利于多人协作的大型工程。</li></ul><p>其带来的利好算是拳拳打到了传统模式的痛处。下图是一个更直观的对比，同样的业务逻辑，靠上的是 redux-saga 实现，考下则是 redux-observable 实现。你一眼就能感受到谁更简洁明了：</p><p><img src="/2018/08/18/使用_redux-observable_实现组件自治/rxjs_redux_saga.jpg" alt=""></p><p><img src="/2018/08/18/使用_redux-observable_实现组件自治/rxjs_redux_observable.jpg" alt=""></p><h2 id="接入-redux-observable"><a href="#接入-redux-observable" class="headerlink" title="接入 redux-observable"></a>接入 redux-observable</h2><p>redux-observable 只是 redux 一个中间件，因此它可以和你现在的 redux-thunk，redux-saga 等共存，redux-observable 的作者你可以渐进地接入 redux-observable 去处理一些复杂的业务逻辑，当你基本熟悉了 RxJS 和 FRP 模式，你会发现它可以做一切。</p><p>后续，考虑到整个工程的风格控制，还是建议只选择一套模型，FRP 在复杂场景下表现力卓著，在简单场景下，也不会大炮打蚊子。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文叙述了如何 redux-observable 1.0 提供的 <code>state$</code>，解耦组件之间的业务关联，实现单个组件的业务自治。</p><p>接下来，将通过一步步实现一个类 redux-observable 中间件，向大家阐述 redux-observable 设计理念和实现原理。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://redux-observable.js.org/docs" target="_blank" rel="noopener">redux-observable official docs</a></li></ul><hr><h2 id="关于本系列"><a href="#关于本系列" class="headerlink" title="关于本系列"></a>关于本系列</h2><ul><li><p>本系列将从介绍 redux-observable 1.0 开始，阐述自己在结合 RxJS 到 Redux 中的心得体会。涉及内容会有 redux-observable 实践介绍，redux-observable 实现原理探究，最后会介绍下自己当前基于 redux-observble + dva architecture 的一个 state 管理框架 reobservable。</p></li><li><p>本系列不是 RxJS 或者 Redux 入门，不再讲述他们的基础概念，宣扬他们的核心优势。如果你搜索 RxJS 不小心进到了这个系列，对 RxJS 和 FRP 程序设计产生了兴趣，那么入门我会推荐：</p><ul><li><a href="https://www.learnrxjs.io/" target="_blank" rel="noopener">learnrxjs.io</a></li><li>Andre Staltz 在 <a href="https://egghead.io/courses/introduction-to-reactive-programming" target="_blank" rel="noopener">egghead.io</a> 上的一系列课程</li><li>程墨的 <a href="https://item.jd.com/12336101.html" target="_blank" rel="noopener">《深入浅出 RxJS》</a></li></ul></li><li><p>本系列更不是教程，只是介绍自己在 Redux 中应用 RxJS 的一些思路，希望更多人能指出当中存在的误区，或者交流更优雅的实践。</p></li><li><p>由衷的感谢实践路上一些师兄的帮助，尤其感谢腾讯云的 questguo 学长在模式上的指导。reobservable 脱胎于腾讯云 questguo 主导的 React 框架 —— TCFF，期待未来 TCFF 的开源。</p></li><li><p>感谢小雨的设计支援。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2018/08/18/使用_redux-observable_实现组件自治/cover.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;使用-redux-observable-实现组件自治&quot;&gt;&lt;a href=&quot;#使用-redux-observable-实现组件自治&quot; class=&quot;headerlink&quot; title=&quot;使用 redux-observable 实现组件自治&quot;&gt;&lt;/a&gt;使用 redux-observable 实现组件自治&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本文是 《使用 RxJS + Redux 管理应用状态》系列第一篇文章，旨在介绍 redux-obervable v1 版本为 React + Redux 带来的组件自治能力。&lt;/p&gt;
&lt;p&gt;本系列的文章地址汇总：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://yoyoyohamapi.me/2018/08/18/%E4%BD%BF%E7%94%A8_redux-observable_%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6%E8%87%AA%E6%B2%BB/&quot;&gt;使用 redux-observable 实现组件自治&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://yoyoyohamapi.me/2018/08/21/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA_redux-observable/&quot;&gt;如何实现一个 redux-observable&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="React" scheme="http://yoyoyohamapi.me/categories/React/"/>
    
    
      <category term="React" scheme="http://yoyoyohamapi.me/tags/React/"/>
    
      <category term="Redux" scheme="http://yoyoyohamapi.me/tags/Redux/"/>
    
      <category term="RxJS" scheme="http://yoyoyohamapi.me/tags/RxJS/"/>
    
  </entry>
  
  <entry>
    <title>callbag，一个有趣的规范</title>
    <link href="http://yoyoyohamapi.me/2018/02/14/callbag/"/>
    <id>http://yoyoyohamapi.me/2018/02/14/callbag/</id>
    <published>2018-02-14T09:23:00.000Z</published>
    <updated>2018-02-14T17:05:28.507Z</updated>
    
    <content type="html"><![CDATA[<h2 id="push-和-pull-模型"><a href="#push-和-pull-模型" class="headerlink" title="push 和 pull 模型"></a>push 和 pull 模型</h2><p>如果你了解 RxJs，在响应式编程中，Observable 和 Obsever 是 push 模型，与之对应的，还有一个 pull 模型：</p><p><img src="https://i.stack.imgur.com/HwvQv.png" alt=""></p><ul><li><strong>Pull（<code>f(): B</code>）</strong>：返回一个值。</li><li><strong>Push（<code>f(x: A): void</code>）</strong>：响应式的，当有值产生时，会发出一个事件，并携带上这个值。订阅了该事件的观察者（Observer）将获得反馈。</li></ul><p>JavaScript 中的 <code>Math.random()</code>、<code>window.outerHeight</code> 等都是 pull 模型：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> height = <span class="built_in">window</span>.outerHeight();</span><br><span class="line"><span class="comment">// 或者是迭代器写法 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">getWindowHeight</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="built_in">window</span>.outerHeight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> iter = getWindowHeight()</span><br><span class="line">iter.next()</span><br></pre></td></tr></table></figure><p>pull 模型包含两个部分：</p><ul><li><strong> 生产者 </strong>：负责生产数据，是数据源</li><li><strong> 消费者 </strong>：负责消费数据，是数据的使用方</li></ul><p>在 pull 模型中，数据是 <strong> 按需索取 </strong> 的。</p><p>再通过 RxJs 看一个 push 模型的例子：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Rx.Observable</span><br><span class="line">    .fromEvent(<span class="built_in">document</span>, <span class="string">'click'</span>)</span><br><span class="line">  .map(<span class="function"><span class="params">event</span> =&gt;</span> <span class="string">`Event time: <span class="subst">$&#123;event.timeStamp&#125;</span>`</span>)</span><br><span class="line">    .subscribe(<span class="function"><span class="keyword">function</span> <span class="title">observer</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>push 模型的组成包含了两个部分：</p><ul><li><strong> 可观察（可监听）对象 </strong>：是数据来源</li><li><strong> 观察者（监听者）</strong>：是数据的使用方</li></ul><p>与 pull 模型不同，观察者 <strong> 不能主动索取数据 </strong>，而是观察数据源，当数据源有数据时，才可消费和使用。</p><p>push 模型有这么一些优点：</p><ul><li><strong> 高度复用的可观察对象 </strong>：通过对源可观察对象使用不同的运算子，可构建出新的可观察对象。</li><li><strong> 延迟执行 </strong>：可观察对象只有被观察者订阅，才会派发数据。</li><li><strong> 声明式、描述未来的代码 </strong>：我们只用声明数据源和数据消费方式，而不用关心数据交付时的细节。</li></ul><p><a href="https://cycle.js.org/" target="_blank" rel="noopener">Cycle.js</a> 的作者 Andre Staltz 长久以来面对一个问题，Cycle.js 及其推荐使用的响应式编程库 <a href="https://github.com/staltz/xstream" target="_blank" rel="noopener">xstream</a> 都是 push 模型的，这让框架的模型和业务代码都受益于 push 模型的优点。但是，实际项目中，我们还是有不少 pull 模型下的需求，Andre Staltz 也开了一个 <a href="https://github.com/cyclejs/cyclejs/issues/581" target="_blank" rel="noopener">issue</a> ，讨论如何更好的使用代码描述 pull 模型。</p><a id="more"></a><h2 id="push-与-pull-可以是同型的"><a href="#push-与-pull-可以是同型的" class="headerlink" title="push 与 pull 可以是同型的"></a>push 与 pull 可以是同型的</h2><p>stalz 看到，我们的 Observable 和 Observer：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Observer &#123;</span><br><span class="line">  next(x): <span class="built_in">void</span>;</span><br><span class="line">  error(e): <span class="built_in">void</span>;</span><br><span class="line">  complete(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Observable &#123;</span><br><span class="line">  subscribe(observer): Subscription;</span><br><span class="line">  unsubsribe(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过函数进行描述：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observable</span>(<span class="params">msgType, msgPayload</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li><code>msgType == 0</code>：payload 是 observer，意味着 observer 向 observable 问好，需要订阅这个 observerble。（subscribe）</li><li><code>msgType == 1</code>：意味着 observer 将取消对 observable 的订阅。（unsubscribe）</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observer</span>(<span class="params">msgType, msgPayload</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>当：</p><ul><li><code>msgType == 1</code>：对应 <code>observer.next(payload)</code>，即 observable 交付数据给 observer，此时 payload 携带了数据。</li><li><code>msgType == 2</code> 且 payload 为 <code>undefined</code>：对应于 <code>observer.complete()</code>。</li><li><code>msgType == 2</code> 且 payload 含有值：对应于 <code>observer.error(payload)</code>，此时 payload 描述了错误。</li></ul><p>进一步概括就是：</p><p><strong>Observer</strong>:</p><ul><li><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">observer</span><span class="params">(<span class="number">1</span>, data)</span></span>: void</span><br></pre></td></tr></table></figure><ul><li>数据交付 ：observable 将数据交付给 observer</li></ul></li><li><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">observer</span><span class="params">(<span class="number">2</span>, err)</span></span>: void</span><br></pre></td></tr></table></figure><ul><li>出错：observable 将错误告知 observer</li></ul></li><li><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">observer</span><span class="params">(<span class="number">2</span>)</span></span>: void</span><br></pre></td></tr></table></figure><ul><li>完成：observable 不再有数据，告知 observer 任务完成</li></ul></li></ul><p><strong>Observable</strong>:</p><ul><li><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">observable</span><span class="params">(<span class="number">0</span>, observer)</span></span>: void</span><br></pre></td></tr></table></figure><ul><li>问好：observer 订阅了 observable</li></ul></li><li><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">observable</span><span class="params">(<span class="number">2</span>)</span></span>: void</span><br></pre></td></tr></table></figure><ul><li>结束：observer 取消对 observable 的订阅</li></ul></li></ul><p>这么概括下来，我们发现，pull 模型也可以进行类似的概括：</p><p><strong>Consumer</strong>：</p><ul><li><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">consumer</span><span class="params">(<span class="number">0</span>, producer)</span></span>: void</span><br></pre></td></tr></table></figure><ul><li>问好：<strong> 在 pull 模型中，producer 需要向 consumer 问好，告诉 consumer 有需要时，从哪里取值 </strong></li></ul></li><li><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">consumer</span><span class="params">(<span class="number">1</span>, data)</span></span>: void</span><br></pre></td></tr></table></figure><ul><li>数据交付：producer 将数据交付给 consumer</li></ul></li><li><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">consumer</span><span class="params">(<span class="number">2</span>, err)</span></span>: void</span><br></pre></td></tr></table></figure><ul><li>出错：producer 将错误告知 consumer</li></ul></li><li><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">consumer</span><span class="params">(<span class="number">2</span>)</span></span>: void</span><br></pre></td></tr></table></figure><ul><li>完成：producer 告知 consumer 任务已完成</li></ul></li></ul><p><strong>Producer</strong>：</p><ul><li><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">producer</span><span class="params">(<span class="number">0</span>, consumer)</span></span>: void</span><br></pre></td></tr></table></figure><ul><li>问好：consumer 确定和哪个 producer 交互</li></ul></li><li><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">producer</span><span class="params">(<span class="number">1</span>, data)</span></span>: void</span><br></pre></td></tr></table></figure><ul><li>数据交付：<strong> 在 pull 模型中，consumer 需要主动向 producer 取值 </strong></li></ul></li><li><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">producer</span><span class="params">(<span class="number">2</span>)</span></span>: void</span><br></pre></td></tr></table></figure><ul><li>结束：consumer 结束了和 producer 的交互</li></ul></li></ul><p>综上，我们发现，push 和 pull 模型是同型的（具有一样的角色和函数签名），因此，可以通过一个规范同时定义二者。</p><h2 id="callbag"><a href="#callbag" class="headerlink" title="callbag"></a>callbag</h2><p>staltz 为 push 和 pull 模型创建了一个名为 callbag 的 <a href="https://github.com/callbag/callbag" target="_blank" rel="noopener">规范</a>，这个规范的内容如下：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">type</span>: <span class="built_in">number</span>, payload?: <span class="built_in">any</span>) =&gt; <span class="built_in">void</span></span><br></pre></td></tr></table></figure><h3 id="定义（Defination）"><a href="#定义（Defination）" class="headerlink" title="定义（Defination）"></a>定义（Defination）</h3><ul><li>Callbag：一个函数，函数签名为： <code>(type: 0 | 1 | 2, payload?: any) =&gt; void</code></li><li>Greet：如果一个 callbag 以 <code>0</code> 为第一个参数被调用，我们就说 <code>该 callbag 被问好了</code>。此时函数执行的操作是： “向这个 callbag 问好”。</li><li>Deliver：如果一个 callbag 以 <code>1</code> 为第一个参数被调用，我们就说 “这个 callbag 正被交付数据”。此时函数执行的操作是：“交付数据给这个 callbag”。</li><li>Terminate：如果一个 callbag 以 <code>2</code> 为第一个参数被调用，我们就说 “这个 callbag 被终止了”。此时函数执行的操作是：“终止这个 callbag”。</li><li>Source：一个负责交付数据的 callbag。</li><li>Sink：一个负责接收（消费）数据的 callbag。</li></ul><h3 id="协议（Protocal）"><a href="#协议（Protocal）" class="headerlink" title="协议（Protocal）"></a>协议（Protocal）</h3><p><strong> 问好（Greets）</strong>: <code>(type: 0, cb: Callbag) =&gt; void</code></p><p>当第一个参数是 <code>0</code>，而第二个参数是另外一个 callbag（即一个函数）的时候，这个 callbag 就被问好了。</p><p><strong> 握手（Handshake）</strong></p><p>当一个 source 被问好，并被作为 payload 传递给了某个 sink，sink <strong> 必须 </strong> 使用一个 callbag payload 进行问好，这个 callbag 可以是他自己，也可以是另外的 callbag。换言之，问好是相互的。相互间的问好被称为 <strong> 握手 </strong>。</p><p><strong> 终止（Termination）</strong>: <code>(type: 2, err?: any) =&gt; void</code></p><p>当第一个参数是 <code>0</code>，而第二个参数要么是 undefined（由于成功引起的终止），要么是任何的真实值（由于失败引起的终止），这个 callbag 就被终止了。</p><p>在握手之后，source <strong> 可能 </strong> 终止掉 sink，sink 也 <strong> 可能 </strong> 会终止掉 source。如果 source 终止了 sink，则 sink <strong> 不应当 </strong> 终止 source，反之亦然。换言之，终止行为 <strong> 不应该 </strong> 是相互的。</p><p><strong> 数据交付（Data delivery）</strong> <code>(type: 1, data: any) =&gt; void</code></p><p>交付次数：</p><ul><li>一个 callbag（source 或者 sink）<strong> 可能 </strong> 会被一次或多次交付数据</li></ul><p>有效交付的窗口：</p><ul><li>一个 callbag <strong> 一定不能 </strong> 在被问好之前被交付数据</li><li>一个 callbag <strong> 一定不能 </strong> 在终止后被交付数据</li><li>一个 sink <strong> 一定不能 </strong> 在其终止了它的 source 后被交付数据</li></ul><h2 id="创建自己的-callbag"><a href="#创建自己的-callbag" class="headerlink" title="创建自己的 callbag"></a>创建自己的 callbag</h2><p>callbag 的组成可以简单归纳为：</p><ul><li>handshake：一次握手过程，source 和 sink 如何握手</li><li>talkback：对讲对象，sink 和 source 正在和谁沟通</li></ul><h3 id="listener（observer）sink"><a href="#listener（observer）sink" class="headerlink" title="listener（observer）sink"></a>listener（observer）sink</h3><ul><li><p><strong> 定义问好过程 </strong>：在问好阶段，可以知道在和谁对讲：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sink</span>(<span class="params">type, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (type === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// sink 收到了来自 source 的问好 </span></span><br><span class="line">    <span class="comment">// 问好的时候确定 source 和 sink 的对讲方式 </span></span><br><span class="line">    <span class="keyword">const</span> talkback = data;</span><br><span class="line">    <span class="comment">// 3s 后，sink 终止和 source 的对讲 </span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> talkback(<span class="number">2</span>), <span class="number">3000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong> 定义数据处理过程 </strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sink</span>(<span class="params">type, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (type === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> talkback = data;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> talkback(<span class="number">2</span>), <span class="number">3000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (type === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong> 定义结束过程 </strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> handle;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sink</span>(<span class="params">type, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (type === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> talkback = data;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> talkback(<span class="number">2</span>), <span class="number">3000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (type === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (type === <span class="number">2</span>) &#123;</span><br><span class="line">        clearTimeout(handle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以再用工厂函数让代码干净一些：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeSink</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> handle;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">sink</span>(<span class="params">type, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (type === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> talkback = data;</span><br><span class="line">      handle = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> talkback(<span class="number">2</span>), <span class="number">3000</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (type === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (type === <span class="number">2</span>) &#123;</span><br><span class="line">      clearTimeout(handle);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="puller（consumer）sink"><a href="#puller（consumer）sink" class="headerlink" title="puller（consumer）sink"></a>puller（consumer）sink</h3><p>puller sink 则可以向 source 主动请求数据：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> handle;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sink</span>(<span class="params">type, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (type === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> talkback = data;</span><br><span class="line">        setInterval(<span class="function"><span class="params">()</span> =&gt;</span> talkback(<span class="number">1</span>), <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (type === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (type === <span class="number">2</span>) &#123;</span><br><span class="line">        clearTimeout(handle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="listenable（observable）source"><a href="#listenable（observable）source" class="headerlink" title="listenable（observable）source"></a>listenable（observable）source</h3><ul><li><p>定义问好过程：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">source</span>(<span class="params">type, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (type === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果 source 收到 sink 的问好，</span></span><br><span class="line">    <span class="comment">// 则 payload 即为 sink，source 可以向 sink 发送数据了 </span></span><br><span class="line">    <span class="keyword">const</span> sink = data;</span><br><span class="line">    setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      sink(<span class="number">1</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 让 source 也和 sink 问好，完成一次握手 </span></span><br><span class="line">  sink(<span class="number">0</span>, <span class="comment">/* talkback callbag here */</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当 sink 想要停止观察，需要让 source 有处理停止的能力，另外，listenable 的 source 不会理会 sink 主动的数据索取。因此，我们这么告知 sink 沟通方式：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">source</span>(<span class="params">type, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (type === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> sink = data;</span><br><span class="line">        <span class="keyword">let</span> handle = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            sink(<span class="number">1</span>, <span class="literal">null</span>);</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> talkback = <span class="function">(<span class="params">type, data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (type === <span class="number">2</span>) &#123;</span><br><span class="line">            clearInterval(handle);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    sink(<span class="number">0</span>, talkback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>优化一下代码可读性：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">source</span>(<span class="params">start, sink</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (start !== <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">let</span> handle = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    sink(<span class="number">1</span>, <span class="literal">null</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">const</span> talkback = <span class="function">(<span class="params">t, d</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (t === <span class="number">2</span>) clearInterval(handle);</span><br><span class="line">  &#125;;</span><br><span class="line">  sink(<span class="number">0</span>, talkback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="pullable（iterable）source"><a href="#pullable（iterable）source" class="headerlink" title="pullable（iterable）source"></a>pullable（iterable）source</h3><p>pullable source 中，值时按照 sink 的需要获取的，因此，只有在 sink 索取值时，source 才需要交付数据：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">source</span>(<span class="params">start, sink</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start !== <span class="number">0</span>) retrun;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">const</span> talkback = <span class="function">(<span class="params">t, d</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= <span class="number">20</span>) sink(<span class="number">1</span>, i++);</span><br><span class="line">            <span class="keyword">else</span> sink(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sink(<span class="number">0</span>, talkback)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建运算子"><a href="#创建运算子" class="headerlink" title="创建运算子"></a>创建运算子</h2><p>借助于 operator，能够不断的构建新的 source，operator 的一般范式为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myOperator = <span class="function"><span class="params">args</span> =&gt;</span> inputSource =&gt; outputSource</span><br></pre></td></tr></table></figure><p>借助于管道技术，我们能一步步的声明新的 source：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">pipe(</span><br><span class="line">  source,</span><br><span class="line">  myOperator(args),</span><br><span class="line">  iterate(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x))</span><br><span class="line">)</span><br><span class="line"><span class="comment">// same as...</span></span><br><span class="line">pipe(</span><br><span class="line">  source,</span><br><span class="line">  inputSource =&gt; outputSource,</span><br><span class="line">  iterate(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x))</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>下面我们创建了一个乘法 operator：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> multiplyBy = <span class="function"><span class="params">factor</span> =&gt;</span> inputSource =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">outputSource</span>(<span class="params">start, outputSink</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start !== <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        inputSource(start, (type, data) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (type === <span class="number">1</span>) &#123;</span><br><span class="line">                outputSink(<span class="number">1</span>, data * factor);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                outputSink(<span class="number">1</span>, data * factor);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">source</span>(<span class="params">start, sink</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start !== <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> handle = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> sink(<span class="number">1</span>, i++), <span class="number">3000</span>);</span><br><span class="line">    <span class="keyword">const</span> talkback = <span class="function">(<span class="params">type, data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (type === <span class="number">2</span>) &#123;</span><br><span class="line">            clearInterval(handle);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sink(<span class="number">0</span>, talkback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> timeout;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sink</span>(<span class="params">type, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (type === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> talkback = data;</span><br><span class="line">        timetout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> talback(<span class="number">2</span>), <span class="number">9000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (type === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'data is'</span>, data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (type === <span class="number">2</span>) &#123;</span><br><span class="line">        clearTimeout(handle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newSource = multiplyBy(<span class="number">3</span>)(source);</span><br><span class="line">newSource(<span class="number">0</span>, sink);</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过 callbag ，我们可以近乎一致的处理 <strong> 数据源和数据源的消费 </strong>：</p><p>例如，下面是 listenable 数据源，我们用 <code>forEach</code> 消费：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;forEach, fromEvent, map, filter, pipe&#125; = <span class="built_in">require</span>(<span class="string">'callbag-basics'</span>);</span><br><span class="line"></span><br><span class="line">pipe(</span><br><span class="line">  fromEvent(<span class="built_in">document</span>, <span class="string">'click'</span>),</span><br><span class="line">  filter(<span class="function"><span class="params">ev</span> =&gt;</span> ev.target.tagName === <span class="string">'BUTTON'</span>),</span><br><span class="line">  map(<span class="function"><span class="params">ev</span> =&gt;</span> (&#123;<span class="attr">x</span>: ev.clientX, <span class="attr">y</span>: ev.clientY&#125;)),</span><br><span class="line">  forEach(<span class="function"><span class="params">coords</span> =&gt;</span> <span class="built_in">console</span>.log(coords))</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>下面则是 pullable 数据源，我们仍可以用 <code>forEach</code> 进行消费：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;forEach, fromIter, take, map, pipe&#125; = <span class="built_in">require</span>(<span class="string">'callbag-basics'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">getRandom</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="built_in">Math</span>.random();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pipe(</span><br><span class="line">  fromIter(getRandom()),</span><br><span class="line">  take(<span class="number">5</span>),</span><br><span class="line">  forEach(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x))</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://staltz.com/why-we-need-callbags.html" target="_blank" rel="noopener">WHY WE NEED CALLBAGS</a></li><li><a href="https://github.com/callbag/callbag" target="_blank" rel="noopener">callbag</a></li><li><a href="https://github.com/callbag/callbag/blob/master/getting-started.md" target="_blank" rel="noopener">Creating your own utilities</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;push-和-pull-模型&quot;&gt;&lt;a href=&quot;#push-和-pull-模型&quot; class=&quot;headerlink&quot; title=&quot;push 和 pull 模型&quot;&gt;&lt;/a&gt;push 和 pull 模型&lt;/h2&gt;&lt;p&gt;如果你了解 RxJs，在响应式编程中，Observable 和 Obsever 是 push 模型，与之对应的，还有一个 pull 模型：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.stack.imgur.com/HwvQv.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Pull（&lt;code&gt;f(): B&lt;/code&gt;）&lt;/strong&gt;：返回一个值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Push（&lt;code&gt;f(x: A): void&lt;/code&gt;）&lt;/strong&gt;：响应式的，当有值产生时，会发出一个事件，并携带上这个值。订阅了该事件的观察者（Observer）将获得反馈。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;JavaScript 中的 &lt;code&gt;Math.random()&lt;/code&gt;、&lt;code&gt;window.outerHeight&lt;/code&gt; 等都是 pull 模型：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; height = &lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.outerHeight();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 或者是迭代器写法 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;* &lt;span class=&quot;title&quot;&gt;getWindowHeight&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.outerHeight;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; iter = getWindowHeight()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;iter.next()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;pull 模型包含两个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt; 生产者 &lt;/strong&gt;：负责生产数据，是数据源&lt;/li&gt;
&lt;li&gt;&lt;strong&gt; 消费者 &lt;/strong&gt;：负责消费数据，是数据的使用方&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 pull 模型中，数据是 &lt;strong&gt; 按需索取 &lt;/strong&gt; 的。&lt;/p&gt;
&lt;p&gt;再通过 RxJs 看一个 push 模型的例子：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Rx.Observable&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    .fromEvent(&lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;click&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  .map(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;event&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;`Event time: &lt;span class=&quot;subst&quot;&gt;$&amp;#123;event.timeStamp&amp;#125;&lt;/span&gt;`&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    .subscribe(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;observer&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;val&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(val);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;push 模型的组成包含了两个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt; 可观察（可监听）对象 &lt;/strong&gt;：是数据来源&lt;/li&gt;
&lt;li&gt;&lt;strong&gt; 观察者（监听者）&lt;/strong&gt;：是数据的使用方&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;与 pull 模型不同，观察者 &lt;strong&gt; 不能主动索取数据 &lt;/strong&gt;，而是观察数据源，当数据源有数据时，才可消费和使用。&lt;/p&gt;
&lt;p&gt;push 模型有这么一些优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt; 高度复用的可观察对象 &lt;/strong&gt;：通过对源可观察对象使用不同的运算子，可构建出新的可观察对象。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt; 延迟执行 &lt;/strong&gt;：可观察对象只有被观察者订阅，才会派发数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt; 声明式、描述未来的代码 &lt;/strong&gt;：我们只用声明数据源和数据消费方式，而不用关心数据交付时的细节。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://cycle.js.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Cycle.js&lt;/a&gt; 的作者 Andre Staltz 长久以来面对一个问题，Cycle.js 及其推荐使用的响应式编程库 &lt;a href=&quot;https://github.com/staltz/xstream&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;xstream&lt;/a&gt; 都是 push 模型的，这让框架的模型和业务代码都受益于 push 模型的优点。但是，实际项目中，我们还是有不少 pull 模型下的需求，Andre Staltz 也开了一个 &lt;a href=&quot;https://github.com/cyclejs/cyclejs/issues/581&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;issue&lt;/a&gt; ，讨论如何更好的使用代码描述 pull 模型。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript 函数式编程" scheme="http://yoyoyohamapi.me/categories/JavaScript-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="JavaScript" scheme="http://yoyoyohamapi.me/tags/JavaScript/"/>
    
      <category term="函数式编程" scheme="http://yoyoyohamapi.me/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Cycle.js 基础 21 讲</title>
    <link href="http://yoyoyohamapi.me/2017/07/30/Cycle.js%20%E5%9F%BA%E7%A1%80%2021%20%E8%AE%B2/"/>
    <id>http://yoyoyohamapi.me/2017/07/30/Cycle.js 基础 21 讲/</id>
    <published>2017-07-30T05:43:00.000Z</published>
    <updated>2018-08-24T16:07:38.206Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.gitbook.com/book/fepatients/cycle-js-21/details" target="_blank" rel="noopener">Gitbook</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.gitbook.com/book/fepatients/cycle-js-21/details&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Gitbook&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="Cycle.js" scheme="http://yoyoyohamapi.me/categories/Cycle-js/"/>
    
    
      <category term="JavaScript" scheme="http://yoyoyohamapi.me/tags/JavaScript/"/>
    
      <category term="函数式编程" scheme="http://yoyoyohamapi.me/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Cycle.js" scheme="http://yoyoyohamapi.me/tags/Cycle-js/"/>
    
  </entry>
  
  <entry>
    <title>2017.03 - 2017.08 的学习总结</title>
    <link href="http://yoyoyohamapi.me/2017/07/27/2017_03-2017_08%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>http://yoyoyohamapi.me/2017/07/27/2017_03-2017_08学习总结/</id>
    <published>2017-07-27T02:48:00.000Z</published>
    <updated>2018-02-14T17:00:29.237Z</updated>
    
    <content type="html"><![CDATA[<p>从今年三月份开始，我在前端的学习路径是：</p><ol><li>JavaScript 函数式编程（Lisp、Haskell 开发者轻喷）</li><li>函数响应式编程：FRP，这一块主要是以学习 Rxjs 为主</li><li>函数式编程和函数响应式编程的应用：这一块主要是以学习 Cycle.js 为主</li></ol><a id="more"></a><p>期间完成过、或者正在完成的一些内容有，这当中有一部分是和我所在前端学习小组 –<a href="https://github.com/FEPatients" target="_blank" rel="noopener">前端病人</a> 一起完成的：</p><ol><li><a href="https://github.com/FEPatients/js-functional-programming-minibook" target="_blank" rel="noopener">JavaScript 函数式编程手札（未完）</a></li><li><a href="https://github.com/FEPatients/with-or-without-fp" target="_blank" rel="noopener">With or without fp – 用函数式编程重构代码</a></li><li><a href="https://www.gitbook.com/book/fepatients/cycle-js-21" target="_blank" rel="noopener">Cycle.js 基础 21 讲</a></li><li><a href="https://fepatients.gitbooks.io/-rxjs-subject/content/" target="_blank" rel="noopener">深入 RxJS 的 Subject</a></li><li><a href="https://github.com/yoyoyohamapi/cyclejs-modal-demo" target="_blank" rel="noopener">Cycle.js 实现一个 Modal</a></li><li><a href="https://github.com/yoyoyohamapi/cyclejs-todomvc" target="_blank" rel="noopener">Cycle.js 实现一个 TodoMvc</a></li><li>使用 Cycle.js 完成了鹅厂封陪 Mini 项目中 Web 前端部分，算是一个有体积的应用了</li></ol><p>这五个月的产出的内容达到了我预设的目标，毕竟在此期间，我还要照顾自己的硕士毕业论文，以及填坑自己的另外一本 Gitbook：<a href="https://www.gitbook.com/book/yoyoyohamapi/mit-ml/details" target="_blank" rel="noopener">斯坦福机器学习笔记</a></p><p>去年分析 underscore 源码、redux 源码，算是把我带入了 JavaScript 函数式编程的大门。函数式编程起码从语法风格来说，会是大势，它未必需要深入的 <a href="https://www.gitbook.com/book/drboolean/mostly-adequate-guide" target="_blank" rel="noopener">mostly-adequate-guide</a> 中的定义各个 Functor 或者 Monad，但是 pure function，pointfree，curring，compose 这些优良特性带来了 Eric Elliot 大神提出的 <strong> 组合式软件编写 </strong>。在目前的一些工程中，我都受益于组合式软件编写，逻辑和副作用开始分离，更多的函数通过基本的函数线性组合产生，我的业务代码，我的工具函数包都变得更加可靠和易于测试。逐渐，我开始用 pointfree 的 ramda 替换掉 pointful 的 lodash。</p><p>七月份最大的兴奋除了正式入职，就是看到了 Cycle.js 中文社区的建立，自己也能加入进去。我一直都更喜欢团队作战，一方面，团队能够约束我个人，不浮躁，另一方面，团队的技术圈子可以带来交流，可以带来目标。技术本就不应该冷静，因为团队，它会变得像人一样火热，即便它会遭受潮水般的质疑，那也胜过人变得冷漠，技术被不闻不问，在冷静中死掉。</p><p>接下来，会首先总结一下这次 Cycle.js 在 Mini 项目中的实战记录，不同于从 jQuery 过渡到 Vue 或者 React 时的小激动，Cycle.js 给了我更多的兴奋点，在使用 Cycle.js 构建前端应用的时候，思路和实现都可以说是颠覆式的。我需要记录下这次过程，希望能分享给他人，也防止记性不好的我再踩一些同样的坑。</p><p>之后，会一直跟进 Cycle.js，跟进 stalz 的动作，跟进 Cycle 中文社区其他的小伙伴，加油。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从今年三月份开始，我在前端的学习路径是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;JavaScript 函数式编程（Lisp、Haskell 开发者轻喷）&lt;/li&gt;
&lt;li&gt;函数响应式编程：FRP，这一块主要是以学习 Rxjs 为主&lt;/li&gt;
&lt;li&gt;函数式编程和函数响应式编程的应用：这一块主要是以学习 Cycle.js 为主&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="JavaScript 函数式编程" scheme="http://yoyoyohamapi.me/categories/JavaScript-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="JavaScript" scheme="http://yoyoyohamapi.me/tags/JavaScript/"/>
    
      <category term="函数式编程" scheme="http://yoyoyohamapi.me/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>斯坦福机器学习笔记</title>
    <link href="http://yoyoyohamapi.me/2017/04/29/%E6%96%AF%E5%9D%A6%E7%A6%8F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoyoyohamapi.me/2017/04/29/斯坦福机器学习笔记/</id>
    <published>2017-04-29T03:45:13.000Z</published>
    <updated>2018-02-14T17:01:25.708Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>系列文章已发布至 <a href="https://www.gitbook.com/book/yoyoyohamapi/mit-ml" target="_blank" rel="noopener">Gitbook</a></p></blockquote><p>本书为斯坦福吴恩达教授的在 coursera 上的 <a href="https://zh.coursera.org/learn/machine-learning" target="_blank" rel="noopener">机器学习公开课</a> 的知识笔记，涵盖了大部分课上涉及到的知识点和内容，因为篇幅有限，部分公式的推导没有记录在案，但推荐大家还是在草稿本上演算一遍，加深印象，知其然还要知其所以然。</p><p>本书涉及到的程序代码均放在了我个人的 <a href="https://github.com/yoyoyohamapi/mit-ml" target="_blank" rel="noopener">github</a> 上，采用了 python 实现，大部分代码都是相关学习算法的完整实现和测试。我没有放这门课程的 homework 代码，原因是 homework 布置的编程作业是填空式的作业，而完整实现一个算法虽然历经更多坎坷，但更有助于检验自己对算法理解和掌握程度。</p><div style="text-align:center"><br><img src="https://yoyoyohamapi.gitbooks.io/mit-ml/content/%E8%AF%81%E4%B9%A6.jpg" width="350"><br></div><a id="more"></a><p>本书的章节安排与课程对应关系为：</p><table><thead><tr><th style="text-align:left">斯坦福课程</th><th style="text-align:left">本书章节</th></tr></thead><tbody><tr><td style="text-align:left">Week 2</td><td style="text-align:left">线性回归</td></tr><tr><td style="text-align:left">Week 3</td><td style="text-align:left">逻辑回归</td></tr><tr><td style="text-align:left">Week 4-5</td><td style="text-align:left">神经网络</td></tr><tr><td style="text-align:left">Week 6</td><td style="text-align:left">算法分析与优化</td></tr><tr><td style="text-align:left">Week 7</td><td style="text-align:left">SVM（支持向量机）</td></tr><tr><td style="text-align:left">Week 8</td><td style="text-align:left">K-Means、特征降维</td></tr><tr><td style="text-align:left">Week 9</td><td style="text-align:left">异常检测、推荐系统</td></tr><tr><td style="text-align:left">Week 10</td><td style="text-align:left">大规模机器学习</td></tr><tr><td style="text-align:left">Week 11</td><td style="text-align:left">案例 – 光学字符识别</td></tr></tbody></table><p>学生我才疏学浅，对机器学习也只是刚刚入门，文中难免不少纰漏甚至严重错误，希望大家指正，这是对我最大的帮助。本书最大的目的也在于交流学习，而不在 star 和传播。任重而道远，你我共勉。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;系列文章已发布至 &lt;a href=&quot;https://www.gitbook.com/book/yoyoyohamapi/mit-ml&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Gitbook&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本书为斯坦福吴恩达教授的在 coursera 上的 &lt;a href=&quot;https://zh.coursera.org/learn/machine-learning&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;机器学习公开课&lt;/a&gt; 的知识笔记，涵盖了大部分课上涉及到的知识点和内容，因为篇幅有限，部分公式的推导没有记录在案，但推荐大家还是在草稿本上演算一遍，加深印象，知其然还要知其所以然。&lt;/p&gt;
&lt;p&gt;本书涉及到的程序代码均放在了我个人的 &lt;a href=&quot;https://github.com/yoyoyohamapi/mit-ml&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;github&lt;/a&gt; 上，采用了 python 实现，大部分代码都是相关学习算法的完整实现和测试。我没有放这门课程的 homework 代码，原因是 homework 布置的编程作业是填空式的作业，而完整实现一个算法虽然历经更多坎坷，但更有助于检验自己对算法理解和掌握程度。&lt;/p&gt;
&lt;div style=&quot;text-align:center&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://yoyoyohamapi.gitbooks.io/mit-ml/content/%E8%AF%81%E4%B9%A6.jpg&quot; width=&quot;350&quot;&gt;&lt;br&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://yoyoyohamapi.me/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://yoyoyohamapi.me/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>一步步写一个 co</title>
    <link href="http://yoyoyohamapi.me/2017/02/03/%E4%B8%80%E6%AD%A5%E6%AD%A5%E5%86%99%E4%B8%80%E4%B8%AA-co/"/>
    <id>http://yoyoyohamapi.me/2017/02/03/一步步写一个-co/</id>
    <published>2017-02-03T11:29:34.000Z</published>
    <updated>2018-02-14T17:01:30.865Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>文章已发布至 <a href="https://www.gitbook.com/book/yoyoyohamapi/-co/details" target="_blank" rel="noopener">GitBook</a></p></blockquote><p>现在，我们有三个 markdown 文件 file1.md,file2.md,file3.md，我们想要统计这三个文件的大小信息，并输出为以下格式：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">file1</span>: <span class="number">5384</span>, <span class="attr">file2</span>: <span class="number">2712</span>, <span class="attr">file3</span>: <span class="number">13942</span>&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>从最传统的回调开始，我们不断优化解决该问题的方式，最后完成了一个简化版的 <a href="https://github.com/tj/co/tree/2.0.0" target="_blank" rel="noopener">co V2</a>，实现了用更优雅地方式来组织和编写异步流程。</p><blockquote><p>本文对应的项目地址，包含了文中所有涉及到的代码片: <a href="https://github.com/yoyoyohamapi/write-a-co" target="_blank" rel="noopener">戳我</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;文章已发布至 &lt;a href=&quot;https://www.gitbook.com/book/yoyoyohamapi/-co/details&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitBook&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在，我们有三个 markdown 文件 file1.md,file2.md,file3.md，我们想要统计这三个文件的大小信息，并输出为以下格式：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;span class=&quot;attr&quot;&gt;file1&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;5384&lt;/span&gt;, &lt;span class=&quot;attr&quot;&gt;file2&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;2712&lt;/span&gt;, &lt;span class=&quot;attr&quot;&gt;file3&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;13942&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="一步步写一个 co" scheme="http://yoyoyohamapi.me/categories/%E4%B8%80%E6%AD%A5%E6%AD%A5%E5%86%99%E4%B8%80%E4%B8%AA-co/"/>
    
    
      <category term="JavaScript" scheme="http://yoyoyohamapi.me/tags/JavaScript/"/>
    
      <category term="co" scheme="http://yoyoyohamapi.me/tags/co/"/>
    
      <category term="ES6" scheme="http://yoyoyohamapi.me/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>underscore 源码分析</title>
    <link href="http://yoyoyohamapi.me/2017/01/01/underscore-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoyoyohamapi.me/2017/01/01/underscore-源码分析/</id>
    <published>2017-01-01T01:19:53.000Z</published>
    <updated>2018-02-14T17:02:24.123Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>文章已发布至 <a href="https://www.gitbook.com/book/yoyoyohamapi/undersercore-analysis" target="_blank" rel="noopener">GitBook</a></p></blockquote><h2 id="写作意图"><a href="#写作意图" class="headerlink" title="写作意图"></a>写作意图</h2><p>起初，我分析 underscore 的源码只是想更深入的了解 <strong> 函数式编程（Functional Programming）</strong>，但分析结束后，我就觉得单纯的源码注释不足以记录我的收获、理解和感悟，所以我想把这些写下来，我粗略地将写作意图概括如下：</p><ul><li><p>函数式编程近些年非常火爆，诸如 haskwell 这样的纯函数式编程语言获得了非常高的社区活跃度。JavaScript 支持多范式编程，抛开 underscore 和 lodash 这样的生来为了函数编程的库不谈，诸如 <a href="https://github.com/reactjs/redux" target="_blank" rel="noopener">redux</a> 这样的库也大量运用了函数式编程，即便作为一个 react+redux 的业务开发者，想要深入理解的 redux 的实现机制，也不得不学习函数式编程。因此，学习函数式编程，将会成为 JavaScript 开发者的必须。</p><p>   在阅读 underscore 的源码期间，被作者 jashkenas（他同时也是 backbone 和 coffee 的作者）的功力深深折服，一些功能可能我也能写出，但绝对写不了如此健壮。所以，深入学习 underscore 源码，不仅有助于我们认识函数式编程，也能深化我们对于 JavaScript 中一些基础知识的理解和掌握。</p><p>   随着 backbone 的衰落和 lodash 的崛起，underscore 的热度已经不及当年，但是截止这篇文章的开始前的一个月，underscore 仍然有最新的 bug 修复，可见作者 jashkenas 仍然没有放弃 underscore 的维护。所以现在分析 underscore 的源码仍然不显得过时。相较于 lodash，underscore 的源码更加短小，也不太涉及 JavaScript 中的一些奇淫巧技，所以，分析 underscore 更加适合 JavaScript 开发者的进阶。在完成了 underscore 的源码分析后，希望我自己有时间，也希望读者有意愿再去分析 lodash 的源码，后者在性能和功能上都已经超越了 underscore，并且长时间霸占了 npm 了最热 package 的位置。</p></li></ul><a id="more"></a><h2 id="章节安排"><a href="#章节安排" class="headerlink" title="章节安排"></a>章节安排</h2><h3 id="underscore-基础篇"><a href="#underscore-基础篇" class="headerlink" title="underscore 基础篇"></a><a href="https://yoyoyohamapi.gitbooks.io/undersercore-analysis/content/base/" target="_blank" rel="noopener">underscore 基础篇</a></h3><p>在基础部分，将会阐述 underscore 的大致结构及一些广泛用到的内部函数（internal function），这些函数被大量用到了 underscore 的 API 实现中，是我们之后理解 underscore 源码的必须途径。</p><p>之后，我们按照官方 API 文档的顺序来阐述 underscore 的源码实现，由于很多 API 的实现可以举一反三，所以，本书并不会啰嗦的阐述每个 API 的实现，如果真的由此需求，可以配合我写的 <a href="https://github.com/yoyoyohamAPI/underscore/blob/master/underscore.analysis.js" target="_blank" rel="noopener">underscore 中文注释</a> 辅助阅读。</p><h3 id="underscore-集合篇"><a href="#underscore-集合篇" class="headerlink" title="underscore 集合篇"></a><a href="https://yoyoyohamapi.gitbooks.io/undersercore-analysis/content/collection/" target="_blank" rel="noopener">underscore 集合篇</a></h3><p>不同于数学当中的集合，在 underscore 中，简单地定义集合为 <strong> 一个可迭代的序列 </strong>，相较于原生的 ES5 提供的迭代方法，underscore 不仅能够对数组进行迭代，还能够对对象进行迭代。</p><h3 id="underscore-数组篇"><a href="#underscore-数组篇" class="headerlink" title="underscore 数组篇"></a><a href="https://yoyoyohamapi.gitbooks.io/undersercore-analysis/content/array/" target="_blank" rel="noopener">underscore 数组篇</a></h3><p>这一章节我们将介绍 underscore 中提供的针对数组的操作，部分 API 已经在集合篇中有过阐述，不再赘述。</p><h3 id="underscore-函数篇"><a href="#underscore-函数篇" class="headerlink" title="underscore 函数篇"></a><a href="https://yoyoyohamapi.gitbooks.io/undersercore-analysis/content/function/" target="_blank" rel="noopener">underscore 函数篇</a></h3><p>在 JavaScript 中，函数是第一型的对象，函数在 JavaScript 中的地位因此可见一斑。这一章节也是我认为最为重要的一章，在本章中，能够见到许多实用的针对函数的操作，以及函数式编程中的重要概念。</p><h3 id="underscore-对象篇"><a href="#underscore-对象篇" class="headerlink" title="underscore 对象篇"></a><a href="https://yoyoyohamapi.gitbooks.io/undersercore-analysis/content/object/" target="_blank" rel="noopener">underscore 对象篇</a></h3><p>本章中，将介绍 underscore 中操作对象的 API。</p><h3 id="underscore-实用工具篇"><a href="#underscore-实用工具篇" class="headerlink" title="underscore 实用工具篇"></a><a href="https://yoyoyohamapi.gitbooks.io/undersercore-analysis/content/utils/" target="_blank" rel="noopener">underscore 实用工具篇</a></h3><p>underscore 还提供了不少工具函数，来提供一些周边功能，如字符逃逸等。但其中最重要的是其提供的模板引擎工具，我将会花费很大笔墨对其进行描述。</p><h3 id="underscore-内容拾遗"><a href="#underscore-内容拾遗" class="headerlink" title="underscore 内容拾遗"></a><a href="https://yoyoyohamapi.gitbooks.io/undersercore-analysis/content/supply/" target="_blank" rel="noopener">underscore 内容拾遗</a></h3><p>最后，在收尾阶段，我们还会介绍 underscore 提供的面向对象风格（OOP Style），链式调用（Chain）等内容。</p><h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><p>本文基于 underscore 的 <a href="https://github.com/jashkenas/underscore/tree/1.8.3" target="_blank" rel="noopener">1.8.3 版本</a> 进行分析, 在阅读官方文档时遇到的困难时，特别感谢 <a href="http://www.css88.com/doc/underscore/" target="_blank" rel="noopener">underscore 中文教程</a> 提供的帮助。</p><blockquote><p>欢迎转载或者引用，但请注明出处，这算是对我工作成果的认可和尊重。也欢迎拍砖，相应问题可以发到 <a href="https://www.gitbook.com/book/yoyoyohamAPI/undersercore-analysis/discussions" target="_blank" rel="noopener">discussion</a>，我会最快时间进行更正或者解答。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;文章已发布至 &lt;a href=&quot;https://www.gitbook.com/book/yoyoyohamapi/undersercore-analysis&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitBook&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;写作意图&quot;&gt;&lt;a href=&quot;#写作意图&quot; class=&quot;headerlink&quot; title=&quot;写作意图&quot;&gt;&lt;/a&gt;写作意图&lt;/h2&gt;&lt;p&gt;起初，我分析 underscore 的源码只是想更深入的了解 &lt;strong&gt; 函数式编程（Functional Programming）&lt;/strong&gt;，但分析结束后，我就觉得单纯的源码注释不足以记录我的收获、理解和感悟，所以我想把这些写下来，我粗略地将写作意图概括如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;函数式编程近些年非常火爆，诸如 haskwell 这样的纯函数式编程语言获得了非常高的社区活跃度。JavaScript 支持多范式编程，抛开 underscore 和 lodash 这样的生来为了函数编程的库不谈，诸如 &lt;a href=&quot;https://github.com/reactjs/redux&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;redux&lt;/a&gt; 这样的库也大量运用了函数式编程，即便作为一个 react+redux 的业务开发者，想要深入理解的 redux 的实现机制，也不得不学习函数式编程。因此，学习函数式编程，将会成为 JavaScript 开发者的必须。&lt;/p&gt;
&lt;p&gt;   在阅读 underscore 的源码期间，被作者 jashkenas（他同时也是 backbone 和 coffee 的作者）的功力深深折服，一些功能可能我也能写出，但绝对写不了如此健壮。所以，深入学习 underscore 源码，不仅有助于我们认识函数式编程，也能深化我们对于 JavaScript 中一些基础知识的理解和掌握。&lt;/p&gt;
&lt;p&gt;   随着 backbone 的衰落和 lodash 的崛起，underscore 的热度已经不及当年，但是截止这篇文章的开始前的一个月，underscore 仍然有最新的 bug 修复，可见作者 jashkenas 仍然没有放弃 underscore 的维护。所以现在分析 underscore 的源码仍然不显得过时。相较于 lodash，underscore 的源码更加短小，也不太涉及 JavaScript 中的一些奇淫巧技，所以，分析 underscore 更加适合 JavaScript 开发者的进阶。在完成了 underscore 的源码分析后，希望我自己有时间，也希望读者有意愿再去分析 lodash 的源码，后者在性能和功能上都已经超越了 underscore，并且长时间霸占了 npm 了最热 package 的位置。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="underscore 源码分析" scheme="http://yoyoyohamapi.me/categories/underscore-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="JavaScript" scheme="http://yoyoyohamapi.me/tags/JavaScript/"/>
    
      <category term="函数式编程" scheme="http://yoyoyohamapi.me/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>thunkify</title>
    <link href="http://yoyoyohamapi.me/2016/08/02/thunkify/"/>
    <id>http://yoyoyohamapi.me/2016/08/02/thunkify/</id>
    <published>2016-08-02T03:03:08.000Z</published>
    <updated>2018-02-14T17:02:19.476Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>自己之前曾经撸过一个验证库，代码大致如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">validate</span>(<span class="params">data, rules, cb</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ....</span></span><br><span class="line">  <span class="comment">// 一切完成后会触发回调函数</span></span><br><span class="line">  cb(<span class="literal">null</span>, errMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>出于性能上的考虑，该库被封装为了一个异步函数，需要提供一个回调函数 <code>cb</code> 来获得验证结果，该回调函数是一个满足 node 规范的 <strong>error-first callback</strong>。在其他系统中，该库使用良好，但是，新项目使用了 koa，我在中间件中使用这个库提供的 <code>validate</code> 方法， 却连编译期都没有通过：</p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> validator = <span class="built_in">require</span>(<span class="string">'../libs/validator'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> *(<span class="params">next</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 获得请求体</span></span><br><span class="line">        <span class="keyword">const</span> body = <span class="keyword">this</span>.request.body;</span><br><span class="line">        <span class="comment">// 获得规则</span></span><br><span class="line">        <span class="keyword">const</span> rules = getRules(<span class="keyword">this</span>.request.url);</span><br><span class="line">        <span class="keyword">if</span> (rules) &#123;</span><br><span class="line">          validator.validate(body, rules, (error, errMap) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> errors = <span class="built_in">Object</span>.keys(errMap).reduce(<span class="function">(<span class="params">errors, key</span>) =&gt;</span> &#123;</span><br><span class="line">                  <span class="keyword">const</span> value = errMap 连[key];</span><br><span class="line">                  <span class="keyword">if</span> (value.error) &#123;</span><br><span class="line">                      errors.push(<span class="string">` 参数 [<span class="subst">$&#123;key&#125;</span>] 的规则 [\'<span class="subst">$&#123;value.msg&#125;</span>\'] 不通过 `</span>);</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">return</span> errors;</span><br><span class="line">              &#125;, []);</span><br><span class="line">              <span class="keyword">if</span> (errors.length) &#123;</span><br><span class="line">                  logger.error(<span class="string">` 参数校验失败:<span class="subst">$&#123;errors.toString()&#125;</span>`</span>);</span><br><span class="line">                  <span class="keyword">const</span> error = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">` 参数校验失败:<span class="subst">$&#123;errors.toString()&#125;</span>`</span>);</span><br><span class="line">                  error.status = <span class="number">400</span>;</span><br><span class="line">                  <span class="keyword">this</span>.throw(error);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// ！注意，我在回调函数中使用了 yield</span></span><br><span class="line">                  <span class="keyword">yield</span> next;</span><br><span class="line">              &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">yield</span> next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>查阅了 <a href="http://tc39wiki.calculist.org/es6/arrow-functions/" target="_blank" rel="noopener"> ECMAScript Wiki </a> 知道，<code>yield</code> 关键字并不能在箭头函数中使用。一再探索解决渠道的时候，我有两个考虑，一方面，<code>yield</code> 是使用 koa 中间件时绕不开的。另一方面，我也不想去改造库，这样必然会影响到其他系统。</p><h2 id="thunk"><a href="#thunk" class="headerlink" title="thunk"></a>thunk</h2><p>解决该问题的方法就是将我们原有库的 API 包装成一个 thunk，该 thunk 大致形态如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">thunk</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    cb(err, data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>thunk</code> 返回的函数接收一个回调函数 <code>cb(error, data)</code>。同样地，该函数是一个 <strong>error-first callback</strong>。现在，在 koa 中间件中，我们就能这样使用 <code>thunk</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// data 源于回调的第二个参数 `data`</span></span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">yield</span> thunk();</span><br><span class="line">&#125; <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">  <span class="comment">// error handling: 其中错误来源于回调的第一个参数 `error`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>所以，我们可以这样包装我们的 <code>validate</code> 方法，使 <code>validate</code> 方法 thunk 化：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> thunkedValidate = <span class="function"><span class="keyword">function</span>(<span class="params">data, rules</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> validator.validate(data, rules, cb);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们能在中间件顺畅的使用 API 了，并且代码更加直观：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 获得请求体</span></span><br><span class="line"><span class="keyword">const</span> body = <span class="keyword">this</span>.request.body;</span><br><span class="line"><span class="comment">// 获得规则</span></span><br><span class="line"><span class="keyword">const</span> rules = getRules(<span class="keyword">this</span>.request.url);</span><br><span class="line"><span class="keyword">if</span> (rules) &#123;</span><br><span class="line">  <span class="keyword">const</span> errMap = <span class="keyword">yield</span> thunkedValidate(body, rules);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>上面我们改造 <code>validate</code> 的做法并不通用，如果我们还想改造其他 API，逐个封装显然容易让人疲惫不堪。借助于高阶函数，我们能够封装一个通用的方法用来 thunk 化一个函数，我们将其命名为 <code>thunkify</code>，他的大致结构如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接受一个函数, 返回一个 thunk</span></span><br><span class="line"><span class="comment"> * @param func 原函数</span></span><br><span class="line"><span class="comment"> * @return Function thunk</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">thunkify</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回一个 thunk</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再分析下，将一个函数改造为返回一个 thunk 的过程：</p><ol><li>获得原函数的参数，比如上例中的 <code>data</code>、<code>rules</code></li><li>新建一个高阶函数，该函数以这些参数作为参数，并且返回一个 thunk，在 thunk 中，才是我们运行 API 的过程：</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">data, rules</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> thunk(done)&#123;</span><br><span class="line">    <span class="comment">// 通常，回调函数是最后一个传入的函数</span></span><br><span class="line">    validator.validate(rules, data, ()=&gt; &#123;&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了更加通用，在 <code>thunkify</code> 中，我们创建的高阶函数不再显式声明需要的参数，而是借助于 <code>arguments</code> 来捕获参数：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">thunkify</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 获得参数，借助闭包保存</span></span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 thunk</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 追加 `cb` 到 args 中</span></span><br><span class="line">      args.push(<span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>)</span>&#123;</span><br><span class="line">        cb.call(<span class="keyword">this</span>, err, data);</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">// 调用 api， 完成逻辑</span></span><br><span class="line">      func.apply(<span class="keyword">this</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试一下，用例我参考的<a href="https://github.com/tj/node-thunkify" target="_blank" rel="noopener"> node-thunkify </a>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params">name, fn</span>) </span>&#123;</span><br><span class="line">  fn(<span class="literal">null</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">thunked = thunkify(load);</span><br><span class="line"></span><br><span class="line">thunked(<span class="string">'wxj'</span>)(<span class="function"><span class="keyword">function</span>(<span class="params">err, name</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;); <span class="comment">// 'wxj'</span></span><br></pre></td></tr></table></figure><h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><p>再看下面的一个测试 ：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  fn(<span class="literal">null</span>, <span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> user = &#123;</span><br><span class="line">  name: <span class="string">'wxj'</span>,</span><br><span class="line">  load: thunkify(load)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user.load()(<span class="function"><span class="keyword">function</span>(<span class="params">err, name</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></p><p>没有按照预期的输出 <code>&#39;wxj&#39;</code>，因为我们的 <code>thunkify</code> 忘记考虑绑定执行上下文了，在原始的 API 执行时：</p><figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span>;</span></span><br></pre></td></tr></table></figure><p>其对应的 <code>this</code> 应该是 <code>func()</code> 执行时所处的上下文。所以，我们优化 <code>thunkify</code>，让 thunk 化 的 API 能获得正确的执行上下文：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">thunkify</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 获得参数，借助闭包保存</span></span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 缓存上下文</span></span><br><span class="line">    <span class="keyword">var</span> ctx = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 返回 thunk</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 追加 `cb` 到 args 中</span></span><br><span class="line">      args.push(<span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>)</span>&#123;</span><br><span class="line">        cb.call(<span class="keyword">this</span>, err, data);</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">// 调用 API，使用缓存了的上下文</span></span><br><span class="line">      func.apply(ctx, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再跑一下上面的用例， 成功输出了 <code>&#39;wxj&#39;</code>。</p><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><hr><p>假定，我们 API 是会抛出错误的，那么在 API 的执行过程中捕获到错误时，我们就应当向 <code>cb</code> 中注入该错误：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">thunkify</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 获得参数，借助闭包保存</span></span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 缓存上下文</span></span><br><span class="line">    <span class="keyword">var</span> ctx = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 返回 thunk</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 追加 `cb` 到 args 中</span></span><br><span class="line">      args.push(<span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>)</span>&#123;</span><br><span class="line">        cb.call(<span class="keyword">this</span>, err, data);</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">// 调用 API，完成逻辑</span></span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">        func.apply(ctx, args);</span><br><span class="line">      &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        cb(e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试一下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'boom'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">load = thunkify(load);</span><br><span class="line"></span><br><span class="line">load()(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们封装了一个大致可用的 thunkify 函数，也再次体会了 JavaScript 多范式编程的魅力和高阶函数的强大。不过，在实际生产环境中，还是推荐使用更健壮的<a href="https://github.com/tj/node-thunkify" target="_blank" rel="noopener"> node-thunkify </a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h2&gt;&lt;p&gt;自己之前曾经撸过一个验证库，代码大致如下：&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;validate&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;data, rules, cb&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// ....&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 一切完成后会触发回调函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  cb(&lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;, errMap);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;出于性能上的考虑，该库被封装为了一个异步函数，需要提供一个回调函数 &lt;code&gt;cb&lt;/code&gt; 来获得验证结果，该回调函数是一个满足 node 规范的 &lt;strong&gt;error-first callback&lt;/strong&gt;。在其他系统中，该库使用良好，但是，新项目使用了 koa，我在中间件中使用这个库提供的 &lt;code&gt;validate&lt;/code&gt; 方法， 却连编译期都没有通过：&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript 学习笔记" scheme="http://yoyoyohamapi.me/categories/JavaScript-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="http://yoyoyohamapi.me/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>使用 ES6 中的 generator 来优化异步过程</title>
    <link href="http://yoyoyohamapi.me/2016/08/01/%E4%BD%BF%E7%94%A8-ES6-%E4%B8%AD%E7%9A%84-generator-%E6%9D%A5%E4%BC%98%E5%8C%96%E5%BC%82%E6%AD%A5%E8%BF%87%E7%A8%8B%EF%BC%88%E7%BF%BB%E8%AF%91%E5%8F%8A%E8%A1%A5%E5%85%85%EF%BC%89/"/>
    <id>http://yoyoyohamapi.me/2016/08/01/使用-ES6-中的-generator-来优化异步过程（翻译及补充）/</id>
    <published>2016-08-01T11:58:27.000Z</published>
    <updated>2018-02-14T17:01:21.492Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文：<a href="https://davidwalsh.name/async-generators" target="_blank" rel="noopener">Going Async With ES6 Generators</a> 本文在作者文章的基础上，适当补充了一些代码及说明</p></blockquote><p>ES6 中的 generator 能够帮助我们提供一种类似同步一样的代码风格，来将异步过程的具体实现隐藏。这样的好处就是我们能够更加自然的表达自己的业务流程（work flow），而避免陷入异步的麻烦中。换言之，借助于 generator，我们既拥有了异步执行的能力，又不用再绞尽脑汁的去维护异步代码。</p><p>继续阅读本文，你会发现这么做的结果简直太美妙了，以前那些糟糕的异步代码现在讲会向同步代码那样变得 <strong> 易于阅读 </strong> 和 <strong> 可维护 </strong>。需要知道的是，这个同步只是代码风格上的同步，他的执行过程仍然是异步的。</p><p>说了那么多，仍然有些抽象，现在我们由浅入深地看看到底怎么通过 ES6 来优化异步过程。</p><a id="more"></a><h2 id="一个最简单的异步"><a href="#一个最简单的异步" class="headerlink" title="一个最简单的异步"></a>一个最简单的异步</h2><p>假设我们的程序原来拥有这样的异步代码，这是最为朴实和原始的 JavaScript 异步流程控制：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeAjaxCall</span>(<span class="params">url,cb</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do some ajax fun</span></span><br><span class="line">    <span class="comment">// call `cb(result)` when complete</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">makeAjaxCall( <span class="string">"http://some.url.1"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">result1</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse( result1 );</span><br><span class="line"></span><br><span class="line">    makeAjaxCall( <span class="string">"http://some.url.2/?id="</span> + data.id, <span class="function"><span class="keyword">function</span>(<span class="params">result2</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> resp = <span class="built_in">JSON</span>.parse( result2 );</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">"The value you asked for:"</span> + resp.value );</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以看到，对于一次异步请求，我们获取异步结果的过程放到了回调当中。然而，借助 generator 来完成相同的任务：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 我们将真正的异步功能掩藏在 `request` 中，这样我们在 generator 中能专注同步写法</span></span><br><span class="line">    <span class="comment">// 通过 `it.next(..)` 来获得异步结果，并让 generator 的流程继续</span></span><br><span class="line">  makeAjaxCall(url, (result)=&gt;&#123;</span><br><span class="line">    it.next(result);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 注意，这里没有返回任何值，也就是说 `request()` 的执行结果会返回 `undefined`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 在 generator 中，我们的异步处理流程摇身一变成了同步执行过程</span></span><br><span class="line">  <span class="keyword">const</span> result1 = <span class="keyword">yield</span> request(<span class="string">'http://some.url.1'</span>);</span><br><span class="line">  <span class="keyword">const</span> data =  <span class="built_in">JSON</span>.parse(result1);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> result2 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.2?id="</span> + data.id );</span><br><span class="line">    <span class="keyword">const</span> resp = <span class="built_in">JSON</span>.parse( result2 );</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">"The value you asked for:"</span> + resp.value );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `main()` 方法执行后，generator 进入暂态，当 `makAjaxCall` 异步任务完成后，会让 `main()` 继续</span></span><br><span class="line">it = main();</span><br><span class="line">it.next();</span><br></pre></td></tr></table></figure><p>可以看到，generator 函数 <code>*main(..)</code> 自身非常纯净，我们在其中撰写业务流程就像我们在 PHP 或者 Java 等语言撰写业务流程，看不到任何的回调。</p><p>下面解释一下以上代码片是如何工作的：</p><p>helper 函数 <code>request(..)</code> 简单的包裹了异步任务 <code>makeAjaxCall(..)</code>，一旦 <code>makeAjaxCall(..)</code> 取得了结果，就调用 generator 迭代器的 <code>next(..)</code> 方法使 generator 继续运行。</p><p>当 <code>*main</code> 运行到 <code>yield ..</code> 后，他会被暂停在 <code>yield</code> 发生的位置，直到遇到了在 <code>makeAjaxCall(..)</code> 的回调中声明的 <code>it.next(..)</code> 才会继续执行。注意到，我们把 Ajax 请求到的结果 <code>result</code> 传递给了 <code>it.next(..)</code>，那么之后，<code>result</code> 就会被返回到的 <code>*main</code> 暂停了的位置，作为 <code>yield ..</code> 表达式的输出，所以，<code>result1</code> 不会是 <code>undefined</code>（默认情况下，<code>yield</code> 返回 <code>undefined</code>），而是拿到的异步结果。</p><p>这就是真正牛逼的地方。语句 <code>result1 = yield request(..)</code> 所表达的意图是要去请求一个值，但是，这个请求过程却被隐藏了。利用 <code>yield</code> 实现 <strong> 暂停 </strong> 功能，然后将 <strong> 继续 </strong> 功能放到 generator 函数以外地方，更准确地说，是放到了 generator 以外的异步回调中，从而保证了我们能够在 generator 中利用 <strong> 同步 </strong> 方式撰写业务流程。</p><blockquote><p><strong> 暂停 - 继续 </strong> 这样串行执行的过程模拟了 <strong> 同步 </strong> 的过程，使得这条语句在语法风格上实现了同步，但其内部实现又是异步的。</p></blockquote><p>别高兴的太早，上面的代码还存在一些问题。在上面的代码中，我们总是执行一个异步 Ajax 调用，但是，如果我们之后将 Ajax 的返回结果缓存到了内存来提升性能，这意味着我们下一次请求不再需要去服务端获得数据，而可以立即从内存上获取。为了满足这个需求，我们可能就会将代码改成如下形式:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cache = &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(cache[url]) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      it.next(cacheUrl);</span><br><span class="line">    &#125;,<span class="number">0</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    makeAjaxCall(url, (resp)=&gt;&#123;</span><br><span class="line">      it.next(resp);</span><br><span class="line">      cache[url] = resp;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：这里用到了 <code>setTimeout(..0)</code> 这个小技巧来强行进入异步过程，如果我们直接调用 <code>it.next(cacheUrl)</code>，就会出错，原因在于执行语句 <code>yield request(..)</code> 时，我们先执行 <code>request(..)</code>，之后 generator 函数才会暂停（后执行 <code>yield</code> ）。所以，如果我们直接调用 <code>it.next(cacheUrl)</code>，则流程如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">next()-&gt;request()-&gt;next()</span><br></pre></td></tr></table></figure><p>由于此时 generator 已经运行了，程序会抛出错误 <code>Generator is already running</code>。而通过 <code>setTimeout(..0)</code> 包裹后，我们的执行流程如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">next()-&gt;request()-&gt;yield-&gt;next()-&gt; 继续</span><br></pre></td></tr></table></figure><p>整个业务才能继续执行。</p><p>现在，我们的 generator 是这样的:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> result1 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.1"</span> );</span><br><span class="line"><span class="keyword">const</span> data = <span class="built_in">JSON</span>.parse( result1 );</span><br></pre></td></tr></table></figure><p>牛逼吧？尽管我们新添加了缓存的逻辑，但丝毫不影响我们的 generator 函数，仍旧是在专心的写业务。在 <code>*main()</code> 中，其过程仍然是非常清晰的业务流：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">请求值 --&gt; 暂停（等待请求完成）--&gt; 获得值 --&gt; 继续</span><br></pre></td></tr></table></figure><blockquote><p>在该场景下，暂停的持续时间变得很微妙，他可能很长（比如向服务器请求值），也可能很短（比如从内存缓存中请求值），但在我们的 <code>*main()</code> 中，还是只关注工作流（flow），无论异步过程的实现细节是否变得复杂。</p></blockquote><h2 id="更好的异步流程控制"><a href="#更好的异步流程控制" class="headerlink" title="更好的异步流程控制"></a>更好的异步流程控制</h2><p>上面的代码已经满足了一些简单的异步场景。但是很快，他的功能就会显得捉襟见肘，我们需要一个更加强大的异步机制来结合我们的 generator 去满足更大的业务场景。这个机制就是 <strong>Promises</strong>。</p><blockquote><p>对于 ES6 中 Promise 尚存疑惑的读者可以看下作者关于此的<a href="http://blog.getify.com/promises-part-1/" target="_blank" rel="noopener">博客</a>。</p></blockquote><p>首先，我们反思一下之前的设计缺陷：</p><ul><li>缺乏清晰的错误处理</li></ul><p>在 <a href="https://davidwalsh.name/es6-generators-dive#error-handling" target="_blank" rel="noopener">作者之前撰写的文章</a> 中，我们能够知道一些在 Ajax 调用过程中检测错误的手段：通过 <code>it.throw(..)</code> 将错误返回的 generator 中，而在 generator 中，我们又通过 <code>try..catch</code> 来俘获错误，进行错误处理:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  makeAjaxCall(url, (err,result)=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) it.throw(err);</span><br><span class="line">    <span class="keyword">else</span> it.next(result);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> result1 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.1"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">"Error:"</span> + err );</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="built_in">JSON</span>.parse( result1 );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> result2 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.2?id="</span> + data.id );</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">"Error:"</span> + err );</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> resp = <span class="built_in">JSON</span>.parse( result2 );</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">"The value you asked for:"</span> + resp.value );</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure><p>这样做的坏处就是，我们把错误抛出耦合到了 Ajax 流程中，设想，我们有还有其他的 generator 也用到了 <code>request(..)</code>，我们的错误控制就会变成这样：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    makeAjaxCall(url, (err,result)=&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span>(err) &#123;</span><br><span class="line">            it1.throw(err);</span><br><span class="line">            it2.throw(err);</span><br><span class="line">            it3.throw(err);</span><br><span class="line">            <span class="comment">// ..</span></span><br><span class="line">            itn.throw(err);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这使得 <code>request(..)</code> 难以复用。</p><ul><li>如果 <code>makeAjaxCall(..)</code> 是一个并不受我们的控制的第三方库</li></ul><p>我们如果要在其中做诸如 <code>it.next(..)</code> 这样对 generator 的控制，就不得不修改这个库的实现，耗费人力不说，随意破坏第三方库也会使得代码难以移植。</p><ul><li>并行任务。</li></ul><p>由于 generator 中的 <code>yield</code> 是一个单步暂停点，同一时刻就只能跑一个任务。所以，我们渴望一个新的方式去执行并行任务，并且不需要太多的人工介入。</p><p>要解决上述的问题就需要我们探索新的设计模式了，结合这个新的设计模式，能让我们的基于 generator 的异步过程变得更加优雅。这个新的设计模式将会引入 <strong>Promise</strong>，其流程大致如下：</p><p><code>yield</code> 一个 Promise 对象后暂停，直至这些 Promise 对象被 <strong> 履行（fulfill）</strong> 的时候才继续我们的 generator。由于并行的 <code>Promise.all([..])</code> 也是一个 Promise 对象，所以在这种设计模式下，也能执行并行任务。</p><p>让我们对之前的 <code>request(..)</code> 函数加以修改，使之基于 Promise：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">      <span class="comment">// 现在，`makeAjaxCall(..)` 不再耦合 `it.next(..)`</span></span><br><span class="line">        makeAjaxCall( url, (result)=&gt;resolve(result));</span><br><span class="line">    &#125; );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>request(..)</code> 构造了一个 Promise 对象并返回，该 Promise 对象将会在 Ajax 请求完成后被 resolved。现在，generator 中的 <code>yield</code> 最终也将产出这个 Promise 对象。我们还需要一个工具函数来控制我们的 generator 的迭代器，完成我们 generator 函数的自动执行。我们暂且将这个工具函数称之为 <code>runGenerator(..)</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// `runGenerator` 函数将运行一个 generator 函数 `g` 直至其完成</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runGenerator</span>(<span class="params">g</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> it = g(), ret;</span><br><span class="line">    <span class="comment">// 执行迭代过程的函数，首次立即执行的目的是为了启动 generator</span></span><br><span class="line">    (<span class="function"><span class="keyword">function</span> <span class="title">iterate</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 获得最近迭代结果, 启动时 val 是 undefined</span></span><br><span class="line">        ret = it.next( val );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 generator 没有执行完毕</span></span><br><span class="line">        <span class="keyword">if</span> (!ret.done) &#123;</span><br><span class="line">            <span class="comment">// 是否 `ret` 仍然是一个 Promise 对象，如果是，意味着 generator 还在不断 yield</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"then"</span> <span class="keyword">in</span> ret.value) &#123;</span><br><span class="line">                <span class="comment">// 将 `iterate(val)` 注册为该 Promise 的 `then(..)` 的回调，</span></span><br><span class="line">                <span class="comment">// 借此，获得一个 Promise 链</span></span><br><span class="line">                ret.value.then( iterate );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果不是 Promise 对象，而是立即数, 将该结果返回</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// avoid synchronous recursion</span></span><br><span class="line">                setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                    iterate( ret.value ); <span class="comment">// 相当于 `it.next(立即数)`</span></span><br><span class="line">                &#125;, <span class="number">0</span> );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以分析一下该工具函数的执行过程： 1. 我们首先初始化了传入的 generator 的迭代器 <code>it</code>，并且创建了一个迭代函数 <code>iterate</code>，该迭代函数用来 <strong> 继续 </strong> generator 的流程，从而让 generator 的自动执行至完毕。 2. 每次我们执行 <code>iterator(val)</code>，就会调用 <code>it.next(val)</code>，并且获得结果 <code>ret</code>。假设我们 generator 中的执行语句是 <code>yield request( &quot;http://some.url.1&quot; )</code>，<code>request(..)</code> 会返回一个 Promise 对象，此时，<code>ret</code> 也就是该 Promise 对象，我们向其 <code>then(..)</code> 方法注册 <code>iterator</code>，使得该 Promise 对象完成后能够进入下一个 Promise 对象的流程，并且每次完成都会继续 generator。 3. 当 <code>iterator(val)</code> 不停流转，直至 <code>val</code> 是一个立即数时，暗示 Promise 链执行完毕，获得了结果，将其返回到 generator 使 generator 得以继续执行。</p><blockquote><p>简言之，结合了 Promise 的 generator 异步流程就是：每次 <code>yield</code> 一个 Promise 进入暂停态，在 Promise 完成后 generator 得以继续执行。</p></blockquote><p>下面我们看看怎么使用 <code>runGenerator</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">runGenerator( <span class="function"><span class="keyword">function</span> *<span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result1 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.1"</span> );</span><br><span class="line">    <span class="keyword">const</span> data = <span class="built_in">JSON</span>.parse( result1 );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> result2 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.2?id="</span> + data.id );</span><br><span class="line">    <span class="keyword">const</span> resp = <span class="built_in">JSON</span>.parse( result2 );</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">"The value you asked for:"</span> + resp.value );</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure><p>简直碉堡了，有没有！我们的业务逻辑仍然没什么变化！</p><p>设想，如果我们不做 <code>runGenerator</code> 函数，就需要手动控制 generator 的流程：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> it = main(); <span class="comment">// 获得 generator 的迭代器</span></span><br><span class="line"><span class="comment">// 不断用 `then(..)` 修饰 Promise</span></span><br><span class="line">it.next().value.then(<span class="function">(<span class="params">result1</span>)=&gt;</span>&#123;</span><br><span class="line">  it.next(result1).value.then(<span class="function">(<span class="params">result2</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 最终的结果返回</span></span><br><span class="line">    it.next(result2);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果业务流非常漫长，则撰写的嵌套是非常恐怖的。</p><p>现在，我们已经使用了 Promise 来管理基于 generator 的异步流程，它将我们从充满了诸如回调陷阱（callback hell）中解放了出来。通过 generators+promise 这个设计模式，我们阐述一下如何解决上面提到的三个问题： 1. 现在，我们拥有内置的错误处理。虽然这点没有在上面的 <code>runGenerator(..)</code> 进行揭示，但是，后文会讲到，在新的设计模式下，从 Promise 中监听所有的错误并不困难。最终通过将错误绑定到 <code>it.throw(..)</code>，我们就可以放心的在 generator 中使用 <code>try..catch</code> 语句来捕获和处理错误。 2. 我们拥有了 Promise 提供的 <a href="https://blog.getify.com/promises-part-2/#uninversion" target="_blank" rel="noopener">control/trustability</a>。 3. Promise 已经做了大量抽象帮助我们方便的操纵多个 “并行的” 任务。</p><p>例如，<code>yield Promise.all([..])</code> 将会利用传入的并行的任务数组（数组元素都是 Promise 对象），产出单一的 Promise 对象供 generator 操纵，generator 会等待所有的子 Promise 对象完成（无论完成顺序是怎样的）才继续进行。最后，我们真正返回给 generator 流程的是所有子 Promise 的响应构成的数组，数组元素的顺序会与请求顺序一致。</p><h2 id="generators-promise-下的错误处理"><a href="#generators-promise-下的错误处理" class="headerlink" title="generators+promise 下的错误处理"></a>generators+promise 下的错误处理</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        makeAjaxCall( url, (err,text)=&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span> (err) reject( err );</span><br><span class="line">            <span class="keyword">else</span> resolve( text );</span><br><span class="line">        &#125; );</span><br><span class="line">    &#125; );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runGenerator</span>(<span class="params">g</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> it = g(), ret;</span><br><span class="line">    <span class="comment">// 现在，传入了 `err` 作为第一个参数</span></span><br><span class="line">    (<span class="function"><span class="keyword">function</span> <span class="title">iterate</span>(<span class="params">err, val</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// generator 迭代过程中遇到错误就 `throw`</span></span><br><span class="line">        <span class="keyword">if</span>(err) &#123;</span><br><span class="line">          setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            it.throw(err);</span><br><span class="line">          &#125;,<span class="number">0</span>);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">        ret = it.next( val );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 generator 没有执行完毕</span></span><br><span class="line">        <span class="keyword">if</span> (!ret.done) &#123;</span><br><span class="line">            <span class="comment">// 是否 `ret` 仍然是一个 Promise 对象，如果是，意味着 generator 还在不断 `yield`</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"then"</span> <span class="keyword">in</span> ret.value) &#123;</span><br><span class="line">                <span class="comment">// 将 `iterate(val)` 注册为该 Promise 的 `then(..)` 的回调，</span></span><br><span class="line">                <span class="comment">// 借此，获得一个 Promise 链</span></span><br><span class="line">                ret.value.then( iterate );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果不是 Promise 对象，而是立即数，暗示 Promise 链已经获得最终结果，将该结果返回</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// avoid synchronous recursion</span></span><br><span class="line">                setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                    iterate( ret.value ); <span class="comment">// 相当于 it.next(立即数)</span></span><br><span class="line">                &#125;, <span class="number">0</span> );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">runGenerator(<span class="function"><span class="keyword">function</span> *<span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> result1 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.1"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">"Error:"</span> + err );</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="built_in">JSON</span>.parse( result1 );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> result2 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.2?id="</span> + data.id );</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">"Error:"</span> + err );</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> resp = <span class="built_in">JSON</span>.parse( result2 );</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">"The value you asked for:"</span> + resp.value );</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure><p>如果一个 Promise 的 reject 发生，那么该 reject 对应到的错误会映射到 generator 中的能够捕获的一个错误，这个映射过程是通过 <code>runGenerator(..)</code> 中声明的 <code>it.throw(..)</code> 来完成的。</p><h2 id="generators-promise-下的并行任务"><a href="#generators-promise-下的并行任务" class="headerlink" title="generators+promise 下的并行任务"></a>generators+promise 下的并行任务</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        makeAjaxCall( url, resolve );</span><br><span class="line">    &#125; )</span><br><span class="line">    <span class="comment">// 当获得返回的 `text`，可以做一些后置处理</span></span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">text</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// did we just get a (redirect) URL back?</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="regexp">/^https?:\/\/.+/</span>.test( text )) &#123;</span><br><span class="line">            <span class="comment">// make another sub-request to the new URL</span></span><br><span class="line">            <span class="keyword">return</span> request( text );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// otherwise, assume text is what we expected to get back</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> text;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">runGenerator( <span class="function"><span class="keyword">function</span> *<span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> search_terms = <span class="keyword">yield</span> <span class="built_in">Promise</span>.all( [</span><br><span class="line">        request( <span class="string">"http://some.url.1"</span> ), <span class="comment">// 每个元素也是 promise 对象</span></span><br><span class="line">        request( <span class="string">"http://some.url.2"</span> ),</span><br><span class="line">        request( <span class="string">"http://some.url.3"</span> )</span><br><span class="line">    ] );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> search_results = <span class="keyword">yield</span> request(</span><br><span class="line">        <span class="string">"http://some.url.4?search="</span> + search_terms.join( <span class="string">"+"</span> )</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">const</span> resp = <span class="built_in">JSON</span>.parse( search_results );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">"Search results:"</span> + resp.value );</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure><p>在上面代码中，<code>Promise.all([ .. ])</code> 创建了一个 Promise 对象，该对象会等待三个子 Promise 对象完成。最终，返回的到 generator 的，恢复 generator 执行的，会是该 Promise 对象的执行结果。</p><h3 id="ES7-中的-async"><a href="#ES7-中的-async" class="headerlink" title="ES7 中的 async"></a>ES7 中的 <code>async</code></h3><p>尚未发布的 ES7 标准中提出了一个 <code>async</code> 函数，该函数就像我们上面撰写被 <code>runGenerator(..)</code> 所包裹的 generator。通过 <code>await</code> 关键字，你能够发出 Promise 对象，他会等待这些对象完成后才继续下去（我们甚至都不再需要借助迭代器了）。</p><p>aysnc 函数的大致使用过程如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result1 = <span class="keyword">await</span> request( <span class="string">"http://some.url.1"</span> );</span><br><span class="line">    <span class="keyword">const</span> data = <span class="built_in">JSON</span>.parse( result1 );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> result2 = <span class="keyword">await</span> request( <span class="string">"http://some.url.2?id="</span> + data.id );</span><br><span class="line">    <span class="keyword">const</span> resp = <span class="built_in">JSON</span>.parse( result2 );</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">"The value you asked for:"</span> + resp.value );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main();</span><br></pre></td></tr></table></figure><p>正如你所看到的那样，一个 <code>async function</code> 能够被直接调用，而不需要再包裹上 <code>runGenerator(..)</code>。其次，我们将用新的关键字 <code>await</code> 来替代 <code>yield</code> 告诉 <code>async function</code> 在继续前需要等待当前的 Promise 处理完成。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>generator+promise 的设计模式集成了强大而优雅的同步式的异步流程控制的优势。通过简单的 wrapper 函数，我们能够自动地运行我们的 generator 直至完成，包括清晰明了的同步式的错误控制。</p><p>而在 ES7 以上的版本，我们还能有 <code>async function</code> 来完成同样的任务。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文：&lt;a href=&quot;https://davidwalsh.name/async-generators&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Going Async With ES6 Generators&lt;/a&gt; 本文在作者文章的基础上，适当补充了一些代码及说明&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ES6 中的 generator 能够帮助我们提供一种类似同步一样的代码风格，来将异步过程的具体实现隐藏。这样的好处就是我们能够更加自然的表达自己的业务流程（work flow），而避免陷入异步的麻烦中。换言之，借助于 generator，我们既拥有了异步执行的能力，又不用再绞尽脑汁的去维护异步代码。&lt;/p&gt;
&lt;p&gt;继续阅读本文，你会发现这么做的结果简直太美妙了，以前那些糟糕的异步代码现在讲会向同步代码那样变得 &lt;strong&gt; 易于阅读 &lt;/strong&gt; 和 &lt;strong&gt; 可维护 &lt;/strong&gt;。需要知道的是，这个同步只是代码风格上的同步，他的执行过程仍然是异步的。&lt;/p&gt;
&lt;p&gt;说了那么多，仍然有些抽象，现在我们由浅入深地看看到底怎么通过 ES6 来优化异步过程。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript 学习笔记" scheme="http://yoyoyohamapi.me/categories/JavaScript-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript - ES6" scheme="http://yoyoyohamapi.me/tags/JavaScript-ES6/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 中的递归优化</title>
    <link href="http://yoyoyohamapi.me/2016/06/28/JavaScript-%E4%B8%AD%E7%9A%84%E9%80%92%E5%BD%92%E4%BC%98%E5%8C%96/"/>
    <id>http://yoyoyohamapi.me/2016/06/28/JavaScript-中的递归优化/</id>
    <published>2016-06-28T14:45:04.000Z</published>
    <updated>2018-02-14T17:02:05.633Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>说到递归，我们先来看一个最常见的递归用例：<strong> 计算阶乘 </strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> n*factorial(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试一下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">factorial(<span class="number">5</span>); <span class="comment">// =&gt; 120</span></span><br></pre></td></tr></table></figure><p>似乎一切正常，5 的阶乘 120 被正确计算出来了，我们试着把数字调大一些：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">factorial(<span class="number">70000</span>);</span><br><span class="line"><span class="comment">// Uncaught RangeError:Maximum call stack size exceeded(…)</span></span><br></pre></td></tr></table></figure><p>浏览器提示我们 <strong> 栈溢出 </strong> 了（测试环境：chrome 51），究竟发生了什么呢?</p><a id="more"></a><h2 id="尾调用"><a href="#尾调用" class="headerlink" title="尾调用"></a>尾调用</h2><p>其实，上面的 <code>factorial</code> 的实现等同于下面这个形式：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> total = factorial(n<span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">return</span> n*total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数有个什么特点呢，就是该函数中的调用 <code>factorial(n-1)</code> 并没有发生在函数最后。因此，为了在执行完该调用还能返回到函数中执行后续操作:</p><ol><li>赋值给局部变量 <code>total</code>：<code>var total = factorial(n-1)</code><br>.    计算 <code>n*total</code> 并返回。</li></ol><p>那么，当前的运行环境在进入这个调用前，会先将 <strong> 调用位置 </strong> 以及周围的一些环境保存成一个 <strong> 调用帧（call frame）</strong> ，并将该调用帧 <strong> 压入（push）</strong> 一个栈空间中，这个栈被称为 <strong> 调用栈（call stack）</strong>。当再无调用帧入栈时，就开始逐个 <strong> 压出（pop）</strong> 调用帧，调用取值。比如上面的 <code>factorial(5)</code> 的执行过程就是一个呈 <strong> 金字塔形 </strong> 的过程，金字塔的峰值就反应了 <code>factorial</code> 对栈空间需求的峰值：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">push factorial(<span class="number">5</span>)</span><br><span class="line">push <span class="number">5</span>*factorial(<span class="number">4</span>)</span><br><span class="line">push <span class="number">5</span>*(<span class="number">4</span>*factorial(<span class="number">3</span>) )</span><br><span class="line">push <span class="number">5</span>*(<span class="number">4</span>* (<span class="number">3</span>*factorial(<span class="number">2</span>)) )</span><br><span class="line">push <span class="number">5</span>*(<span class="number">4</span>*( <span class="number">3</span>* (<span class="number">2</span>*factorial(<span class="number">1</span>)) ) )</span><br><span class="line">pop  <span class="number">5</span>*<span class="number">4</span>*<span class="number">3</span>*(<span class="number">2</span>*<span class="number">1</span>)</span><br><span class="line">pop  <span class="number">5</span>*<span class="number">4</span>*(<span class="number">3</span>*<span class="number">2</span>)</span><br><span class="line">pop  <span class="number">5</span>*(<span class="number">4</span>*<span class="number">6</span>)</span><br><span class="line">pop  <span class="number">5</span>*<span class="number">24</span></span><br><span class="line">pop  <span class="number">120</span></span><br></pre></td></tr></table></figure><p>很明显，这次调用之于调用栈的空间复杂度是 <code>O(n)</code>，亦即，随着我们 <code>n</code> 取值的不断变大，栈空间不断被消耗，当 <code>n</code> 很大时，栈溢出就发生了，毕竟内存总是有限的，不允许我们这么无节制的消耗栈空间。</p><p>那么要如何优化，才能不发生栈溢出呢？我们来看另外一个非常简单的函数：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> n = <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">return</span> b(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数有个什么特点？就是其内部的函数调用 <code>b(100)</code> 发生在了函数末尾，也就是说，该函数调用之后不再有任何后续操作，通常，把这样的调用形式称之为 <a href="https://zh.wikipedia.org/wiki/%E5%B0%BE%E8%B0%83%E7%94%A8" target="_blank" rel="noopener">尾调用</a>。尾调用因为脱离对后续操作的依赖，也就没有必要再去创建更多的调用帧消耗宝贵的栈空间了。</p><p>那么我们尝试着把之前的 <code>factorial</code> 改写成尾调用的形式，再次分析 <code>factorial</code> 的执行过程，可以发现，它能够被简化成如下形式：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>*factorial(<span class="number">5</span>)</span><br><span class="line"><span class="number">5</span>*factorial(<span class="number">4</span>)</span><br><span class="line"><span class="number">20</span>*factorial(<span class="number">3</span>)</span><br><span class="line"><span class="number">60</span>*factorial(<span class="number">2</span>)</span><br><span class="line"><span class="number">120</span>*factorial(<span class="number">1</span>)</span><br><span class="line"><span class="number">120</span>*<span class="number">1</span></span><br><span class="line"><span class="number">120</span></span><br></pre></td></tr></table></figure><p>即每次的执行过程总是：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">total*factorial(n)</span><br></pre></td></tr></table></figure><p>进一步，我们将 <code>total</code> 当做 <code>factorial</code> 的参数，这样就将后续过程也融入到了函数调用中，最终获得了一个尾调用形式的 <code>factorial</code> ：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, total</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">  <span class="keyword">return</span> factorial(n<span class="number">-1</span>, n*total);</span><br><span class="line">  <span class="comment">// 不再有后续操作 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>factorial</code> 的执行过程就会变成：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">factorial(<span class="number">5</span>,<span class="number">1</span>)</span><br><span class="line">factorial(<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">factorial(<span class="number">3</span>,<span class="number">20</span>)</span><br><span class="line">factorial(<span class="number">2</span>,<span class="number">60</span>)</span><br><span class="line">factorial(<span class="number">1</span>,<span class="number">120</span>)</span><br><span class="line"><span class="number">120</span></span><br></pre></td></tr></table></figure><p>已经不是金字塔形了，栈的空间复杂度由 <code>O(n)</code> 减少到了 <code>O(1)</code> ，仅最外层的函数需要一个调用帧，因为外层函数执行完成后需要返回到外部空间进行后续操作。这种优化方式被称为 *<em> 尾调用优化（Tail Call Optimization）*<em> ，简称 **TCO</em></em> 。</p><h2 id="现实却很残酷"><a href="#现实却很残酷" class="headerlink" title="现实却很残酷"></a>现实却很残酷</h2><p>我们再来测试一下被优化过 <code>factorial</code> 函数：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">factorial(<span class="number">70000</span>,<span class="number">1</span>);</span><br><span class="line"><span class="comment">// =&gt; VM16052:1 Uncaught RangeError: Maximum call stack size exceeded(…)</span></span><br></pre></td></tr></table></figure><p>悲剧！还是栈溢出了，这是为什么呢？原因就在于尾调用优化虽然在其他语言里面的得到了支持，但在 <strong>ES5</strong> 中还没有得到支持，换言之，<strong>ES5</strong> 根本不管你函数调用是否发生在函数末尾都不会作出优化。那么还有没有其他的解决方式？难道我们永远无法在 <strong>ES5</strong> 中实现一个大的阶乘运算？目前来说，我们可能想到的办法会是：干脆不要递归了，以非递归形式来重写 <code>factorial</code> 函数。</p><p>对于阶乘来说，非递归的实现复杂度也不高，但试想，如果面对一个更加复杂的业务，难道也得替换成冗长的非递归形式吗？</p><h2 id="救星：Trampoline（蹦床）"><a href="#救星：Trampoline（蹦床）" class="headerlink" title="救星：Trampoline（蹦床）"></a>救星：Trampoline（蹦床）</h2><p>救星来了，它就是 <strong>Trampoline</strong>，翻译过来就是 <strong> 蹦床 </strong>，先看一下利用蹦床解决栈溢出的递归的代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 阶乘函数 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, total</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">  <span class="comment">// 返回一个 thunk，避免函数调用 </span></span><br><span class="line">  <span class="keyword">return</span> factorial.bind(<span class="literal">null</span>, n<span class="number">-1</span>, n*total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tramponline 函数 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trampoline</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(fn &amp;&amp; <span class="keyword">typeof</span> fn === <span class="string">'function'</span>)&#123;</span><br><span class="line">    fn = fn();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fac</span>(<span class="params">n,total</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> trampoline(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> factorial(n, total);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上代码我们可以看到，Trampoline 的核心在于通过 <strong> 循环（loop）</strong> 来替换 <strong> 递归（recursion）</strong> 过程，从而规避递归过程中占空间的申请和消耗。实现这一目标的步骤如下：</p><ol><li>改造原来的递归，迫使他不再返回一个函数调用，而只返回一个 <a href="https://en.wikipedia.org/wiki/Thunk" target="_blank" rel="noopener">thunk</a>，以备调用：</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原来的阶乘函数 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n,total</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> factorial(n<span class="number">-1</span>, n*total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在的阶乘函数 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> factorial.bind(<span class="literal">null</span>, n<span class="number">-1</span>, n*total);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>一个蹦床函数，由他来通过循环控制原递归函数的执行过程：接受一个参数 <code>fn</code> ，若 <code>fn</code> 是一个 <strong>thunk</strong> ，执行 <code>fn</code> ，直至 <code>fn</code> 不再需要被执行，就获得了最后的结果。该过程相当于抑制了递归函数的执行，我们仅只是一次次抽出子过程进行执行：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trampoline</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(fn &amp;&amp; <span class="keyword">typeof</span> fn === <span class="string">'function'</span>)&#123;</span><br><span class="line">    fn = fn();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>一个 wrapper ，用来创建新的执行过程：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fac</span>(<span class="params">n,total</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> trampoline(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> factorial(n, total);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>现在，这个 wrapper 将是我们最终的调用对象，之后求取阶乘我们将调用 <code>fac</code> ，而不再是 <code>factorial</code> ：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fac(<span class="number">70000</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// =&gt; Infinity</span></span><br></pre></td></tr></table></figure></li></ol><p>可以看到，现在不再出现栈溢出的情况了。另外，为了避免混淆，更好的一种方式是将 <code>factorial</code> 封装到 <code>fac</code> 内部:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fac</span>(<span class="params">n,total</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, total</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">    <span class="comment">// 返回一个 thunk，避免函数调用 </span></span><br><span class="line">    <span class="keyword">return</span> factorial.bind(<span class="literal">null</span>, n<span class="number">-1</span>, n*total);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> trampoline(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> factorial(n, total);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ES6-中的尾递归优化"><a href="#ES6-中的尾递归优化" class="headerlink" title="ES6 中的尾递归优化"></a>ES6 中的尾递归优化</h2><p>在 <strong>ES6</strong> 下，尾递归优化获得了支持，但是在 Babel 最新的 v6 版本中，去掉了对于尾递归函数的 transform，Babel 官方给出了理由如下：</p><blockquote><p>Only explicit self referencing tail recursion was supported due to the complexity and performance impact of supporting tail calls globally. Removed due to other bugs and will be re-implemented.</p></blockquote><p>早先版本的 Babel 对于尾递归的优化可以参看这篇文章：<a href="https://taylodl.wordpress.com/2015/08/09/functional-javascript-tail-call-optimization-and-babel/" target="_blank" rel="noopener">Functional JavaScript – Tail Call Optimization and Babel</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://raganwald.com/2013/03/28/trampolines-in-javascript.html" target="_blank" rel="noopener">Tramponline in Javascript</a><br>   <a href="https://zh.wikipedia.org/wiki/%E5%B0%BE%E8%B0%83%E7%94%A8" target="_blank" rel="noopener">Wiki 尾调用</a><br>   <a href="https://zh.wikipedia.org/wiki/%E5%B0%BE%E8%B0%83%E7%94%A8" target="_blank" rel="noopener">阮一峰 - 尾调用优化</a><br>   <a href="http://www.integralist.co.uk/posts/js-recursion.html" target="_blank" rel="noopener">Understanding recursion in functional JavaScript programming</a><br>   <a href="https://taylodl.wordpress.com/2015/08/09/functional-javascript-tail-call-optimization-and-babel/" target="_blank" rel="noopener">Functional JavaScript – Tail Call Optimization and Babel</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h2&gt;&lt;p&gt;说到递归，我们先来看一个最常见的递归用例：&lt;strong&gt; 计算阶乘 &lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;factorial&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;n&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(n==&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; n*factorial(n&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;测试一下：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;factorial(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// =&amp;gt; 120&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;似乎一切正常，5 的阶乘 120 被正确计算出来了，我们试着把数字调大一些：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;factorial(&lt;span class=&quot;number&quot;&gt;70000&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Uncaught RangeError:Maximum call stack size exceeded(…)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;浏览器提示我们 &lt;strong&gt; 栈溢出 &lt;/strong&gt; 了（测试环境：chrome 51），究竟发生了什么呢?&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript 函数式编程" scheme="http://yoyoyohamapi.me/categories/JavaScript-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="JavaScript" scheme="http://yoyoyohamapi.me/tags/JavaScript/"/>
    
      <category term="函数式编程" scheme="http://yoyoyohamapi.me/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Redux 中间件的实现</title>
    <link href="http://yoyoyohamapi.me/2016/06/23/Redux-%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <id>http://yoyoyohamapi.me/2016/06/23/Redux-的中间件/</id>
    <published>2016-06-23T10:26:18.000Z</published>
    <updated>2018-02-14T17:02:10.260Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>我们知道在 Redux 中，dispatch 的作用在于派发一个 action，该 action 会被 reducer 收到，reducer 根据 action 的类型进行相应的状态（state）维护：</p><div style="text-align:center"><br><img src="https://www.lucidchart.com/publicSegments/view/bc695af5-28c4-432d-ba5f-270905ce996e/image.png" width="500"><br></div><a id="more"></a><p>Redux 的 dispatch 方法被设计得非常轻量，我们不妨查看 Redux 中的 <strong>createStore.js</strong> 源码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 需要 action 是一个纯对象 </span></span><br><span class="line">   <span class="keyword">if</span> (!isPlainObject(action)) &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">       <span class="string">'Actions must be plain objects.'</span> +</span><br><span class="line">       <span class="string">'Use custom middleware for async actions.'</span></span><br><span class="line">     )</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// action 需要声明类型</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">typeof</span> action.type === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">       <span class="string">'Actions may not have an undefined"type"property.'</span> +</span><br><span class="line">       <span class="string">'Have you misspelled a constant?'</span></span><br><span class="line">     )</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 检查是否正在 dispatch 中</span></span><br><span class="line">   <span class="keyword">if</span> (isDispatching) &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Reducers may not dispatch actions.'</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 开始 dispatch, 倘若 dispatch 遇到阻碍(exception), 允许再次 dispatch</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     isDispatching = <span class="literal">true</span></span><br><span class="line">     <span class="comment">// 通过 reducer 来刷新状态</span></span><br><span class="line">     currentState = currentReducer(currentState, action)</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     <span class="comment">// 修复 dispatch 状态, 以便再次发送</span></span><br><span class="line">     isDispatching = <span class="literal">false</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取最新一次(next) 的监听列表, 逐个响应该 dispatch</span></span><br><span class="line">   <span class="keyword">var</span> listeners = currentListeners = nextListeners</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; listeners.length; i++) &#123;</span><br><span class="line">     listeners[i]()</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> action</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现，在 dispatch 实现中，仅能接受和返回一个 plain action 对象：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  type: CLICK</span><br><span class="line">  text: <span class="string">'submit'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><p>在开发环境下，我们要在 dispatch 过程中输出一些日志，比如 dispatch 前后的系统状态变动，可以有如下方式：</p><ul><li>直接在业务代码中添加日志打印：</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> action = addTodo(<span class="string">'Use Redux'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'dispatching'</span>, action)</span><br><span class="line">store.dispatch(action)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'next state'</span>, store.getState())</span><br></pre></td></tr></table></figure><p>目的是达到了，但是并不智慧（代码侵入性太强），我们每需要一个日志打印，就得手动在业务代码中添加，这会使我们业务代码变得肮脏（到处是重复的 <code>console.log</code> ）而难以阅读。</p><ul><li>重新构造一个经过包裹的 dispatch</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatchAndLog</span>(<span class="params">store, action</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'dispatching'</span>, action)</span><br><span class="line">  store.dispatch(action)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'next state'</span>, store.getState())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后，在有日志需求的地方，我们用该 <code>dispatchAndLog</code> 方法替换原有的 <code>dispatch</code> 方法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">dispatchAndLog(store, addTodo(<span class="string">'Use Redux'</span>))</span><br></pre></td></tr></table></figure><p>看起来这样做不错，代码也清爽简洁，但设想这样一种情况，团队的其他人交给我们了一份老旧的代码片，使用的全是 <code>dispatch</code> 方法，为了日志需求，我们不得不定位到每一个 <code>dispatch</code> 进行替换，这口锅你愿意不愿意背？当然还得背，否则 KPI 就要捉急，为了背着不是那么累，还得往下思考。</p><ul><li>Monkey Patching</li></ul><p>在上一种解决方式中，壁垒就是我们得 <strong> 重复 </strong> 替换每一个 <code>dispatch</code> 调用。<code>dispatch</code> 作为 <code>store</code> 的一个方法，保存的是一个方法引用，所以我们可以让 <code>store</code> 的 <code>dispatch</code> 属性重新指向包裹后的引用：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先暂存老的业务逻辑</span></span><br><span class="line"><span class="keyword">let</span> next = store.dispatch</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatchAndLog</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 为老的业务逻辑打上补丁 patching</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'dispatching'</span>, action)</span><br><span class="line">  <span class="keyword">let</span> result = next(action)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'next state'</span>, store.getState())</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 新的逻辑替换掉老的逻辑</span></span><br><span class="line">store.dispatch = dispatchAndLog</span><br></pre></td></tr></table></figure><blockquote><p>Monkey Patching 是一个很常见的技术手段，先在老的业务逻辑上打补丁（patching）形成新的逻辑，再用新的逻辑替换掉老的逻辑，而几乎不影响代码变动。</p></blockquote><p>好像天亮了，在你充满希望的等着上级褒奖时，新的需求来了：在一些场景下，为了保证性能（如惰性求值），我们不想 action 是一个 plain object，而希望它是一个<a href="http://www.ruanyifeng.com/blog/2015/05/thunk.html" target="_blank" rel="noopener"> thunk </a>，为此，我们包裹一个新的 <code>dispatch</code>:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此时，`store.dispatch` 已经拥有了日志功能</span></span><br><span class="line"><span class="keyword">let</span> next = store.dispatch <span class="comment">// 快照老的 `dispatch`</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatchThunk</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> action === <span class="string">'function'</span>)</span><br><span class="line">    <span class="keyword">return</span> action(store)</span><br><span class="line">  <span class="keyword">return</span> next(action) <span class="comment">// 调用老的 `dispatch`</span></span><br><span class="line">&#125;</span><br><span class="line">store.dispatch = dispatchThunk <span class="comment">// 刷新 `dispatch`</span></span><br></pre></td></tr></table></figure><p>此时，我们验证 Monkey Patching 的解决策略在新的需求到来时依然能够从容应对，通过不断的打补丁，我们使得原有的 <code>dispatch</code> 方法不断强大，这个强大体现在两个方面：</p><ol><li>在 <code>dispatch</code> 的执行过程中注入了新的逻辑，例如日志打印</li><li>支持更广泛的 action 类型，不仅可以是 plain object，还可以是 thunk，甚至是 promise</li></ol><p>但是，我们也发现了，代码仍然在这些方面有所重复：</p><ol><li>缓存老的 <code>dispatch</code> 逻辑：</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> next = store.dispatch</span><br></pre></td></tr></table></figure><ol><li>替换 <code>store.dispatch</code>：</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">store.dispatch = dispatchThunk</span><br></pre></td></tr></table></figure><p>对于第一个问题， 我们可以通过参数传递来 <strong> 隐式地 </strong> 缓存老逻辑：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatchAndLog</span>(<span class="params">store, next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">action</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'dispatching'</span>, action)</span><br><span class="line">    <span class="keyword">let</span> result = next(action)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'next state'</span>, store.getState())</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们新的业务代码会变成如下形式：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">store.dispatch = dispatchAndLog(store, store.dispatch)</span><br><span class="line">store.disptach = dispatchThunk(store, store.dispatch)</span><br></pre></td></tr></table></figure><p>如果熟悉函数式编程，我们还可以通过 <a href="https://zh.wikipedia.org/wiki/%E6%9F%AF%E9%87%8C%E5%8C%96" target="_blank" rel="noopener"> curry 化</a> 优化上述代码片:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logger</span>(<span class="params">store</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">next</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'dispatching'</span>, action)</span><br><span class="line">      <span class="keyword">let</span> result = next(action)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'next state'</span>, store.getState())</span><br><span class="line">      <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，代码变成了：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> dispatch = store.dispatch</span><br><span class="line">dispatch = logger(store)(dispatch)</span><br><span class="line">dispatch = thunk(store)(dispatch)</span><br><span class="line">store.dispatch = dispatch</span><br></pre></td></tr></table></figure><p>我们发现，对于 <code>dispatch</code> 的构造，是一个 <strong> 链式（chain）</strong> 的修饰过程，每一个对于现有 <code>dispatch</code> 的改造都可以视为一个 <strong> 中间件（middleware）</strong>， 我们现在封装一个函数表示上述过程：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为 store 设置中间件</span></span><br><span class="line"><span class="comment"> * @param store</span></span><br><span class="line"><span class="comment"> * @paran middlewares &#123;Array&#125; 中间件列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">applyMiddleware</span>(<span class="params">store, middlewares</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 保证 `middlewares` 是一个数组</span></span><br><span class="line">  middlewares = middlewares.slice()</span><br><span class="line">  <span class="comment">// 我们声明的中间件序列最靠外的应当被最后响应</span></span><br><span class="line">  <span class="comment">// 所以最靠外的中间件应当最接近原生的 `dispatch`</span></span><br><span class="line">  middlewares.reverse()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化 `dispatch`</span></span><br><span class="line">  <span class="keyword">let</span> dispatch = store.dispatch</span><br><span class="line">  <span class="comment">// 迭代装饰 `dispatch`</span></span><br><span class="line">  middlewares.forEach(<span class="function"><span class="params">middleware</span> =&gt;</span></span><br><span class="line">    dispatch = middleware(store)(dispatch)</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, store, &#123; dispatch &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK，业务代码现在变成如下形式：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">store = applyMiddleware(store, [thunk, logger])</span><br></pre></td></tr></table></figure><p>这已经是一个非常干练的解决方式了，也非常接近于 Redux 自身提供的 <code>applyMiddleware</code> 的函数实现，但是该函数存在如下两个缺陷：</p><ol><li>将整个 <code>store</code> 暴露给中间件是过剩的，因为这些中间件仅有（1）<strong> 改造 dispatch 方法 </strong>、（2）<strong> 读取当前状态 </strong> 的需求， 所以仅需要暴露给他们 <code>dispatch(action)</code> 及 <code>getState()</code> 就够了，这形成了 Redux 对中间件的约定。</li><li>该方法存在这样一个隐患：可以无休止的应用中间件，如果开发者使用不当，将会产生对 <code>store.dispatch</code> 的重复包装：</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">store = applyMiddleware(store, [thunk, logger])</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">store = applyMiddleware(store, [thunk, logger])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时，日志会被嵌套且重复地打印</span></span><br><span class="line">store.dispatch(action)</span><br></pre></td></tr></table></figure><p>所以，更合理的一种做法是，把应用中间件到 <code>store</code> 的过程放到第一次返回 <code>store</code> 之前， 亦即，在用户拿到 <code>store</code> 对象前，<code>store.disptach</code> 已经被中间件序列包装完毕。</p><p>官方实现的 <code>applyMiddleware</code> 解决了这些问题：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">applyMiddleware</span>(<span class="params">...middlewares</span>) </span>&#123;</span><br><span class="line"> <span class="comment">// 重构了 `createStore` 方法， 保证用户在拿到 `store` 对象前，</span></span><br><span class="line"> <span class="comment">// `store` 对象的 `dispatch` 已经被中间件序列包装完毕</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">createStore</span>) =&gt;</span> (reducer, initialState, enhancer) =&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> store = createStore(reducer, initialState, enhancer)</span><br><span class="line">    <span class="comment">// 原始的 `dispatch`</span></span><br><span class="line">    <span class="keyword">var</span> dispatch = store.dispatch</span><br><span class="line">    <span class="keyword">var</span> chain = []</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 暴露有限的 API 给中间件</span></span><br><span class="line">    <span class="keyword">var</span> middlewareAPI = &#123;</span><br><span class="line">      getState: store.getState,</span><br><span class="line">      <span class="comment">// 通过闭包，每个中间件仅调用最新的 `dispatch`</span></span><br><span class="line">      dispatch: <span class="function">(<span class="params">action</span>) =&gt;</span> dispatch(action)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 利用 curry 化，初始化中间件链</span></span><br><span class="line">    chain = middlewares.map(<span class="function"><span class="params">middleware</span> =&gt;</span> middleware(middlewareAPI))</span><br><span class="line">    <span class="comment">// 利用函数组合，组合各个中间件至最终的 `dispatch` 形态</span></span><br><span class="line">    dispatch = compose(...chain)(store.dispatch)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个通过中间件重构了 `dispatch` 的 `store` 对象</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      ...store,</span><br><span class="line">      dispatch</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到， 该方法实际上是重构了 <code>createStore()</code>, 在官方的 <code>createStore</code> 实现中，我们观察到如下源码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// createStore.js</span></span><br><span class="line"><span class="comment">// 如果传递了 `enhancer`, 就必须保证 `enhancer` 是一个函数</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">'function'</span>) &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected the enhancer to be a function.'</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 如果 `enhancer` 合法, 那么创建 `store` 的行为就放到 `enhancer` 中完成</span></span><br><span class="line">   <span class="keyword">return</span> enhancer(createStore)(reducer, initialState)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们得知，一旦遇到 <code>enhancer</code>（在这里是 <code>applyMiddleware</code>），那么创建 <code>store</code> 的行为就放到 <code>enhancer</code> 中完成，这样就解决了对 <code>store.dispatch</code> 的重复包装问题。</p><p>此外，在 <code>applyMiddleware</code> 中有如下一段代码片很重要：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">dispatch = compose(...chain)(store.dispatch)</span><br></pre></td></tr></table></figure><p>这段代码片中利用了函数式编程中函数组合（composing）的概念，从中间件链中不断抽出函数进行组合（一个 reduce 过程）， 组合方向为从右向左。为什么要进行函数组合呢，回顾之前的代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> dispatch = store.dispatch</span><br><span class="line">dispatch = logger(store)(dispatch)</span><br><span class="line">dispatch = thunk(store)(dispatch)</span><br><span class="line">store.dispatch = dispatch</span><br></pre></td></tr></table></figure><p>该构造过程可以简化为：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">store.dispatch = thunk(store)(logger(store)(dispatch))</span><br></pre></td></tr></table></figure><p>如果了解函数式编程（学习 Redux 必须了解），这样的形式就暗示了我们可以进行函数组合（composing）来组合各个中间件构造最终的 dispatch， 官方的 compose 实现如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// compose.js</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 组合函数</span></span><br><span class="line"><span class="comment"> * @param funcs 待组合函数列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...funcs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (funcs.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">arg</span> =&gt;</span> arg</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 获得起始函数</span></span><br><span class="line">    <span class="keyword">const</span> last = funcs[funcs.length - <span class="number">1</span>]</span><br><span class="line">    <span class="comment">// 获得其余函数</span></span><br><span class="line">    <span class="keyword">const</span> rest = funcs.slice(<span class="number">0</span>, <span class="number">-1</span>)</span><br><span class="line">    <span class="comment">// 通过 `reduceRight`, 从右向左组合函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> rest.reduceRight(<span class="function">(<span class="params">composed, f</span>) =&gt;</span> f(composed), last(...args))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如我们的中间件序列为：<code>[mid1, mid2, mid3]</code>, 那么最终组合成的函数即为：<code>mid1(mid2(mid3(...args)))</code>。 在 <code>dispatch</code> 时，中间件的响应顺序也为 <code>[mid1,mid2,mid3]</code></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们整理一下通过中间件机制增强 dispatch 的过程：</p><h3 id="1-撰写中间件"><a href="#1-撰写中间件" class="headerlink" title="1. 撰写中间件"></a>1. 撰写中间件</h3><p>打补丁，包裹老的业务逻辑到新的业务逻辑形成一个新的中间件，同时将各个中间件按序进行存储，形成一个中间件链。</p><h3 id="2-组合中间件"><a href="#2-组合中间件" class="headerlink" title="2. 组合中间件"></a>2. 组合中间件</h3><p>通过函数组合，新的业务逻辑不断装饰老的业务逻辑。</p><h3 id="3-pipeline"><a href="#3-pipeline" class="headerlink" title="3. pipeline"></a>3. pipeline</h3><p>action 将在各个中间件间流动, 每次流动，都有可能产生新的 action。使用了中间件技术的 dispatch 将会成为一个流通 action 的管道</p><p>现在，具有中间件参与的 dispatch 如下图所示：</p><div style="text-align:center"><br><img src="https://www.lucidchart.com/publicSegments/view/b1fe65ad-1d2f-4bbe-a35e-f287fce57267/image.png" width="500"><br></div><h2 id="举个栗子-–-计数器"><a href="#举个栗子-–-计数器" class="headerlink" title="举个栗子 – 计数器"></a>举个栗子 – 计数器</h2><p>现在，完整的看一个在 Redux 使用中间件的例子 – 一个<a href="https://github.com/yoyoyohamapi/redux-middleware-example" target="_blank" rel="noopener">简单的计数器</a></p><p>首先，我们定义两个中间件：</p><ol><li>日志中间件：输出 dispatch 过程中的一些信息</li><li>thunk 中间件：允许 action 是一个 thunk</li></ol><h3 id="middlewares-js"><a href="#middlewares-js" class="headerlink" title="middlewares.js"></a>middlewares.js</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 日志中间件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> logger = <span class="function">(<span class="params">&#123;dispatch, getState&#125;</span>) =&gt;</span> next =&gt; <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'current state'</span>, getState())</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'dispatching...'</span>, action)</span><br><span class="line">    <span class="keyword">let</span> result = next(action)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'next state'</span>, getState())</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'.........'</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * thunk 中间件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> thunk = <span class="function">(<span class="params">&#123;dispatch, getState&#125;</span>) =&gt;</span> next =&gt; <span class="function"><span class="params">action</span>=&gt;</span></span><br><span class="line">    <span class="keyword">typeof</span> action === <span class="string">'function'</span>?action(dispatch, getState):next(action)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;thunk,logger&#125;</span><br></pre></td></tr></table></figure><h3 id="actions-js"><a href="#actions-js" class="headerlink" title="actions.js"></a>actions.js</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> INCREMENT = <span class="string">'INCREMENT'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> DECREMENT = <span class="string">'DECREMENT'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">increment</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        type: INCREMENT</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">decrement</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        type: DECREMENT</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">incrementIfOdd</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">dispatch, getState</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; counter &#125; = getState();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (counter % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dispatch(increment());</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="reducers-js"><a href="#reducers-js" class="headerlink" title="reducers.js"></a>reducers.js</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; INCREMENT, DECREMENT &#125; <span class="keyword">from</span> <span class="string">'./actions'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">countReducer</span>(<span class="params">state=&#123;counter:<span class="number">0</span>&#125;, action</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> INCREMENT:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123;</span><br><span class="line">                counter: state.counter + <span class="number">1</span></span><br><span class="line">            &#125;)</span><br><span class="line">        <span class="keyword">case</span> DECREMENT:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123;</span><br><span class="line">                counter: state.counter - <span class="number">1</span></span><br><span class="line">            &#125;)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> state</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="index-js"><a href="#index-js" class="headerlink" title="index.js"></a>index.js</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'babel-polyfill'</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"><span class="keyword">import</span>  &#123; increment, decrement, incrementIfOdd &#125; <span class="keyword">from</span> <span class="string">'./actions'</span></span><br><span class="line"><span class="keyword">import</span> &#123; logger, thunk&#125; <span class="keyword">from</span> <span class="string">'./middlerwares'</span></span><br><span class="line"><span class="keyword">import</span> rootReducer <span class="keyword">from</span> <span class="string">'./reducers'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(</span><br><span class="line">    rootReducer,</span><br><span class="line">    applyMiddleware(</span><br><span class="line">        thunk,</span><br><span class="line">        logger</span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">store.dispatch(increment())</span><br><span class="line">store.dispatch(increment())</span><br><span class="line">store.dispatch(decrement())</span><br><span class="line">store.dispatch(incrementIfOdd())</span><br></pre></td></tr></table></figure><p>程序运行结果如下图所示：</p><div style="text-align:center"><br><img src="http://yoyoyohamapi.qiniudn.com/redux-middleware-middleware.png" width="200"><br></div><p>我们用图描述 <code>store.dispatch(incrementIfOdd())</code> 这一过程, 假设当前的 <code>counter</code> 为奇数：</p><div style="text-align:center"><br><img src="https://www.lucidchart.com/publicSegments/view/46caf1d5-08b1-4adf-9016-65461f32a717/image.png" width="500"><br></div><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://redux.js.org/docs/advanced/Middleware.html" target="_blank" rel="noopener">Middlewares</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h2&gt;&lt;p&gt;我们知道在 Redux 中，dispatch 的作用在于派发一个 action，该 action 会被 reducer 收到，reducer 根据 action 的类型进行相应的状态（state）维护：&lt;/p&gt;
&lt;div style=&quot;text-align:center&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://www.lucidchart.com/publicSegments/view/bc695af5-28c4-432d-ba5f-270905ce996e/image.png&quot; width=&quot;500&quot;&gt;&lt;br&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="React" scheme="http://yoyoyohamapi.me/categories/React/"/>
    
    
      <category term="React" scheme="http://yoyoyohamapi.me/tags/React/"/>
    
      <category term="Redux" scheme="http://yoyoyohamapi.me/tags/Redux/"/>
    
  </entry>
  
  <entry>
    <title>Flux 下的组件化开发</title>
    <link href="http://yoyoyohamapi.me/2016/06/20/Flux%E4%B8%8B%E7%9A%84%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/"/>
    <id>http://yoyoyohamapi.me/2016/06/20/Flux下的组件化开发/</id>
    <published>2016-06-20T13:20:30.000Z</published>
    <updated>2018-02-14T17:01:59.662Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Flux-构成"><a href="#Flux-构成" class="headerlink" title="Flux 构成"></a>Flux 构成</h2><p>首先要明确的是，Flux 并不是一个前端框架，而是前端的一个设计模式，一个状态管理机制，其把前端的一个交互流程简单的模拟成了一个单向数据流。</p><div style="text-align:center"><br><img src="http://facebook.github.io/flux/img/flux-simple-f8-diagram-1300w.png" width="500"><br></div><p>在上图中，我们可以看到 Flux 的四个核心构成：</p><a id="more"></a><h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p>一个交互动作, 更多的时候代表一个时间，比如用户在页面组件上的点击（click），失焦（blur），双击（doubleclick）等等。一个 Action 往往由如下两个部分组成：</p><ul><li>交互类型（type）：例如创建、删除、更新等</li><li>交互体（payload）：或者说交互的携带信息，例如创建的文本</li></ul><h3 id="Dispatcher"><a href="#Dispatcher" class="headerlink" title="Dispatcher"></a>Dispatcher</h3><p>Action 分发器。从上图的数据流中，我们可以看到，用户每次产生的 Action 将被送入 Dispatcher，Dispatcher 对 Action 进行简单的包裹之后将其派发到 <strong> 所有 </strong> Store 中。</p><blockquote><p>注意！Dispatcher 的这种广播行为有别于 <strong>Pub/Sub</strong> 模型，在 Pub/Sub 模型中，需要声明订阅的消息类型，然后发布者会像订阅者广播特定类型的消息。而在 Dispatcher 中，Store 向其注册的任意回调接口都不要声明订阅的 Action 类型，即 Store 只告诉 Dispatcher “如果 Action 到来，请你把它发送给我”。当 Dispatcher 派发 Action 时，所有注册到 Dispatcher 的 callback 都会得到响应。回调可以通过简单的 switch-case 来针对不对类型的 Action 做出不同的响应。</p></blockquote><h2 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h2><p>数据仓库，保存了我们某个前端 App 的数据以及对数据的操作。Store 会向 Dispatcher 注册一个回调函数，该回调函数接受一个 Action 作为参数。当 Action 被派发到 Store 时，该回调函数被调用，借由 Action 中描述的 <strong> 交互类型（type）</strong>，Store 进行不同处理，这些处理都将被持久化到 Store 维护的数据对象上。</p><p>Store 完成数据的变更后，由于 Flux 并不是双向数据绑定的，因而即便我们已经持久化了 Store 中的数据，但组件的数据并未得到更新，组件也不会重新渲染。所以，每次数据变动后，为了告知组件去更新数据，Store 会 emit 一个 change 事件。当监听到 change 事件发生，注册到监听器上的回调去完成各个组件的状态更新。</p><h2 id="View"><a href="#View" class="headerlink" title="View"></a>View</h2><p>顾名思义，这就是用户所能看到的视图。有别于传统的 MVC，在 Flux 中，View 并不会和数据模型（Model）产生交互，其只会产生各种交互行为（Actions），这些行为将会被送到 Dispatcher 中，如下图所示：</p><div style="text-align:center"><br><img src="http://facebook.github.io/flux/img/flux-simple-f8-diagram-with-client-action-1300w.png" width="500"><br></div><p>当 View 中维护的状态变动时，View 需要被重新渲染。</p><h2 id="Todo-栗子"><a href="#Todo-栗子" class="headerlink" title="Todo 栗子"></a>Todo 栗子</h2><p>下面我们分析一个用 React+Flux 实现的一个 Flux 栗子，其源码托管在 <a href="https://github.com/facebook/flux/tree/master/examples/flux-todomvc" target="_blank" rel="noopener">github</a>上。</p><p>在项目实践中，面向组件化开发的最佳场景我认为是 <strong> 交互驱动型的开发 </strong>，该定义可能不够准确，其描述的是一旦一个完善的交互设计稿产生后，我们就可以从交互稿中 <strong> 分割 </strong> 出组件，并进行组件的状态 <strong> 分析 </strong>。假设我们得到了 Todo 的交互原型：</p><div style="text-align:center"><br><img src="http://7pulhb.com2.z0.glb.clouddn.com/Flux-Todo%E4%BA%A4%E4%BA%92%E5%8E%9F%E5%9E%8B.png" width="800"><br></div><blockquote><p>这是交互设计师的给我们的原稿，并且，原稿可能远不止这样一幅简单的图像，可能还包括更多的交互效果</p></blockquote><p>我们将会把这个应用拆分为如下组件：</p><h3 id="TodoApp"><a href="#TodoApp" class="headerlink" title="TodoApp"></a>TodoApp</h3><div style="text-align:center"><br><img src="http://7pulhb.com2.z0.glb.clouddn.com/Flux-TodoApp.png" width="500"><br></div><p>通常，在前端面向组件化的开发过程中，我们往往需要一个顶部容器包裹住我们的组件，一个页面可以存在若干个这样的顶部容器，这个容器类似一个集装箱或者盒子，封装了某个页面应用的所有组件和状态。例如，在某视频网站中，视频播放窗口可以作为一个顶部容器，其包裹了播放窗口，进度条，播放选项等各个组件，同时，评论部分也可以作为一个顶部容器，其包裹了评论列表，评论框等组件。</p><p>在 Todo 中，TodoApp 作为一个顶部容器，包裹了所有 Todo 应用需要的组件，这样，我们在应用入口只需要从 TodoApp 开始渲染，进而逐个渲染其子组件。但更为重要的是，TodoApp 将会封装其下各个组件需要用到的状态，通过数据流，各个组件将会收到状态，并且在状态改变时，重新开始渲染自己，最终更新页面内容。</p><h3 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h3><div style="text-align:center"><br><img src="http://7pulhb.com2.z0.glb.clouddn.com/Flux-TodoHeader.png" width="500"><br></div><p>这是一个头部组件，根据交互设计，他除了将保有静态的 “todos” 文字标题以外，还将会具有如下行为：</p><ul><li>右侧输入框失焦或者按下回车键：创建新的 todo 任务</li></ul><p>可以看到，由于 Header 不维护任何状态，所以 Header 是一个 <strong> 无状态（Stateless）</strong> 的组件</p><h3 id="Footer"><a href="#Footer" class="headerlink" title="Footer"></a>Footer</h3><div style="text-align:center"><br><img src="http://7pulhb.com2.z0.glb.clouddn.com/Flux-TodoFooter.png" width="500"><br></div><p>这是一个底部组件，它将显示未完成 todo 数，并能删除所有已完成 todo。首先他需要维护这些 <strong> 状态 </strong>:</p><ul><li><p>所有任务：</p><ul><li>通过遍历任务的完成情况，能获得未完成 todo 任务数</li><li>通过遍历任务的完成情况，统计已完成 todo 任务的信息</li><li>如果当前无任务，隐藏 Footer</li></ul></li></ul><p>因此，在初步的设计中，Footer 是一个 <strong> 有状态（Stateful）</strong> 的组件。后面我们会谈到该做法的不恰当。</p><p>并且，他具有如下行为：</p><ul><li>单击右侧按钮（Clear completed）: 清除所有已完成 todo 任务</li></ul><h3 id="MainSection"><a href="#MainSection" class="headerlink" title="MainSection"></a>MainSection</h3><div style="text-align:center"><br><img src="http://7pulhb.com2.z0.glb.clouddn.com/TodoMainSection.png" width="500"><br></div><p>该组件将会负责渲染所有的以创建任务，因而他需要维护的状态为：</p><ul><li>所有任务</li></ul><p>其具有的行为：</p><ul><li>点击顶部左侧图标按钮：完成 / 取消完成所有任务，具体根据 <strong> 所有任务 </strong> 是否都完成了决定</li></ul><p>因此， MainSection 也是一个有状态的组件。</p><h3 id="TodoItem"><a href="#TodoItem" class="headerlink" title="TodoItem"></a>TodoItem</h3><div style="text-align:center"><br><img src="http://7pulhb.com2.z0.glb.clouddn.com/TodoItem.png" width="500"><br></div><p>这是 todo 项目，每个项目来源于 MainSection 中的迭代，并且该组件具有如下行为：</p><ul><li>单击左侧按钮：完成 / 取消完成该任务</li><li>单击右侧按钮：删除该 todo</li><li>双击 todo 文本：进入下面的编辑模式</li></ul><div style="text-align:center"><br><img src="http://7pulhb.com2.z0.glb.clouddn.com/%E5%8F%8C%E5%87%BB%E8%BF%9B%E5%85%A5%E7%BC%96%E8%BE%91.png" width="500"><br></div><p>我们不难发现，“是否处于编辑模式” 实际上可作为该组件的一个状态，该状态的切换直接影响了该组件的展示和行为，所以，TodoItem 组件应当维护一个状态：</p><ul><li>是否编辑模式</li></ul><p>在编辑模式中，具有如下行为：</p><ul><li>输入框失焦或者按下回车键：更新任务</li></ul><p>可以看到，Header 组件及 TodoItem 组件的中的输入框具有一致的交互行为，所以，我们可以将该输入框提出来作为单独的组件，这也侧面体现了，一份完善的交互设计原型将预测到实现过程中的复用和抽象，避免了一些代码重构的时间。</p><h3 id="TodoTextInput"><a href="#TodoTextInput" class="headerlink" title="TodoTextInput"></a>TodoTextInput</h3><p>现在，我们抽象出一个可复用的输入组件 TodoTextInput 供 Header 和 TodoItem 使用，他需要维护如下状态：</p><ul><li>输入值</li></ul><p>他具有如下行为：</p><ul><li>输入框失焦或者按下回车键：调用存储过程（创建，更新等等）</li></ul><h3 id="组件结构"><a href="#组件结构" class="headerlink" title="组件结构"></a>组件结构</h3><div style="text-align:center"><br><img src="https://www.lucidchart.com/publicSegments/view/0f5014ca-ef30-4eac-8e6a-74a76dfc18d6/image.png" width="500"><br></div><h3 id="状态维护"><a href="#状态维护" class="headerlink" title="状态维护"></a>状态维护</h3><div style="text-align:center"><br><img src="https://www.lucidchart.com/publicSegments/view/1c6988eb-cb2c-4092-8f7f-2cbc11e07c9e/image.png" width="500"><br></div><p>我们发现在 MainSection 和 Footer 组件中都需要维护 <strong>allTodos</strong> 这一状态。由于 MainSection 与 Footer 属于平级的组件，所以，当 MainSection 中的 allTodos 这一状态发生改变时，为使 Footer 中的状态也发生改变，MainSection 中需要保存有 Footer 的引用才能更新到 Footer 的状态，同理，Footer 中也需要保存有 MainSection 的引用。这样，两个组件将会是强耦合的，如下图所示：</p><div style="text-align:center"><br><img src="https://www.lucidchart.com/publicSegments/view/210b9a7b-f8db-4642-bee0-62b8a62dbb33/image.png" width="500"><br></div><p>设想，如果以后还有更多的组件需要 allTodos 这一状态，这一设计模式将会是十分糟糕的，任何一个组件的脱离将可能导致整个引用网络的崩溃。</p><p>既然 allTodos 被多个组件共享，那么我们可以将该状态提升到更上一次的组件中，然后通过 <code>props</code> 传递给子组件。所以，在本例中，最终将 allTodos 提到了顶部容器 TodoApp 中进行维护，这样，通过 TodoApp 的 <code>setState()</code> 方法，所有绑定到 TodoApp 的组件都获得了状态更新，避免了组件间的相互引用，如下图所示：</p><div style="text-align:center"><br><img src="https://www.lucidchart.com/publicSegments/view/0140d060-b037-4ab8-9357-61029d6a14ef/image.png" width="500"><br></div><p>在 React 中，我们应当尽量创建多的无状态（Stateless）的组件，而把共享状态放到上层组件中，使上层组件成为一个有状态（Stateful）的组件。这样，有状态组件封装了交互行为以及与行为互动的状态，子组件通过 <code>props</code> 共享状态并进行数据渲染。更多 <code>state</code> 与 <code>props</code> 的关系和区别可以参看<a href="https://facebook.github.io/react/docs/interactivity-and-dynamic-uis-zh-CN.html" target="_blank" rel="noopener">官方文档</a></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><div style="text-align:center"><br><img src="http://7pulhb.com2.z0.glb.clouddn.com/Flux-%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" width="500"><br></div><p>其中 app.js 为应用的入口文件，从入口开始，逐步构造我们的 App。</p><h4 id="Dispatcher-1"><a href="#Dispatcher-1" class="headerlink" title="Dispatcher"></a>Dispatcher</h4><p><strong>js/AppDispatcher.js</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Dispatcher = <span class="built_in">require</span>(<span class="string">'flux'</span>).Dispatcher;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">new</span> Dispatcher();</span><br></pre></td></tr></table></figure><p>可以看到，TodoMVC 中的 Dispatcher 实现来自于于官方的<a href="https://www.npmjs.com/package/flux" target="_blank" rel="noopener">实现</a>。我们可以看下 Flux 中的 Dispatcher 源码，首先看到 <code>Dispatcher()</code> 构造函数：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dispatcher</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    _classCallCheck(<span class="keyword">this</span>, Dispatcher);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>._callbacks = &#123;&#125;; <span class="comment">// 保存向 Dispatcher 注册回调函数</span></span><br><span class="line">    <span class="keyword">this</span>._isDispatching = <span class="literal">false</span>; <span class="comment">// 是否正在分派 Action</span></span><br><span class="line">    <span class="keyword">this</span>._isHandled = &#123;&#125;; <span class="comment">// 已经完成执行的回调列表</span></span><br><span class="line">    <span class="keyword">this</span>._isPending = &#123;&#125;; <span class="comment">// 正在执行中的回调列表</span></span><br><span class="line">    <span class="keyword">this</span>._lastID = <span class="number">1</span>; <span class="comment">// 回调 Id 的起始标志</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看注册方法 <code>register(callback)</code> , 每个向 Dispatcher 的注册的回调（callback）都拥有唯一 Id 进行标识：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向 Dispatcher 注册回调函数, 每个回调函数都有唯一 id 进行标识</span></span><br><span class="line"><span class="comment"> * @param callback</span></span><br><span class="line"><span class="comment"> * @returns &#123;string&#125; 注册回调的 id</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">Dispatcher.prototype.register = <span class="function"><span class="keyword">function</span> <span class="title">register</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> id = _prefix + <span class="keyword">this</span>._lastID++;</span><br><span class="line">    <span class="keyword">this</span>._callbacks[id] = callback;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据 id 删除回调</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">Dispatcher.prototype.unregister = <span class="function"><span class="keyword">function</span> <span class="title">unregister</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    !<span class="keyword">this</span>._callbacks[id] ? process.env.NODE_ENV !== <span class="string">'production'</span> ? invariant(<span class="literal">false</span>, <span class="string">'Dispatcher.unregister(...): `%s` does not map to a registered callback.'</span>, id) : invariant(<span class="literal">false</span>) : <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>._callbacks[id];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>执行一个注册了的回调函数将经历如下过程：</p><ol><li>标识当前正在执行的回调为进行中（Pending）状态</li><li>将当前待处理的用户行为（payload）送至回调执行</li><li>执行完成，标识该回调已经完成（Handled）</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行回调函数, 该过程为:</span></span><br><span class="line"><span class="comment"> * 1. 标识当前正在执行的回调为 Pending 状态</span></span><br><span class="line"><span class="comment"> * 2. 将 payload 送入回调执行</span></span><br><span class="line"><span class="comment"> * 3. 执行完成, 标识该回调已经完成</span></span><br><span class="line"><span class="comment"> * @internal</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">Dispatcher.prototype._invokeCallback = <span class="function"><span class="keyword">function</span> <span class="title">_invokeCallback</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>._isPending[id] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">this</span>._callbacks[id](<span class="keyword">this</span>._pendingPayload);</span><br><span class="line">    <span class="keyword">this</span>._isHandled[id] = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>派发 <code>dispatch(payload)</code> 指定的用户行为 <code>payload</code> 到所有的 callback 将经历如下过程：</p><p>首先，需要明确的是能够进行派发的前提是当前 Dispatcher 为空闲状态，接下来</p><ol><li>派发前的预处理 <code>startDispatching()</code><ul><li>初始化所有回调的状态</li><li>设置当前正在分发的 <code>payload</code><ul><li>标识当前的 Dispatcher 状态为 “正在进行派发”</li></ul></li></ul></li><li>根据注册顺序依次执行回调 <code>invokeCallback(id)</code></li><li>派发结束后的收尾工作 <code>stopDispatching()</code><ul><li>清除派发对象</li><li>标识当前的 Dispatcher 状态为 “结束派发”</li></ul></li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 派发一个 payload 到所以已注册的 callback 中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">Dispatcher.prototype.dispatch = <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">payload</span>) </span>&#123;</span><br><span class="line">    !!<span class="keyword">this</span>._isDispatching ? process.env.NODE_ENV !== <span class="string">'production'</span> ? invariant(<span class="literal">false</span>, <span class="string">'Dispatch.dispatch(...): Cannot dispatch in the middle of a dispatch.'</span>) : invariant(<span class="literal">false</span>) : <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">this</span>._startDispatching(payload);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> id <span class="keyword">in</span> <span class="keyword">this</span>._callbacks) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>._isPending[id]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>._invokeCallback(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>._stopDispatching();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分发 payload 前的初始化:</span></span><br><span class="line"><span class="comment"> * 1. 初始化所有回调的状态</span></span><br><span class="line"><span class="comment"> * 2. 设置当前正在分发的 payload</span></span><br><span class="line"><span class="comment"> * 3. 标识当前 "正在进行派发"</span></span><br><span class="line"><span class="comment"> * @internal</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">Dispatcher.prototype._startDispatching = <span class="function"><span class="keyword">function</span> <span class="title">_startDispatching</span>(<span class="params">payload</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> id <span class="keyword">in</span> <span class="keyword">this</span>._callbacks) &#123;</span><br><span class="line">        <span class="keyword">this</span>._isPending[id] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">this</span>._isHandled[id] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>._pendingPayload = payload;</span><br><span class="line">    <span class="keyword">this</span>._isDispatching = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 结束派发时的收尾工作</span></span><br><span class="line"><span class="comment"> * 1. 清除派发对象</span></span><br><span class="line"><span class="comment"> * 2. 标识当前 "结束派发"</span></span><br><span class="line"><span class="comment"> * @internal</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">Dispatcher.prototype._stopDispatching = <span class="function"><span class="keyword">function</span> <span class="title">_stopDispatching</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>._pendingPayload;</span><br><span class="line">    <span class="keyword">this</span>._isDispatching = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>waitFor</strong></p><p>再看 Dispatcher 中一个很重要的方法: <code>waitFor(ids)</code>, 顾名思义，该方法的作用是：等待其他向 Dispatcher 注册了的回调执行完成。因而，该方法主要保证了 dispatch 时，待响应的回调函数的执行的 <strong> 顺序性 </strong>。</p><p>例如，在一个航班订票系统中，我们首先要选择完国家（Country），才能选择城市（City），所以，当一个类型为 “更新所选国家”的交互被送到 <code>CityStore</code> 所注册的回调时，为了保证能正确的选择更新后国家的城市，我们需要这样做：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">CityStore.dispatchToken = flightDispatcher.register(<span class="function"><span class="keyword">function</span>(<span class="params">payload</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (payload.actionType === <span class="string">'country-update'</span>) &#123;</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 如果不执行 waitFor(), 由于程序的异步性，那么可能 CityStore 的回调先于 ContryStore 的回调执行 </span></span><br><span class="line"><span class="comment">        * 此时的国家尚未更新，得到的默认城市是错误的，而并不是最新的</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">       flightDispatcher.waitFor([CountryStore.dispatchToken]);</span><br><span class="line">       <span class="comment">// waitFor() 保证了 ContryStore 先响应了'country-update'，即保证了国家更新先于城市更新</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 此时我们能正确的选择该国家的城市</span></span><br><span class="line">       CityStore.city = getDefaultCityForCountry(CountryStore.country);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>下面我们看 <code>waitFor()</code> 的源码实现：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 等待指定的回调完成</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">Dispatcher.prototype.waitFor = <span class="function"><span class="keyword">function</span> <span class="title">waitFor</span>(<span class="params">ids</span>) </span>&#123;</span><br><span class="line">    !<span class="keyword">this</span>._isDispatching ? process.env.NODE_ENV !== <span class="string">'production'</span> ? invariant(<span class="literal">false</span>, <span class="string">'Dispatcher.waitFor(...): Must be invoked while dispatching.'</span>) : invariant(<span class="literal">false</span>) : <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> ii = <span class="number">0</span>; ii &lt; ids.length; ii++) &#123;</span><br><span class="line">        <span class="keyword">var</span> id = ids[ii];</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>._isPending[id]) &#123;</span><br><span class="line">            !<span class="keyword">this</span>._isHandled[id] ? process.env.NODE_ENV !== <span class="string">'production'</span> ? invariant(<span class="literal">false</span>, <span class="string">'Dispatcher.waitFor(...): Circular dependency detected while'</span> + <span class="string">'waiting for `%s`.'</span>, id) : invariant(<span class="literal">false</span>) : <span class="literal">undefined</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        !<span class="keyword">this</span>._callbacks[id] ? process.env.NODE_ENV !== <span class="string">'production'</span> ? invariant(<span class="literal">false</span>, <span class="string">'Dispatcher.waitFor(...): `%s` does not map to a registered callback.'</span>, id) : invariant(<span class="literal">false</span>) : <span class="literal">undefined</span>;</span><br><span class="line">        <span class="keyword">this</span>._invokeCallback(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Store-1"><a href="#Store-1" class="headerlink" title="Store"></a>Store</h4><p>在 <strong>js/stores/TodoStore.js</strong> 中：</p><p>首先，我们维护我们的数据对象，并提供若干对于该数据的操作：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 保存 TODO 列表</span></span><br><span class="line"><span class="keyword">var</span> _todos = &#123;&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个 Todo</span></span><br><span class="line"><span class="comment"> * @param text &#123;string&#125; Todo 内容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 更新一个 TODO item</span></span><br><span class="line"><span class="comment"> * @param id &#123;string&#125;</span></span><br><span class="line"><span class="comment"> * @param updates &#123;object&#125; 待更新对象的属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params">id, updates</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据一个更新属性值对象更新所有 Todo</span></span><br><span class="line"><span class="comment"> * @param updates &#123;object&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateAll</span>(<span class="params">updates</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除 Todo</span></span><br><span class="line"><span class="comment"> * @param id &#123;string&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">destroy</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除所有的已完成的 TODO items</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">destroyCompleted</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后导出一个全局单例，该单例提供了常用的外部访问接口，并且通过 node 提供的 <code>EventEmitter</code> 来实现事件的派发和监听：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> TodoStore = assign(&#123;&#125;, EventEmitter.prototype, &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否所有 TODO 都已完成</span></span><br><span class="line"><span class="comment">     * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    areAllComplete: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得所有的 TODO</span></span><br><span class="line"><span class="comment">     * @returns &#123;object&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    getAll: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送变更事件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    emitChange: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加变更事件监听</span></span><br><span class="line"><span class="comment">     * @param callback</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    addChangeListener: <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 一旦受到变更事件, 触发回调</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         *   例如, 当我们创建一条 todo 时,</span></span><br><span class="line"><span class="comment">         *   TodoStore 将会发出一条变更事件,</span></span><br><span class="line"><span class="comment">         *   上游的状态维护器将会调用 callback 进行状态更新</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">this</span>.on(CHANGE_EVENT, callback);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除变更事件监听</span></span><br><span class="line"><span class="comment">     * @param callback</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    removeChangeListener: <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.removeListener(CHANGE_EVENT, callback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>最后，我们需要向 <code>AppDispatcher</code> 注册回调函数，以便在 <code>payload</code> 被分发到 TodoStore 时，TodoStore 能做出响应：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">AppDispatcher.register(<span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> text;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据不同的 action 类型(即不同的交互逻辑), 执行不同过程</span></span><br><span class="line">    <span class="keyword">switch</span> (action.actionType) &#123;</span><br><span class="line">        <span class="keyword">case</span> TodoConstants.TODO_CREATE:</span><br><span class="line">            text = action.text.trim();</span><br><span class="line">            <span class="keyword">if</span>( text!==<span class="string">''</span>) &#123;</span><br><span class="line">                create(text);</span><br><span class="line">                <span class="comment">// 一旦变更, 发出变更事件,</span></span><br><span class="line">                TodoStore.emitChange();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> TodoConstants.TODO_TOGGLE_COMPLETE_ALL:</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> TodoConstants.TODO_UNDO_COMPLETE:</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> TodoConstants.TODO_COMPLETE:</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> TodoConstants.TODO_UPDATE_TEXT:</span><br><span class="line">           <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> TodoConstants.TODO_DESTROY:</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> TodoConstants.TODO_DESTROY_COMPLETED:</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// no op</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>! 注意, 在回调执行过程中，如果发生状态的变动，需要抛出 change 事件，这样才能将组建的状态也更新（通过回调）。</p></blockquote><h4 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h4><p>我们将 TodoApp 中常见的 Action 都封装到了 <strong>js/TodoActions.js</strong> 中, 通过其中的 <code>AppDispatcher</code> 单例，我们可以将 Action 派发出去:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> TodoActions = &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建行为 </span></span><br><span class="line"><span class="comment">     * @param text &#123;string&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    create: <span class="function"><span class="keyword">function</span> (<span class="params">text</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 将创建行为送到 Dispatcher, Dispatcher 派发这个行为(action 对象) 到各个 Store</span></span><br><span class="line">        AppDispatcher.dispatch(&#123;</span><br><span class="line">            actionType: TodoConstants.TODO_CREATE,</span><br><span class="line">            text: text</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新行为</span></span><br><span class="line"><span class="comment">     * @param id &#123;string&#125;</span></span><br><span class="line"><span class="comment">     * @param text &#123;string&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    updateText: <span class="function"><span class="keyword">function</span> (<span class="params">id, text</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 全部设置为完成</span></span><br><span class="line"><span class="comment">     * @param todo</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    toggleComplete: <span class="function"><span class="keyword">function</span> (<span class="params">todo</span>) </span>&#123;</span><br><span class="line">       <span class="comment">// ...</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 标记所有的 Todo 为已完成</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    toggleCompleteAll: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    destroy: <span class="function"><span class="keyword">function</span> (<span class="params">id</span>) </span>&#123;</span><br><span class="line">       <span class="comment">// ...</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除所有已完成的 Todo</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    destroyCompleted: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Components"><a href="#Components" class="headerlink" title="Components"></a>Components</h4><p>下面开始实现各个组件，个人偏向的流程是先在组件目录下创建好各个空白组件，之后再依序进行装填：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> React = <span class="built_in">require</span>(<span class="string">'react'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Header = React.createClass(&#123;</span><br><span class="line"></span><br><span class="line">    render: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span>:render</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Header;</span><br></pre></td></tr></table></figure><p>装填顺序我会选择先装填顶部容器（此例中即为 TodoApp ），之后按照 DOM 树 <strong> 自底向上 </strong> 地进行装填:</p><p><strong>TodoApp.react.js</strong>:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Footer = <span class="built_in">require</span>(<span class="string">'./Footer.react'</span>);</span><br><span class="line"><span class="keyword">var</span> Header = <span class="built_in">require</span>(<span class="string">'./Header.react'</span>);</span><br><span class="line"><span class="keyword">var</span> MainSection = <span class="built_in">require</span>(<span class="string">'./MainSection.react'</span>);</span><br><span class="line"><span class="keyword">var</span> React = <span class="built_in">require</span>(<span class="string">'react'</span>);</span><br><span class="line"><span class="keyword">var</span> TodoStore = <span class="built_in">require</span>(<span class="string">'../stores/TodoStore'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在根 DOM 下维护状态,</span></span><br><span class="line"><span class="comment">// 这样的状态往往是共享状态(会向下传递的状态)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTodoState</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        allTodos: TodoStore.getAll(),</span><br><span class="line">        areAllComplete: TodoStore.areAllComplete()</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> TodoApp = React.createClass(&#123;</span><br><span class="line">    getInitialState: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getTodoState();</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定生命期 -- 挂载</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    componentDidMount: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 挂载时再为 TodoStore 添加监听器</span></span><br><span class="line">        TodoStore.addChangeListener(<span class="keyword">this</span>._onChange);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    componentWillUnmount: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        TodoStore.removeChangeListener(<span class="keyword">this</span>._onChange);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    render: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;Header /&gt;</span><br><span class="line">                &lt;MainSection</span><br><span class="line">                    allTodos=&#123;<span class="keyword">this</span>.state.allTodos&#125;</span><br><span class="line">                    areAllComplete=&#123;<span class="keyword">this</span>.state.areAllComplete&#125;</span><br><span class="line">                /&gt;</span><br><span class="line">                &lt;Footer allTodos=&#123;<span class="keyword">this</span>.state.allTodos&#125;/&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    /</span>**</span><br><span class="line">     * Event handler <span class="keyword">for</span> <span class="string">'change'</span> events coming <span class="keyword">from</span> the TodoStore</span><br><span class="line">     *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">    _onChange: function() &#123;</span></span><br><span class="line"><span class="regexp">        this.setState(getTodoState());</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">module.exports = TodoApp;</span></span><br></pre></td></tr></table></figure><blockquote><p>为了方便，TodoApp 不仅维护 allTodos 这个状态，还维护 areAllComplete，该状态主要服务于 MainSection 中的 “完成所有 / 取消完成所有任务” 这一用例，避免重复遍历 allTodos 的开销。</p></blockquote><p>我们可以看到，TodoApp 提供了一个 <code>onChange()</code> 方法作为 TodoStore 的 <code>change</code> 事件的回调，当 TodoStore 发出 change 事件时，TodoApp 将刷新状态，借此通知其下组件如 MainSection 等重新渲染。</p><p>更多组件的实现不再赘述。下面着重介绍 Flux 的工作流程</p><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>我们以 创建新的 Todo 这一工作流程为例展示 Flux 的工作过程。在 Flux 中，该流程如下图所示：</p><div style="text-align:center"><br><img src="https://www.lucidchart.com/publicSegments/view/49534565-8e62-4836-a6ca-e616269ba094/image.png" width="500"><br></div><p>（1） 我们在 TodoTextInput 中敲入数据，在输入框上，我们监听了 <strong> 失焦(onBlur)</strong> 和 <strong> 按下键盘按键(onKeyDown)</strong> 的事件：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js/components/TodoTextInput.react.js</span></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @return &#123;object&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) /*<span class="title">object</span>*/ </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;input</span><br><span class="line">        className=&#123;<span class="keyword">this</span>.props.className&#125;</span><br><span class="line">        id=&#123;<span class="keyword">this</span>.props.id&#125;</span><br><span class="line">        placeholder=&#123;<span class="keyword">this</span>.props.placeholder&#125;</span><br><span class="line">        onBlur=&#123;<span class="keyword">this</span>._save&#125;</span><br><span class="line">        onChange=&#123;<span class="keyword">this</span>._onChange&#125;</span><br><span class="line">        onKeyDown=&#123;<span class="keyword">this</span>._onKeyDown&#125;</span><br><span class="line">        value=&#123;<span class="keyword">this</span>.state.value&#125;</span><br><span class="line">        autoFocus=&#123;<span class="literal">true</span>&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>当事件发生时，调用 <code>save()</code> 方法进行处理：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_save: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.props.onSave(<span class="keyword">this</span>.state.value);</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      value: <span class="string">''</span></span><br><span class="line">    &#125;);</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><p>（2） 在 Header 组件中，我们通过为 TodoTextInput 指定 <code>onSave</code> 属性（props）来确定当输入域发生变化后的执行逻辑，使得我们在 TodoTextInput 的状态发生改变时，能够发出一个 “创建行为” 到 Dispatcher：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js/components/Header.react.js</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @return &#123;object&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;header id=<span class="string">"header"</span>&gt;</span><br><span class="line">        &lt;h1&gt;todos&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;TodoTextInput</span></span><br><span class="line"><span class="regexp">          id="new-todo"</span></span><br><span class="line"><span class="regexp">          placeholder="What needs to be done?"</span></span><br><span class="line"><span class="regexp">          onSave=&#123;this._onSave&#125;</span></span><br><span class="line"><span class="regexp">        /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/header&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  /</span>**</span><br><span class="line">   * Event handler called within TodoTextInput.</span><br><span class="line">   * Defining <span class="keyword">this</span> here allows TodoTextInput to be used <span class="keyword">in</span> multiple places</span><br><span class="line">   * <span class="keyword">in</span> different ways.</span><br><span class="line">   * @param &#123;string&#125; text</span><br><span class="line">   *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">  _onSave: function(text) &#123;</span></span><br><span class="line"><span class="regexp">    if (text.trim())&#123;</span></span><br><span class="line"><span class="regexp">      TodoActions.create(text);</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br></pre></td></tr></table></figure><p>我们之所以不在 TodoTextInput 中写死 <code>TodoActions.create(text)</code> 主要是考虑到组件的可扩展性。“输入域变动后的存储逻辑”更应当被设计为一种配置，通过在不同场景下指定其 <code>onSave</code> 属性（prop），使得 TodoTextInput 更加通用。</p><p>（3） 在 <code>TodoActions.create()</code> 中，我们将 Action 送到 Dispatcher，并由其派发一个 “创建 Action”到<br>TodoStore：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js/actions/TodoActions.js</span></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @param  &#123;string&#125; text</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  create: <span class="function"><span class="keyword">function</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">    AppDispatcher.dispatch(&#123;</span><br><span class="line">      actionType: TodoConstants.TODO_CREATE,</span><br><span class="line">      text: text</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>（4） TodoStore 在接收到 Dispatcher 派发来的 Action 之后，其向 Dispatcher 注册的回调被调用, 新的 todo 会被持久化，并因此引起了 TodoStore 维护的 todos 的改变，所以 TodoStore 会抛出一个 change 事件：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js/stores/TodoStore.js</span></span><br><span class="line">AppDispatcher.register(<span class="function"><span class="keyword">function</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> text;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span>(action.actionType) &#123;</span><br><span class="line">    <span class="keyword">case</span> TodoConstants.TODO_CREATE:</span><br><span class="line">      text = action.text.trim();</span><br><span class="line">      <span class="keyword">if</span> (text !== <span class="string">''</span>) &#123;</span><br><span class="line">        create(text);</span><br><span class="line">        TodoStore.emitChange();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...  </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="comment">// no op</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>（5）由于 TodoApp 向 TodoStore 订阅了 change 事件：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js/components/TodoApp.react.js</span></span><br><span class="line">componentDidMount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    TodoStore.addChangeListener(<span class="keyword">this</span>._onChange);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>此时，change 事件发生，回调 <code>onChange()</code> 被触发, TodoApp 维护的状态得到更新：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Event handler for 'change' events coming from the TodoStore</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> _onChange: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.setState(getTodoState());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>（6） 由于 MainSection 及 Footer 组件中的属性（prop）绑定了 TodoApp 维护的状态，所以在 TodoApp 刷新状态 <code>setState()</code> 后，二者将会被重新渲染。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Flux-构成&quot;&gt;&lt;a href=&quot;#Flux-构成&quot; class=&quot;headerlink&quot; title=&quot;Flux 构成&quot;&gt;&lt;/a&gt;Flux 构成&lt;/h2&gt;&lt;p&gt;首先要明确的是，Flux 并不是一个前端框架，而是前端的一个设计模式，一个状态管理机制，其把前端的一个交互流程简单的模拟成了一个单向数据流。&lt;/p&gt;
&lt;div style=&quot;text-align:center&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://facebook.github.io/flux/img/flux-simple-f8-diagram-1300w.png&quot; width=&quot;500&quot;&gt;&lt;br&gt;&lt;/div&gt;

&lt;p&gt;在上图中，我们可以看到 Flux 的四个核心构成：&lt;/p&gt;
    
    </summary>
    
      <category term="React" scheme="http://yoyoyohamapi.me/categories/React/"/>
    
    
      <category term="JavaScript" scheme="http://yoyoyohamapi.me/tags/JavaScript/"/>
    
      <category term="React" scheme="http://yoyoyohamapi.me/tags/React/"/>
    
      <category term="Flux" scheme="http://yoyoyohamapi.me/tags/Flux/"/>
    
  </entry>
  
  <entry>
    <title>深入理解 throttle 与 debounce</title>
    <link href="http://yoyoyohamapi.me/2016/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-throttle-%E4%B8%8E-debounce/"/>
    <id>http://yoyoyohamapi.me/2016/05/29/深入理解-throttle-与-debounce/</id>
    <published>2016-05-29T00:26:38.000Z</published>
    <updated>2018-08-11T14:20:10.016Z</updated>
    
    <content type="html"><![CDATA[<p>我们先来看一个前端开发中遇到的场景：</p><blockquote><p>在页面中，我们有一个 “查询” 按钮，单击该按钮，会通过 <strong>ajax</strong> 异步查询一些数据</p></blockquote><p>假设这个查询是耗时的，并且会给后端造成一定压力，那么如果短时间内我们频繁点击该按钮，请求就会不断发出，这样给后端造成的压力是难以想象的。因此，我们会想到控制我们的查询速率。</p><a id="more"></a><h2 id="独占型提交"><a href="#独占型提交" class="headerlink" title="独占型提交"></a>独占型提交</h2><p>通过设置一个 <code>flag</code> 来标识当前状态为正在请求中，如果已在请求中，则不允许再次请求，请求完成，刷新该 <code>flag</code> 来允许新的请求提交：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isQuerying = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sendQuery = <span class="function"><span class="keyword">function</span>(<span class="params">complete</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果已经在查询了，那么需要等待 </span></span><br><span class="line">  <span class="keyword">if</span>(isQuerying)&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"waiting"</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"send query"</span>);</span><br><span class="line">  <span class="comment">// 标识当前正在查询中 </span></span><br><span class="line">  isQuerying = <span class="literal">true</span>;</span><br><span class="line">  <span class="comment">// 我们模拟一个耗时操作 </span></span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   complete &amp;&amp; complete();    </span><br><span class="line">  &#125;,<span class="number">2000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> complete = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 在回调中， 我们刷新标记量 </span></span><br><span class="line">   isQuerying = <span class="literal">false</span>;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"completed"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$(<span class="string">"#queryBtn"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;sendQuery(complete);&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试一下， 可以看到新的请求不再立即被送出 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++) &#123;</span><br><span class="line">  $(<span class="string">"#queryBtn"</span>).click();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="节制型提交"><a href="#节制型提交" class="headerlink" title="节制型提交"></a>节制型提交</h2><p>在独占型提交中，如果一个请求已经在进行中，那么再多的点击都会被废弃。如果我们只是想限制请求速率，而不想废弃掉之后的点击，那我们得考虑新的提交方式。回归到限制提交的问题本质：</p><blockquote><p>控制回调发生的速率, 不需要回调发生那么快</p></blockquote><p>但是，如果我们新建一个 wrapper 来包裹一下 <code>sendQuery</code> 业务：在 <code>click</code> 事件后，不会直接调用 <code>sendQuery</code>，而是调用 wrapper，在 wrapper 的执行过程中，我们有选择地考虑是否执行 <code>sendQuery</code>，借此控制住 <code>sendQuery</code> 的调用频率。</p><p>假设我们想至少等待 1s 才能发出一次新的查询请求，即请求的调用频次不能超过 <strong>1 次 / 秒 </strong>，可以这样设计：</p><ol><li>开始：<code>click</code> 事件到来， wrapper 被调用<br>.    获得当前时间，比较当前时间距上次 <code>sendQuery</code> 执行的时间是否已经足够 <code>1s</code> 。<br>.    如果已经足够，那么这次查询请求可以立即被执行，否则计算应该等待的时间，延后执行该请求。</li></ol><p>看代码:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> previous = <span class="number">0</span>； <span class="comment">// 记录上次执行的时间点 </span></span><br><span class="line"><span class="keyword">var</span> waiting = <span class="number">1000</span>; <span class="comment">// 需要等待的时间 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sendQuery = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 执行的时候， 刷新 previous</span></span><br><span class="line">  previous = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"sending query"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获得当前时间 </span></span><br><span class="line">  <span class="keyword">var</span> now = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();</span><br><span class="line">  <span class="comment">// 获得需要等待的时间 </span></span><br><span class="line">  <span class="keyword">var</span> remain = waiting-(now-previous);</span><br><span class="line">  <span class="comment">// 判断是否立即执行 </span></span><br><span class="line">  <span class="keyword">if</span>(remain&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">    sendQuery();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    setTimeout(sendQuery, remain);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了防止变量的全局污染， 我们再用一个立即执行函数包裹下作用域：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> delayedQuery = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> previous = <span class="number">0</span>; <span class="comment">// 记录上次执行的时间点 </span></span><br><span class="line">  <span class="keyword">var</span> waiting = <span class="number">1000</span>; <span class="comment">// 需要等待的时间 </span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> sendQuery = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 执行的时候， 刷新 previous</span></span><br><span class="line">    previous = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"sending query"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获得当前时间 </span></span><br><span class="line">    <span class="keyword">var</span> now = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();</span><br><span class="line">    <span class="comment">// 获得需要等待的时间 </span></span><br><span class="line">    <span class="keyword">var</span> remain = waiting - (now - previous);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"need waiting"</span> + remain + <span class="string">"ms"</span>);</span><br><span class="line">    <span class="comment">// 判断是否立即执行 </span></span><br><span class="line">    <span class="keyword">if</span> (remain &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"immediately"</span>);</span><br><span class="line">      sendQuery();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"delayed"</span>);</span><br><span class="line">      setTimeout(sendQuery, remain);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">$(<span class="string">"#queryBtn"</span>).click(delayedQuery);</span><br></pre></td></tr></table></figure><p>但是，我们的业务代码 <code>sendQuery</code> 还是耦合了刷新 <code>previous</code> 的逻辑。其次，如果每个延迟执行的诉求都要去做这样一个包裹，样板代码就显得太多了。现在我们撰写一个通用函数，我们将（1）<strong> 需要控制调用频度的函数 </strong> 和（2）<strong> 对调用频度的限制平率 </strong> 告诉通用函数，它返回一个限制了执行频率的函数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * throttle</span></span><br><span class="line"><span class="comment"> * @param &#123;Function&#125; func 待控制频率的函数 </span></span><br><span class="line"><span class="comment"> * @param &#123;Number&#125; waiting 每次调用的最小等待周期 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func,waiting</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> previous = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个 func 的 wrapper，如要是解耦 func 与 previous 等变量 </span></span><br><span class="line">  <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 刷新 previous</span></span><br><span class="line">    previous = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();</span><br><span class="line">    <span class="comment">// 执行调用 </span></span><br><span class="line">    func();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回一个被控制了调用频率的 </span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获得当前时间 </span></span><br><span class="line">      <span class="keyword">var</span> now = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();</span><br><span class="line">      <span class="comment">// 获得需要等待的时间 </span></span><br><span class="line">      <span class="keyword">var</span> remain = waiting - (now - previous);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"need waiting"</span> + remain + <span class="string">"ms"</span>);</span><br><span class="line">      <span class="comment">// 判断是否立即执行 </span></span><br><span class="line">      <span class="keyword">if</span> (remain &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"immediately"</span>);</span><br><span class="line">        later();</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"delayed"</span>);</span><br><span class="line">        setTimeout(later, remain);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在，刷新 previous 不再需要耦合到 sendQuery 中 </span></span><br><span class="line"><span class="keyword">var</span> sendQuery = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"sending query"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">delayedQuery = throttle(sendQuery,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p><a href="https://jsfiddle.net/softshot/r6uh3xug/2/" target="_blank" rel="noopener">查看演示</a></p><h2 id="Underscore-中的-throttle"><a href="#Underscore-中的-throttle" class="headerlink" title="Underscore 中的 throttle"></a>Underscore 中的 throttle</h2><p>可以看出来， 这里我已经用了 <code>throttle</code> 来命名我们的函数了，<code>throttle</code>，也就是节流阀的意思，很形象是吧，通过这样一个阀门，我们限制函数的执行频次。</p><p>但是在上面的代码中，还有一点小问题，一些查询请求虽然被延迟执行了，但是在某个时间点，他们好像一起执行了，这是因为 <code>setTimeout(func, wait)</code> 并不能保证 <code>func</code> 的执行开始时间，只能保证 <code>func</code> 在不早于从现在起到 <code>wait</code> 毫秒后发生。所以被延后执行的那些查询在某个相近的时间点同时发生了。</p><p>出现这个错误的原因就是：</p><blockquote><p>我们只保障了 <strong> 第一次回调 </strong> 和 <strong> 接下来所有回调 </strong> 的间隔执行，而没有保障到各个回调间相互的间隔执行。</p></blockquote><p>下面可以看一下 Underscore 中 <code>throttle</code> 的实现，比刚才我们写的 throttle 函数健壮许多。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.throttle = <span class="function"><span class="keyword">function</span> (<span class="params">func, wait, options</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// timeout 标识最近一次被追踪的调用 </span></span><br><span class="line">    <span class="comment">// context 和 args 缓存 func 执行时需要的上下文，result 缓存 func 执行结果 </span></span><br><span class="line">    <span class="keyword">var</span> timeout, context, args, result;</span><br><span class="line">    <span class="comment">// 最近一次 func 被调用的时间点 </span></span><br><span class="line">    <span class="keyword">var</span> previous = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!options) options = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个延后执行的函数包裹住 func 的执行过程 </span></span><br><span class="line">    <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 执行时，刷新最近一次调用时间 </span></span><br><span class="line">        previous = options.leading === <span class="literal">false</span> ? <span class="number">0</span> : _.now();</span><br><span class="line">        <span class="comment">// 清空为此次执行设置的定时器 </span></span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">        result = func.apply(context, args);</span><br><span class="line">        <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个 throttle 化的函数 </span></span><br><span class="line">    <span class="keyword">var</span> throttled = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 我们尝试调用 func 时，会首先记录当前时间戳 </span></span><br><span class="line">        <span class="keyword">var</span> now = _.now();</span><br><span class="line">        <span class="comment">// 是否是第一次调用 </span></span><br><span class="line">        <span class="keyword">if</span> (!previous &amp;&amp; options.leading === <span class="literal">false</span>) previous = now;</span><br><span class="line">        <span class="comment">// func 还要等待多久才能被调用 = 预设的最小等待期 -（当前时间 - 上一次调用的时间）</span></span><br><span class="line">        <span class="keyword">var</span> remaining = wait - (now - previous);</span><br><span class="line">        <span class="comment">// 记录执行时需要的上下文和参数 </span></span><br><span class="line">        context = <span class="keyword">this</span>;</span><br><span class="line">        args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="comment">// 如果计算后能被立即执行 </span></span><br><span class="line">        <span class="keyword">if</span> (remaining &lt;= <span class="number">0</span> || remaining &gt; wait) &#123;</span><br><span class="line">            <span class="comment">// 清除之前的设置的延时执行，就不存在某些回调一同发生的情况了 </span></span><br><span class="line">            <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">                clearTimeout(timeout);</span><br><span class="line">                timeout = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 刷新最近一次 func 调用的时间点 </span></span><br><span class="line">            previous = now;</span><br><span class="line">            <span class="comment">// 执行 func 调用 </span></span><br><span class="line">            result = func.apply(context, args);</span><br><span class="line">            <span class="comment">// 再次检查 timeout，因为 func 执行期间可能有新的 timeout 被设置，如果 timeout 被清空了，代表不再有等待执行的 func，也清空 context 和 args</span></span><br><span class="line">            <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!timeout &amp;&amp; options.trailing !== <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果设置了 trailing edge，那么暂缓此次调用尝试的执行 </span></span><br><span class="line">            timeout = setTimeout(later, remaining);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不再控制函数执行调用频率 </span></span><br><span class="line">    throttled.cancel = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">        previous = <span class="number">0</span>;</span><br><span class="line">        timeout = context = args = <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> throttled;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>与我们所写的 <code>throttle</code> 不同的是，Underscore 中的 <code>throttle</code> 并不需要为每次回调都设置一个定时器来延后执行。他的定时器只记录最新一次的调用尝试。比如 <code>waiting</code> 为 <code>1s</code>，在 <code>1.5s</code> 内我们单击了查询按钮 <code>20</code> 次，真正会被送出的查询只有至多两次，分别是第一次和最后一次。这就不会出现上面延时中出现的 “某时刻一些延时函数同时发生” 的情况了。</p><p>在 Underscore 的 <code>throttle</code> 实现中，有个令人疑惑的判断条件：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (remaining &lt;= <span class="number">0</span> || remaining &gt; wait) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当该条件成立时， 可以立即执行 <code>func</code>，<code>remaining&lt;=0</code> 的条件很容易理解，就是 <strong> 不再需要等待时 </strong> 可以执行，那么如何理解 <code>remaining &gt; wait</code> 呢?</p><p>显然，<code>remaining&gt;wait</code> 等同于 <code>now&lt;previous</code>， 亦即：<code>previous</code> 的被刷新晚于 <code>now</code> 的被设置。</p><p>这种情况就发生在我们当前尝试调用时，并且设置了当前时间点 <code>now</code> 之后，上次延时的函数 <code>later</code> 开始了执行， 并刷新了 <code>previous</code>，此时出现了 <code>now</code> 早于 <code>previous</code> 的情况。举个栗子：</p><ol><li>开始时，我们 <code>click</code> 了一次查询按钮，我们将之命名为 <code>click1</code>，此时 <code>previous==0</code><br>.    在 <code>0.4s</code> 时我们 <code>click</code> 了一次查询按钮 <code>click2</code>，<code>now==0.4</code>, <code>previous==0</code>, 则这次点击的查询会至少等待 <code>0.6s</code> 才送出，也就是最快要在 <code>1s</code> 的时候 <code>click2</code> 的查询请求才送出。（由于 <code>setTimeout(func, wait)</code> 并不能保证 <code>func</code> 的执行开始时间，只能保证 <code>func</code> 不早于从现在起到 <code>wait</code> 毫秒后发生， 所以 <code>click2</code> 的查询请求并不一定在 <code>1s</code> 时就能够被送出）<br>.    在 <code>1.2s</code> 时，产生 <code>click3</code>，<code>now==1.2</code></li></ol><p>那么就会存在如下两种情况：</p><ul><li><code>click2</code> 的查询先于 <code>click3</code> 发生，比如在 <code>1.1s</code> 时 <code>click2</code> 的回调被执行，那么 <code>click3</code> 的回调要等 <code>1-(1.2-1.1)==0.9s</code> 才发生<br>   <code>1.3s</code> 时 <code>click2</code> 的查询请求开始执行，<code>previous==1.3</code>，<code>remaining=1-(1.2-1.3)==1.1&gt;1</code>，此时，Underscore 会让 <code>click3</code> 的查询请求也开始执行（既不会停止 <code>click</code> 的查询请求，也不会停止 <code>click3</code> 的查询请求），<code>click3</code> 和 <code>click2</code> 的返回结果取最近一次。</li></ul><h3 id="leading-edge-与-trailing-edge"><a href="#leading-edge-与-trailing-edge" class="headerlink" title="leading edge 与 trailing edge"></a>leading edge 与 trailing edge</h3><p>underscore 中的 <code>throttle</code> 函数提供了第三个参数 <code>options</code> 来进行选项配置，并且支持如下两个参数：</p><ol><li><code>leading</code>：是否设置 <strong> 节流前缘 </strong> – <code>leading edge</code>。前缘的作用是保证第一次尝试调用的 <code>func</code> 会被立即执行，否则第一次调用也必须等待 <code>wait</code> 时间，默认为 <code>true</code>。<br>.    <code>trailing</code>：是否设置 <strong> 节流后缘 </strong> – <code>trailing edge</code>。后缘的作用是：当最近一次尝试调用 <code>func</code> 时，如果 <code>func</code> 不能立即执行，会延后 <code>func</code> 的执行，默认为 <code>true</code>。</li></ol><p>这两个配置会带来总共四种组合，通过 <a href="https://jsfiddle.net/softshot/Lakgk99q/9/" target="_blank" rel="noopener">这个演示</a>，观察不同组合的效果。</p><h2 id="debounce"><a href="#debounce" class="headerlink" title="debounce"></a>debounce</h2><p>在实际项目中，我们还有一种需求，就是如果过于频繁的尝试调用某个函数时，只允许一次调用成功执行。仍然以点击查询按钮异步查询为例，假设我们每次点击的时间间隔都在 <code>1s</code> 内，那么所有的点击只有一次能送出请求，要么是第一次，要么是最后一次。显然，<code>throttle</code> 是做不到这点的，<code>throttle</code> 会至少送出两次请求。针对于此，Underscore 又撰写了 <code>debounce</code> 函数。</p><p>顾名思义， <code>debounce</code> – 防反跳，就是不再跳起，不再响应的意思。</p><blockquote><p><code>throttle</code> 和 <code>debounce</code> 并非 Underscore 独有，他们不仅仅是函数，也是解决问题的方式，诸如 jquery，lodash 等知名库都提供了这两个方法。</p></blockquote><p>从下面的 <code>debounce</code> 实现我们可以看到，不同于 <code>throttle</code>，<code>debounce</code> 不再计算 <code>remain</code> 时间，其提供的 <code>immediate</code> 参数类似于 <code>throttle</code> 中的对于 <code>leading-edge</code> 和 <code>trailing-edge</code> 的控制：</p><ul><li><code>immediate === true</code>，开启 <code>leading-edge</code>，可以执行时立即执行<br>   <code>immediate === false</code>（默认）开启 <code>trailing-edge</code>，可以执行时也必须延后至少 <code>wait</code> 个时间才能执行。</li></ul><p>因此，<code>debounce</code> 后的 <code>func</code> 要么立即获得响应，要么延迟一段时间才响应，<a href="https://jsfiddle.net/softshot/gamLjgcn/" target="_blank" rel="noopener">查看演示</a>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.debounce = <span class="function"><span class="keyword">function</span> (<span class="params">func, wait, immediate</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> timeout, result;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span> (<span class="params">context, args</span>) </span>&#123;</span><br><span class="line">            timeout = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (args) result = func.apply(context, args);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> debounced = restArgs(<span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 每次新的尝试调用 func，会使抛弃之前等待的 func</span></span><br><span class="line">            <span class="keyword">if</span> (timeout) clearTimeout(timeout);</span><br><span class="line">            <span class="comment">// 如果允许新的调用尝试立即执行，</span></span><br><span class="line">            <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">                <span class="comment">// 如果之前尚没有调用尝试，那么此次调用可以立马执行，否则就需要等待 </span></span><br><span class="line">                <span class="keyword">var</span> callNow = !timeout;</span><br><span class="line">                <span class="comment">// 刷新 timeout</span></span><br><span class="line">                timeout = setTimeout(later, wait);</span><br><span class="line">                <span class="comment">// 如果能被立即执行，立即执行 </span></span><br><span class="line">                <span class="keyword">if</span> (callNow) result = func.apply(<span class="keyword">this</span>, args);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 否则，这次尝试调用会延时 wait 个时间 </span></span><br><span class="line">                timeout = _.delay(later, wait, <span class="keyword">this</span>, args);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        debounced.cancel = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            clearTimeout(timeout);</span><br><span class="line">            timeout = <span class="literal">null</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> debounced;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="debounce-1"><a href="#debounce-1" class="headerlink" title="debounce"></a>debounce</h3><p>一定要记住，<code>debounce</code> 满足的是：</p><blockquote><p>高频下只响应一次</p></blockquote><ol><li>遇上疯狂打字员，在输入框快速输入文字（高频），但是我们只想在其完全停止输入时再对输入文字做出处理（一次）。<br>.    AJAX，多数场景下，每个异步请求在短时间只能响应一次。比如下拉刷新，不停的到底（高频），但只发送一次 ajax 请求（一次）。</li></ol><h3 id="throttle"><a href="#throttle" class="headerlink" title="throttle"></a>throttle</h3><p>相比 <code>debounce</code>，<code>throttle</code> 要更加宽松一些，其目的在于:</p><blockquote><p>按频率执行调用。</p></blockquote><ol><li>游戏中的按键响应，比如格斗，比如射击，需要控制出拳和射击的速率。<br>.    自动完成，按照一定频率分析输入，提示自动完成。<br>.    鼠标移动和窗口滚动，鼠标稍微移动一下，窗口稍微滚动一下会带来大量的事件，因而需要控制回调的发生频率。</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://drupalmotion.com/article/debounce-and-throttle-visual-explanation" target="_blank" rel="noopener">Debounce and Throttle: a visual explanation</a><br>   <a href="https://www.zhihu.com/question/19805411" target="_blank" rel="noopener">知乎 @长天之云的回答</a><br>   <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setTimeout" target="_blank" rel="noopener">MDN setTimeout</a><br>   <a href="https://blog.coding.net/blog/the-difference-between-throttle-and-debounce-in-underscorejs" target="_blank" rel="noopener">浅谈 Underscore.js 中 <em>.throttle 和 </em>.debounce 的差异</a><br>   <a href="http://www.easyui.info/archives/1853.html" target="_blank" rel="noopener">Underscore 之 throttle 函数源码分析以及使用注意事项</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们先来看一个前端开发中遇到的场景：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在页面中，我们有一个 “查询” 按钮，单击该按钮，会通过 &lt;strong&gt;ajax&lt;/strong&gt; 异步查询一些数据&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;假设这个查询是耗时的，并且会给后端造成一定压力，那么如果短时间内我们频繁点击该按钮，请求就会不断发出，这样给后端造成的压力是难以想象的。因此，我们会想到控制我们的查询速率。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript 函数式编程" scheme="http://yoyoyohamapi.me/categories/JavaScript-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="函数式编程" scheme="http://yoyoyohamapi.me/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>闭包的一个经典实例和认识误区</title>
    <link href="http://yoyoyohamapi.me/2016/03/18/%E9%97%AD%E5%8C%85%E7%9A%84%E4%B8%80%E4%B8%AA%E7%BB%8F%E5%85%B8%E5%AE%9E%E4%BE%8B%E5%92%8C%E8%AE%A4%E8%AF%86%E8%AF%AF%E5%8C%BA/"/>
    <id>http://yoyoyohamapi.me/2016/03/18/闭包的一个经典实例和认识误区/</id>
    <published>2016-03-18T01:28:54.000Z</published>
    <updated>2018-02-14T17:00:34.652Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>假定我们页面上有 5 个按钮，分别为 按钮 0，…， 按钮 4，如下图所示：</p><div style="text-align:center"><br><img src="http://7pulhb.com2.z0.glb.clouddn.com/%E9%97%AD%E5%8C%85-%E9%A1%B5%E9%9D%A2.png" width="500"><br></div><a id="more"></a><p>现在，我们想为该按钮绑定一个事件：当鼠标点击按钮时，弹出显示框展示按钮索引，对于一些 JavaScript 的初学者来说，不由分说地就写出了下面的代码：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span> 闭包经典例子 < span class="tag">&lt;/<span class="name">title</span>&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span>&gt;</span> 按钮 0<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span>&gt;</span> 按钮 1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span>&gt;</span> 按钮 2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span>&gt;</span> 按钮 3<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span>&gt;</span> 按钮 4<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> buttons = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'button'</span>);</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">for</span>(<span class="keyword">var</span> i= <span class="number">0</span>,length = buttons.length;i&lt;length;i++) &#123;</span></span><br><span class="line"><span class="actionscript">        buttons[i].onclick = <span class="function"><span class="keyword">function</span> <span class="title">click</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="undefined">            alert(i);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>事与愿违，当我们运行上述页面时，无论我们单击那个按钮，都会弹出如下信息，对的，他们全部都弹出一样的值：</p><div style="text-align:center"><br><img src="http://7pulhb.com2.z0.glb.clouddn.com/%E9%97%AD%E5%8C%85-alert%285%29.png" width="200"><br></div><p>我一直认为这是一个极好的关于的闭包的例子，因为这个问题：</p><blockquote><p>由闭包而起，也由闭包而消除</p></blockquote><p>现在，我们认识闭包，我最喜欢的对于闭包的解释是：</p><blockquote><p>“函数在当前词法作用域之外执行，就产生了闭包” – KYLE SIMPSON</p></blockquote><p>在 JavaScript 中，作用域大多只存在于 <strong> 函数作用域（try-catch 也可以模拟作用域）</strong>，而不存在诸如 Java 等语言中的块级作用域 <code>{}</code>。</p><p>现在，既然我们的点击事件能够发生，就说明各个按钮的 <code>onclick</code> 属性是成功绑定的，出错的位置应该发生在 <code>click()</code> 函数内部。进一步分析：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">click</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <a href="https://book.douban.com/subject/3590768/" target="_blank" rel="noopener">《JavaScript 语言精粹》</a> 中，描述到：</p><blockquote><p><code>click()</code> 绑定了变量 <code>i</code> 本身，而没有绑定变量 <code>i</code> 的值</p></blockquote><p>但作者 CrockFord 也并未对造成这样局面的原因多说一句。之所以这样，是因为在 JavaScript 中，对于引用指向的值的确定将会放在 <strong> 运行时 </strong> 确定，取值过程称之为 retrieve。在页面初始化过程中，由于 <code>click()</code> 函数没有调用，亦即 <code>click()</code> 的执行体并没有进入运行时环境，能够确定的仅只是 <code>alert()</code> 函数需要一个引用为 <code>i</code> 的参数，而并不知道对应的 <code>i</code> 的值。</p><p>当我们点击某个按钮时，发生如下的函数的调用，进入 <code>click()</code> 的 <code>运行时</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">click();</span><br></pre></td></tr></table></figure><p>然后我们会去执行：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert(i);</span><br></pre></td></tr></table></figure><p>为了执行 <code>alert()</code> 函数，需要为其提供参数 <code>i</code>（retrieve <code>i</code>）。更准确地说，就是设法找到 <code>i</code> 指向的值，在 <code>click</code> 函数作用域下，我们并不能找到 <code>i</code>。在 Firefox 下，我们可以利用 Firebug 看到，确实，在 <code>click</code> 函数作用域下，并没有参数 <code>i</code>。</p><div style="text-align:center"><br><img src="http://7pulhb.com2.z0.glb.clouddn.com/%E9%97%AD%E5%8C%85-click%E4%BD%9C%E7%94%A8%E5%9F%9F.png" width="600"><br></div><p>那么我们就回到 <code>click</code> 函数作用域的上一级作用域寻找，在 <code>load()</code> 函数作用域下成功找到 <code>i</code> 值：</p><div style="text-align:center"><br><img src="http://7pulhb.com2.z0.glb.clouddn.com/%E9%97%AD%E5%8C%85-load%E6%89%BE%E5%88%B0i.png" width="600"><br></div><p>基于其他语言的看法，我们可能会认为 <code>load()</code> 函数在执行完成后（页面加载），就会丢弃他自己的局部变量 <code>i</code>, 但是由于 <code>click()</code> 函数需要，所以 <code>i</code> 仍然会驻留在内存当中，以供给 <code>click()</code> 使用。</p><p>这就是一次跨作用域形成的闭包，所以我说该问题由闭包而引起（很多身边的朋友在看到接下来用闭包解决该问题，就以为闭包是个解决问题的 <strong> 警官 </strong>，而忽略了这个问题的 <strong> 凶手 </strong> 之一也是闭包）。</p><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>在很多 JavaScript 书籍中，一般就直接摆出了解决该问题的方法，并没有做更多解释，所以很多人 “大概记住了” 解决问题的代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">buttons[i].onclick = (<span class="function"><span class="keyword">function</span> <span class="title">exec</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> j = i;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">click</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>现在先抛开解决的代码片，我们想一下，如果我们还是要依赖于循环的索引去绑定按钮的弹出文字，应该怎么办，我想，解决方案的核心应当是：</p><blockquote><p>“快照” 我们的循环索引 <code>i</code>，让按钮的点击事件函数能够真正绑定到索引 <strong> 值 </strong>，而不仅只是 <strong> 引用 </strong>。</p></blockquote><p>基于之前的知识，我们知道，要想确定一个引用指向的值，我们需要到达运行时环境，并且我们可以通过 <strong> 执行一次函数调用来到达运行时环境 </strong>，在运行时环境，我们产出需要绑定的值。所以，我们通过一个 <strong> 立即执行函数（也称为即时函数）</strong> <code>exec()</code> 来到达运行时环境，快照了 <code>i</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">buttons[i].onclick = (<span class="function"><span class="keyword">function</span> <span class="title">exec</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> j = i;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">click</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><div style="text-align:center"><br><img src="http://7pulhb.com2.z0.glb.clouddn.com/%E9%97%AD%E5%8C%85-%E4%BF%9D%E7%95%99%E7%9A%84j.png" width="600"><br></div><p>所以，我们又通过闭包实现了快照，解决了这个恼人的绑定问题。我更愿意把这个问题的产生和解决归纳为如下过程</p><ol><li>我们犯错是因为我们并没有绑定到循环索引的值，而只是绑定了引用 <code>i</code></li><li>JavaScript 的作用域是函数级别的，我们虽然没有在绑定函数中找到引用 <code>i</code> 对应的值，但是通过 <strong> 闭包（凶手）</strong> 形成的作用域链，我们最后还是拿到了 <code>i</code> 的值，它是最近的一次 <code>i</code> 值：5，并不是我们期望的。</li><li>然后我们知道可以通过函数调用进入运行时取得循环的索引的值，所以我们就通过一个立即函数来进入运行时。</li><li>仅仅取得值是不够的，我们还要缓存这个值，因为我们的事件依赖于这个值。所以，能够达到此目的的仍然是闭包，让闭包去强行包住我们要的值，此时，闭包是 <strong> 解决问题的保护伞 </strong>。</li></ol><h2 id="误区"><a href="#误区" class="headerlink" title="误区"></a>误区</h2><p>之前，我发现周围一些同学在认识这个例子的解决策略的时候，只认识到了 “其形”，也就产生如下的几个误区。</p><h3 id="误区之一：-通过立即执行函数解决问题"><a href="#误区之一：-通过立即执行函数解决问题" class="headerlink" title="误区之一： 通过立即执行函数解决问题"></a>误区之一： 通过立即执行函数解决问题</h3><p>有些同学认为是 <strong> 立即执行函数 </strong> 解决了这个问题。隔了几天，当他回顾着想要再写一遍解决代码的时候，他尝试回顾着 <code>立即执行函数</code> 这个概念，并写出了这样的代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">buttons[i].onclick = (<span class="function"><span class="keyword">function</span> <span class="title">exec</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">click</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>在这样的执行体中，我们并未能 <strong> 快照 </strong> 到循环索引。即便不通过立即函数，我们也能解决问题：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">buttons[i].onclick = exec();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">exec</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">click</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>产生这个误区的原因是：没有看到立即执行函数只是为了产生一次函数调用，从而进入运行时去追溯循环索引 <code>i</code> 的值。</p><h3 id="误区之二：通过标记值解决问题"><a href="#误区之二：通过标记值解决问题" class="headerlink" title="误区之二：通过标记值解决问题"></a>误区之二：通过标记值解决问题</h3><p>同样的在看过解决代码后的几天，有的同学大概又只能依稀想起 <code>var j=i;</code>，然后仅用此去尝试解决问题：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">buttons[i].onclick = <span class="function"><span class="keyword">function</span> <span class="title">click</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> j = i;</span><br><span class="line">    alert(j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为没有进行运行时环境，所以我们并没有动态的对 <code>j</code> 进行赋值（ <code>var j=i</code> 并没有在循环内得到执行），所以最后当点击事件发生，执行到 <code>var j = i;</code> 时， 这一赋值操作需要去找到 <code>i</code>，我们仍然是在外层作用域找到了 <code>i</code>。</p><p>产生这种误区的原因是：忽略了函数体的逻辑只有在运行时才会发生，所以想要通过额外变量来记录循环索引，我们得想办法进入运行时。</p><p>同理，如下的代码片仍然不起作用，只是这次弹出显示的数字将永久为 4, 因为 <code>ii</code> 最后的一次赋值结果为 4;</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i= <span class="number">0</span>,length = buttons.length;i&lt;length;i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> ii = i;</span><br><span class="line">    buttons[i].onclick = <span class="function"><span class="keyword">function</span> <span class="title">click</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(ii);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h2&gt;&lt;p&gt;假定我们页面上有 5 个按钮，分别为 按钮 0，…， 按钮 4，如下图所示：&lt;/p&gt;
&lt;div style=&quot;text-align:center&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://7pulhb.com2.z0.glb.clouddn.com/%E9%97%AD%E5%8C%85-%E9%A1%B5%E9%9D%A2.png&quot; width=&quot;500&quot;&gt;&lt;br&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="JavaScript 学习笔记" scheme="http://yoyoyohamapi.me/categories/JavaScript-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="http://yoyoyohamapi.me/tags/JavaScript/"/>
    
      <category term="闭包" scheme="http://yoyoyohamapi.me/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>利用 Sails.js + MongoDB 开发博客系统（5） -- 个人信息维护</title>
    <link href="http://yoyoyohamapi.me/2015/05/05/%E5%88%A9%E7%94%A8-Sails-js-MongoDB-%E5%BC%80%E5%8F%91%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F%EF%BC%885%EF%BC%89-%E4%B8%AA%E4%BA%BA%E4%BF%A1%E6%81%AF%E7%BB%B4%E6%8A%A4/"/>
    <id>http://yoyoyohamapi.me/2015/05/05/利用-Sails-js-MongoDB-开发博客系统（5）-个人信息维护/</id>
    <published>2015-05-05T03:10:44.000Z</published>
    <updated>2018-08-11T14:19:27.101Z</updated>
    
    <content type="html"><![CDATA[<h2 id="章节概述"><a href="#章节概述" class="headerlink" title="章节概述"></a>章节概述</h2><p>在本章中，你将能学到如下知识:</p><ul><li>利用 skipper 来上传和存储文件。</li></ul><a id="more"></a><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>对于个人信息维护模块，我们暂时实现如下功能：</p><ul><li>头像更改：站点的头像仅支持 jpeg 格式，并保存到：/assets/images/avatar.jpg。</li><li>站点信息维护：包括站点名称以及站点介绍。</li></ul><p>其他诸如密码修改等功能留给读者自行完成。</p><h2 id="配置路由"><a href="#配置路由" class="headerlink" title="配置路由"></a>配置路由</h2><p>config/routes.js 添加:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//---------------User Profile</span></span><br><span class="line">    <span class="string">'/user/profile'</span>: <span class="string">'UserController.index'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="string">'/user/profile/avatar'</span>: <span class="string">'UserController.setAvatar'</span>,</span><br></pre></td></tr></table></figure><h2 id="业务逻辑撰写"><a href="#业务逻辑撰写" class="headerlink" title="业务逻辑撰写"></a>业务逻辑撰写</h2><p>Sails 中通过 <a href="https://github.com/balderdashy/skipper" target="_blank" rel="noopener"> skipper </a> 实现了<a href="http://www.sailsjs.org/documentation/concepts/file-uploads" target="_blank" rel="noopener">文件上传</a>，其核心函数是 <code>upload()</code>，其第一个参数可接受如下配置:</p><ul><li><code>dirname</code>：上传文件保存目录</li><li><code>maxBytes</code>：总的上传（不是单个文件）大小限制</li><li><code>saveAs</code>：如果该参数是字符串，表示单个文件的保存名，如果是函数，则对每个上传文件进行设置</li><li><code>onProcess</code>：每此上传过程中的回调逻辑</li></ul><p>api/controllers/UserController.js：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// 个人信息修改首页</span></span><br><span class="line">    index: <span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(req.method === <span class="string">'GET'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res.view(<span class="string">'user/index'</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跳转到设置头像页面</span></span><br><span class="line">    setAvatar: <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (req.method === <span class="string">'GET'</span>)</span><br><span class="line">            <span class="keyword">return</span> res.view(<span class="string">'user/avatar'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// POST 请求进行文件上传</span></span><br><span class="line">        <span class="comment">// 判断是否有文件上传</span></span><br><span class="line">        <span class="keyword">if</span> (!req.file(<span class="string">'avatar'</span>)._files[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> res.badRequest(<span class="string">'No file was uploaded'</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断文件类型是否争取</span></span><br><span class="line">        <span class="keyword">var</span> fileType = req.file(<span class="string">'avatar'</span>)._files[<span class="number">0</span>].stream.headers[<span class="string">'content-type'</span>];</span><br><span class="line">        <span class="keyword">if</span> (fileType != <span class="string">'image/jpeg'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res.badRequest(<span class="string">'文件类型错误, 仅支持 JPG 文件格式'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        req.file(<span class="string">'avatar'</span>).upload(&#123;</span><br><span class="line">            maxBytes: <span class="number">10000000</span>,</span><br><span class="line">            dirname: <span class="string">'../../assets/images'</span>,</span><br><span class="line">            saveAs: <span class="string">'avatar.jpg'</span></span><br><span class="line">        &#125;, <span class="function"><span class="keyword">function</span> <span class="title">whenDone</span>(<span class="params">err, uploadedFiles</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                <span class="keyword">return</span> res.negotiate(err);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> res.redirect(<span class="string">'/'</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div style="text-align:center"><br><img src="http://7pulhb.com1.z0.glb.clouddn.com/sails-5_article_profile.png" width="800"><br></div><blockquote><p>图像预览我选用的插件是<a href="https://github.com/blueimp/JavaScript-Load-Image" target="_blank" rel="noopener"> JavaScript-Load-Image</a></p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>利用 Sails + MongoDB 开发个人博客系统的教程就暂告段落，其实教程中很多东西未必是最佳实践（Best Practice），很多功能也尚未开发，本教程的写作动机和目的也不在于搭建一个博客系统，因为博主认为技术博客的最佳实践仍是静态博客。本教程的出发点还是在于让各位能够了解 Sails 开发 Web app 的流程及优化手段，也让各位接触一下 b ower，grunt，semantic-ui 这些前端工具。</p><p>真心希望各位能够对文章提出宝贵的意见与批评。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;章节概述&quot;&gt;&lt;a href=&quot;#章节概述&quot; class=&quot;headerlink&quot; title=&quot;章节概述&quot;&gt;&lt;/a&gt;章节概述&lt;/h2&gt;&lt;p&gt;在本章中，你将能学到如下知识:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;利用 skipper 来上传和存储文件。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="利用 Sails.js + MongoDB 开发博客系统" scheme="http://yoyoyohamapi.me/categories/%E5%88%A9%E7%94%A8-Sails-js-MongoDB-%E5%BC%80%E5%8F%91%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Sails" scheme="http://yoyoyohamapi.me/tags/Sails/"/>
    
      <category term="Node" scheme="http://yoyoyohamapi.me/tags/Node/"/>
    
      <category term="MongoDB" scheme="http://yoyoyohamapi.me/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>利用 Sails.js + MongoDB 开发博客系统（4）-- 文章模块</title>
    <link href="http://yoyoyohamapi.me/2015/05/04/%E5%88%A9%E7%94%A8-Sails-js-MongoDB-%E5%BC%80%E5%8F%91%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F%EF%BC%884%EF%BC%89-%E6%96%87%E7%AB%A0%E6%A8%A1%E5%9D%97/"/>
    <id>http://yoyoyohamapi.me/2015/05/04/利用-Sails-js-MongoDB-开发博客系统（4）-文章模块/</id>
    <published>2015-05-04T03:10:44.000Z</published>
    <updated>2018-02-14T17:00:58.206Z</updated>
    
    <content type="html"><![CDATA[<h2 id="章节概述"><a href="#章节概述" class="headerlink" title="章节概述"></a>章节概述</h2><p>在本章中，你将能学习到如下知识：</p><ul><li>认识 MongoDB 的 <code>mapReduce</code> 函数，并利用其实现标签统计功能。</li><li>认识 ES6 中的 Promise，了解其实现库 blue bird，为我们解决 Node 中难看的嵌套回调。</li><li>如何利用 markdown 来创建文章并完成代码高亮显示。</li></ul><a id="more"></a><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>我们将设计如下两个 document：</p><ul><li>文章（article）</li><li>分类（category）</li></ul><p>而评论将使用<a href="http://duoshuo.com/" target="_blank" rel="noopener">多说</a>。</p><h3 id="article-document"><a href="#article-document" class="headerlink" title="article document"></a>article document</h3><table><thead><tr><th>名称</th><th>说明</th><th>类型</th><th>限制</th></tr></thead><tbody><tr><td>title</td><td>文章标题</td><td>string</td><td>必选，长度 1-20 字符</td></tr><tr><td>content</td><td>文章内容</td><td>string</td><td>必选，不少于 1 个字符</td></tr><tr><td>author</td><td>作者</td><td>User</td><td>必选</td></tr><tr><td>tags</td><td>标签</td><td>array</td><td></td></tr><tr><td>category</td><td>分类</td><td>Category</td><td>默认：未分类</td></tr></tbody></table><h3 id="category-document"><a href="#category-document" class="headerlink" title="category document"></a>category document</h3><table><thead><tr><th>名称</th><th>说明</th><th>类型</th><th>限制</th></tr></thead><tbody><tr><td>name</td><td>名称</td><td>string</td><td>必选, 长度 1-20 字符</td></tr></tbody></table><h3 id="额外需求"><a href="#额外需求" class="headerlink" title="额外需求"></a>额外需求</h3><ol><li>用户具有默认分类：<strong>未分类</strong>。</li><li>每创建一篇文章，需要完成标签统计。</li></ol><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="创建-api"><a href="#创建-api" class="headerlink" title="创建 api"></a>创建 api</h3><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">sails <span class="keyword">generate</span> api article</span><br><span class="line">sails <span class="keyword">generate</span> api category</span><br></pre></td></tr></table></figure><h3 id="创建-“未分类”"><a href="#创建-“未分类”" class="headerlink" title="创建 “未分类”"></a>创建 “未分类”</h3><p>我们需要在 user 模型中的 <code>afterCreate</code> 这个生命期中存储一个默认分类：</p><p>api/models/Category.js：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Category.js</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @description :: 分类</span></span><br><span class="line"><span class="comment"> * @docs        :: http://sailsjs.org/#!documentation/models</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">DEFAULT_NAME = <span class="string">"未分类"</span>;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"></span><br><span class="line">    attributes: &#123;</span><br><span class="line">        name: &#123;</span><br><span class="line">            type: <span class="string">"string"</span>,</span><br><span class="line">            required: <span class="literal">true</span>,</span><br><span class="line">            unique:<span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得默认分类名</span></span><br><span class="line">    getDefault: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DEFAULT_NAME;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>api/models/User.js:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 创建（注册）用户前，对用户密码加密</span></span><br><span class="line">   beforeCreate: <span class="function"><span class="keyword">function</span> (<span class="params">values, cb</span>) </span>&#123;</span><br><span class="line">       bcrypt.genSalt(<span class="number">10</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, salt</span>) </span>&#123;</span><br><span class="line">           bcrypt.hash(values.password, salt, <span class="function"><span class="keyword">function</span> (<span class="params">err, hash</span>) </span>&#123;</span><br><span class="line">               <span class="keyword">if</span> (err) <span class="keyword">return</span> cb(err);</span><br><span class="line">               values.password = hash;</span><br><span class="line">               <span class="comment">// 执行用户定义回调</span></span><br><span class="line">               cb();</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;,</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 创建用户后，自动为之生成默认分类 -"未分类"，并更新站点信息</span></span><br><span class="line">   afterCreate: <span class="function"><span class="keyword">function</span> (<span class="params">createdUser, cb</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">var</span> thisModal = <span class="keyword">this</span>;</span><br><span class="line">       Category.create(&#123;<span class="attr">name</span>:Category.getDefault(),<span class="attr">creator</span>:createdUser&#125;)</span><br><span class="line">           .exec(<span class="function"><span class="keyword">function</span>(<span class="params">err,category</span>)</span>&#123;</span><br><span class="line">               <span class="keyword">if</span>(category)&#123;</span><br><span class="line">                   thisModal.updateSite(createdUser);</span><br><span class="line">                   cb();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">   &#125;,</span><br><span class="line"></span><br><span class="line">   <span class="comment">// ..</span></span><br></pre></td></tr></table></figure><h2 id="标签统计功能"><a href="#标签统计功能" class="headerlink" title="标签统计功能"></a>标签统计功能</h2><h3 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h3><p>如何统计所有文章中标签的出现频度，很容易想到的办法是遍历所有文章来统计各个标签的出现的次数，但这样做是十分低效的，为了完成这个需求，我们将利用 MongoDB 中的 <code>mapReduce()</code> 函数，相应知识可以参考官方文档：<a href="http://docs.mongodb.org/manual/core/map-reduce/" target="_blank" rel="noopener">Map Reduce</a></p><p>这里以一个例子简要的介绍一下 MongoDB 的 <code>mapReduce()</code>。考虑一个学生（Student）集合（collection），当中有如下三个学生文档（document）：张三，李四，王五</p><p>张三：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  name: "张三",</span><br><span class="line">  class: 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>李四：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  name: "李四",</span><br><span class="line">  class: 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>王五：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  name: "王五",</span><br><span class="line">  class: 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们利用 Map Reduce 来统计各个班级的学生人数，首先我们要进行一个 map 过程，该过程就是__根据一定条件将划分数据。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  emit(<span class="keyword">this</span>.class,&#123;<span class="attr">count</span>:<span class="number">1</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>emit(参数 1, 参数 2)</code> 方法，我们就能获得输出键值对（key-value）。其中，<code>参数 1</code> 可以看做我们数据的划分依据，例如，本例中我们是根据班级进行划分，而 <code>参数 2</code> 则是要传入这个划分的值，本例中，每个班级下，我们需要学生人数统计 <code>count:1</code>。</p><p>本例中，map 过程将会为我们产生两个文档，分别是：</p><p><strong>班级 1</strong>:</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;1,[&#123;count:1&#125;,&#123;count:1&#125;]&#125;</span><br></pre></td></tr></table></figure><p><strong>班级 2</strong>:</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;2,&#123;count:1&#125;&#125;</span><br></pre></td></tr></table></figure><p>下面再通过 reduce 过程对 map 产生的键值对进行处理，输出每个班的人数：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reduce = <span class="function"><span class="keyword">function</span>(<span class="params">key,values</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> res = &#123;<span class="attr">count</span>:<span class="number">0</span>&#125;</span><br><span class="line">  values.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    res.count += value.count;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>! 重要：reduce 函数中接收的 <code>values</code> 参数的形式，必须和 reduce 函数返回的结果 <code>res</code> 的形式一致。</p></blockquote><p>本例中，reduce 过程将产生两个文档：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  _id: 1</span><br><span class="line">  value: &#123;count:2&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="code"><pre><span class="line">_id: 2</span><br><span class="line">value: &#123;count:1&#125;</span><br></pre></td></tr></table></figure><p>最后，通过 MongoDb 的 <code>mapReduce()</code> 函数将统计信息输出到 <code>statistics</code> 集合中：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">db.student.mapReduce(map,reduce,&#123;<span class="attr">out</span>:<span class="string">"statistics"</span>&#125;);</span><br></pre></td></tr></table></figure><p>现在我们执行</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.statistics</span><span class="selector-class">.find</span>();</span><br></pre></td></tr></table></figure><p>将能看到如下结果：</p><div style="text-align:center"><br><img src="http://7pulhb.com1.z0.glb.clouddn.com/sails-mapreduce_result.png" width="300"><br></div><h3 id="标签统计实现"><a href="#标签统计实现" class="headerlink" title="标签统计实现"></a>标签统计实现</h3><p>借助 sails 中 <a href="http://sailsjs.org/documentation/reference/waterline-orm/models/native" target="_blank" rel="noopener"> <code>native()</code> </a> 方法，我们可以封装 <code>mapreduce()</code> 函数到我们的业务逻辑中：</p><p>api/models/Article.js：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Article.js</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @description :: 文章模型</span></span><br><span class="line"><span class="comment"> * @docs        :: http://sailsjs.org/#!documentation/models</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义 Article 集合的 map，reduce 函数, 统计标签</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> map = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 分类依据组成为："用户 ID: 标签"</span></span><br><span class="line">    <span class="keyword">this</span>.tags.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">tag</span>) </span>&#123;</span><br><span class="line">        emit(tag, <span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> reduce = <span class="function"><span class="keyword">function</span> (<span class="params">k, values</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">        total += values[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"></span><br><span class="line">    attributes: &#123;</span><br><span class="line">        title: &#123;</span><br><span class="line">            type: <span class="string">'string'</span>,</span><br><span class="line">            required: <span class="literal">true</span>,</span><br><span class="line">            minLength: <span class="number">1</span>,</span><br><span class="line">            maxLength: <span class="number">40</span></span><br><span class="line">        &#125;,</span><br><span class="line">        content: &#123;</span><br><span class="line">            type: <span class="string">'string'</span>,</span><br><span class="line">            required: <span class="literal">true</span>,</span><br><span class="line">            minLength: <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        tags: &#123;</span><br><span class="line">            type: <span class="string">'array'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        category: &#123;</span><br><span class="line">            model: <span class="string">'category'</span>,</span><br><span class="line">            required: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次文章创建完成，更新标签统计</span></span><br><span class="line">    afterCreate: <span class="function"><span class="keyword">function</span> (<span class="params">article, cb</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.updateTags();</span><br><span class="line">        cb();</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//custom</span></span><br><span class="line">    updateTags: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        Article.native(<span class="function"><span class="keyword">function</span> (<span class="params">err, collection</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (err) <span class="keyword">return</span> res.serverError(err);</span><br><span class="line">            collection.mapReduce(map, reduce, &#123;<span class="attr">out</span>: <span class="string">"tags"</span>&#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="创建-tags-api"><a href="#创建-tags-api" class="headerlink" title="创建 tags api"></a>创建 tags api</h3><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">sails <span class="keyword">generate</span> api tags</span><br></pre></td></tr></table></figure><h2 id="添加路由及访问控制"><a href="#添加路由及访问控制" class="headerlink" title="添加路由及访问控制"></a>添加路由及访问控制</h2><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p><strong>_config/routes.js</strong>:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//----------------Aticles</span></span><br><span class="line">   <span class="comment">// 默认显示全部文章</span></span><br><span class="line">   <span class="string">'/'</span>: <span class="string">'ArticleController.index'</span>,</span><br><span class="line">   <span class="comment">// 显示某篇文章</span></span><br><span class="line">   <span class="string">'get /article/show/:id'</span> : <span class="string">'ArticleController.show'</span>,</span><br><span class="line">   <span class="comment">// 跳转到创建文章页</span></span><br><span class="line">   <span class="string">'get /article/new'</span>: <span class="string">'ArticleController.new'</span>,</span><br><span class="line">   <span class="comment">// 跳转到编辑文章页</span></span><br><span class="line">   <span class="string">'get /article/edit/:id'</span>: <span class="string">'ArticleController.edit'</span>,</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 显示分类下的全部文章</span></span><br><span class="line">   <span class="string">'/category/:id/articles/:page'</span>: <span class="string">'CategoryController.getArticles'</span>,</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 显示标签下的全部文章</span></span><br><span class="line">   <span class="string">'/tag/:name/articles/:page'</span>: <span class="string">'TagsController.getArticles'</span>,</span><br></pre></td></tr></table></figure><h3 id="Policies"><a href="#Policies" class="headerlink" title="Policies"></a>Policies</h3><p>config/polies.js:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文章显示逻辑不需要登录</span></span><br><span class="line">    ArticleController: &#123;</span><br><span class="line">        index: <span class="string">'userCreated'</span>,</span><br><span class="line">        show: <span class="string">'userCreated'</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    CategoryController: &#123;</span><br><span class="line">        getArticles: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    TagsController: &#123;</span><br><span class="line">        getArticles: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="页面组织"><a href="#页面组织" class="headerlink" title="页面组织"></a>页面组织</h2><p>我是采用如下的页面组织方式:</p><div style="text-align:center"><br><img src="http://7pulhb.com1.z0.glb.clouddn.com/sails-article_views.png" width="300"><br></div><p>其中编辑页面和创建页面因为逻辑相似，二者共用 save.swig，其中含有一个编辑器 _editor.swig 的子页面，建议所有内嵌的子页面都以下划线开头，以示区分。</p><h2 id="业务逻辑撰写"><a href="#业务逻辑撰写" class="headerlink" title="业务逻辑撰写"></a>业务逻辑撰写</h2><p>api/controllers/ArticleController.js：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跳至创建文章</span></span><br><span class="line">    <span class="keyword">new</span>: <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 获取分类</span></span><br><span class="line">        Category.find()</span><br><span class="line">            .exec(<span class="function"><span class="keyword">function</span> (<span class="params">err, categories</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (!err) &#123;</span><br><span class="line">                    <span class="keyword">return</span> res.view(</span><br><span class="line">                        <span class="string">'article/save'</span>,</span><br><span class="line">                        &#123;</span><br><span class="line">                            categories: categories,</span><br><span class="line">                            form: &#123;<span class="attr">action</span>: <span class="string">'/article'</span>, <span class="attr">method</span>: <span class="string">'POST'</span>&#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    )</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跳至修改文章:</span></span><br><span class="line">    edit: <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 获取文章</span></span><br><span class="line">        <span class="keyword">var</span> id = req.param(<span class="string">'id'</span>);</span><br><span class="line">        Article.findOne(id).exec(<span class="function"><span class="keyword">function</span> (<span class="params">err, article</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 如果不存在，404</span></span><br><span class="line">            <span class="keyword">if</span> (article) &#123;</span><br><span class="line">                <span class="comment">// 获取分类</span></span><br><span class="line">                Category.find()</span><br><span class="line">                    .exec(<span class="function"><span class="keyword">function</span> (<span class="params">err, categories</span>) </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (!err) &#123;</span><br><span class="line">                            <span class="keyword">return</span> res.view(</span><br><span class="line">                                <span class="string">'article/save'</span>,</span><br><span class="line">                                &#123;</span><br><span class="line">                                    article: article,</span><br><span class="line">                                    categories: categories,</span><br><span class="line">                                    form: &#123;<span class="attr">action</span>: <span class="string">'/article/'</span> + id, <span class="attr">method</span>: <span class="string">'PUT'</span>&#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            )</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> res.notFound();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Promise-解决难看的嵌套回调"><a href="#Promise-解决难看的嵌套回调" class="headerlink" title="Promise 解决难看的嵌套回调"></a>Promise 解决难看的嵌套回调</h3><p>OK，可以看到，我们已经遇到了 Node 常见的多层嵌套回调了，不断横向延伸的代码感觉就像闷了口大翔在嘴里，非常不舒服，在 ES6 中，可以通过 <a href="https://promisesaplus.com/" target="_blank" rel="noopener"> Promise </a> 来解决嵌套的回调，下面简要介绍一下 Promise。</p><p>顾名思义，Promise 代表一种“许诺”，也就是未来才会发生的东西，如同现实生活中的许诺一样，它会被“履行（fulfiled）” 或者 “拒绝履行（rejected）”，Promise 的核心方法为 <code>then(onFulfiled,onRejected)</code>，通过 <code>then</code>，我们就能构造一个不断向下的过程，而不是横向延伸。</p><p>看个栗子：</p><p>一个 Ajax 请求的嵌套回调:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先我要得到一篇文章</span></span><br><span class="line">$.get(<span class="string">'/article'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,article</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(err)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  <span class="comment">// 在回调中得到该文章所有的评论</span></span><br><span class="line">    $.get(article.commentsURL,<span class="function"><span class="keyword">function</span>(<span class="params">err,comments</span>)</span>&#123;</span><br><span class="line">      <span class="comment">//doSomething</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>经 Promise 处理后的代码:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.get(<span class="string">'/article'</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">article</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $.get(article.commentsURL);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">comments</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// doSomething</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// error handler</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>显然，这种向下的逐级传递使得回调逻辑更加易读以及易维护。想更深入了解 Promise，可以参看<a href="http://spion.github.io/posts/why-i-am-switching-to-promises.html" target="_blank" rel="noopener">这篇文章</a>.</p><p>Sails 所采用的 Waterline 也提倡我们进行 Promise 式的书写，其所采用的 Promise 实现库是<a href="https://github.com/petkaantonov/bluebird" target="_blank" rel="noopener"> blue bird </a>。现在我们通过 blue bird 对编辑文章的业务逻辑进行重构：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 跳至修改文章:</span></span><br><span class="line">edit: <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获取文章</span></span><br><span class="line">    <span class="keyword">var</span> id = req.param(<span class="string">'id'</span>);</span><br><span class="line">    Article.findOne(id).populate(<span class="string">'category'</span>)</span><br><span class="line">        .then(<span class="function"><span class="keyword">function</span> (<span class="params">article</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> [article,Category.find()];</span><br><span class="line">        &#125;)</span><br><span class="line">        .spread(<span class="function"><span class="keyword">function</span> (<span class="params">article, categories</span>) </span>&#123;</span><br><span class="line">            res.view(</span><br><span class="line">                <span class="string">'article/save'</span>,</span><br><span class="line">                &#123;</span><br><span class="line">                    article: article,</span><br><span class="line">                    categories: categories,</span><br><span class="line">                    form: &#123;<span class="attr">action</span>: <span class="string">'/article/'</span> + id, <span class="attr">method</span>: <span class="string">'PUT'</span>&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            );</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">            res.notFound();</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们访问<a href="http://localhost:1337/article/new" target="_blank" rel="noopener"> localhost:1337/article/new </a>，进入如下页面:</p><div style="text-align:center"><br><img src="http://7pulhb.com1.z0.glb.clouddn.com/sails-%E5%88%9B%E5%BB%BA%E6%96%87%E7%AB%A0.png" width="800"><br></div><h2 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h2><h3 id="markdown-支持"><a href="#markdown-支持" class="headerlink" title="markdown 支持"></a>markdown 支持</h3><p>个人不喜欢用富文本编辑器，技术博客最好的写作工具还是 markdown，下面我们通过 bower 来为前端添加 markdown 解析，这里我用的<a href="https://github.com/chjj/marked" target="_blank" rel="noopener"> marked </a>。</p><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bower </span>install <span class="keyword">marked </span>--save</span><br></pre></td></tr></table></figure><h3 id="代码高亮支持"><a href="#代码高亮支持" class="headerlink" title="代码高亮支持"></a>代码高亮支持</h3><p>对于代码高亮，选择老牌的<a href="https://highlightjs.org/" target="_blank" rel="noopener"> highlight.js </a>，它提供了不少很骚的主题。</p><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bower </span><span class="keyword">install </span>highlightjs --save</span><br></pre></td></tr></table></figure><p>记得将喜欢的高亮主题 css 添加到页面，否则看不到加亮效果</p><p>views/article/layout.swig:</p><figure class="highlight twig"><table><tr><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="keyword">extends</span></span> '../partial/layout.swig' %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="keyword">block</span></span> stylesheets -%&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;&#123; path.style &#125;&#125;</span><span class="xml"><span class="tag"><span class="string">/article.css"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;&#123; path.bower &#125;&#125;</span><span class="xml"><span class="tag"><span class="string">/highlightjs/styles/solarized_dark.css"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>/&gt;</span></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;%- <span class="name"><span class="keyword">endblock</span></span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure><h3 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h3><p>现在，我们可以试试效果了，在表单创建相应内容，然后单击预览看看效果：</p><div style="text-align:center"><br><img src="http://7pulhb.com1.z0.glb.clouddn.com/sails-4_article_edit.png" width="800"><br></div><div style="text-align:center"><br><img src="http://7pulhb.com1.z0.glb.clouddn.com/sails-4_article_preview.png" width="800"><br></div><blockquote><p>在创建 / 编辑文章前端逻辑中，新用到的 semantic-ui 的组件有<a href="http://www.semantic-ui.cn/modules/modal.html" target="_blank" rel="noopener"> modal </a></p></blockquote><h3 id="重构标签"><a href="#重构标签" class="headerlink" title="重构标签"></a>重构标签</h3><p>因为表单发送的标签（tags）是字符串，而实际上我们的标签在数据库中的组织形式是数组，所以我们需要在 <strong> 每次后端验证 article 的表单前 </strong> 对发送过来的标签进行处理，将其转换为字符串形式，并保证每个标签的有效性和唯一性：</p><p>api/models/Article.js 中为 <code>beforeValidate</code> 生命期添加逻辑:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文章验证前，重构标签</span></span><br><span class="line">    beforeValidate: <span class="function"><span class="keyword">function</span>(<span class="params">article,cb</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(article.tags.length) &#123;</span><br><span class="line">            <span class="keyword">var</span> rowTags = article.tags[<span class="number">0</span>].split(<span class="string">""</span>);</span><br><span class="line">            article.tags = [];</span><br><span class="line">            <span class="comment">// 去除空标签及重复标签</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;rowTags.length;i++)&#123;</span><br><span class="line">                <span class="keyword">var</span> tag = rowTags[i].replace(<span class="string">" "</span>,<span class="string">""</span>);</span><br><span class="line">                <span class="keyword">if</span>(tag.length&gt;<span class="number">0</span> &amp;&amp; (article.tags.indexOf(tag)&lt;<span class="number">0</span>))&#123;</span><br><span class="line">                    article.tags.push(tag);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cb();</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><h2 id="显示文章"><a href="#显示文章" class="headerlink" title="显示文章"></a>显示文章</h2><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>考虑到访问性能，我们要进行分页，分页采用 “下一页” 方式，操作方式为 “点击加载”。</p><p>Waterline 通过 <code>paginate()</code> 函数实现分页：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Model.find().paginate(&#123;<span class="attr">page</span>: <span class="number">2</span>, <span class="attr">limit</span>: <span class="number">10</span>&#125;);</span><br></pre></td></tr></table></figure><h3 id="业务逻辑"><a href="#业务逻辑" class="headerlink" title="业务逻辑"></a>业务逻辑</h3><p>在 api/controllers/ArticleController.js 添加文章显示的业务逻辑:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文章查询顺序：以更新时间逆序</span></span><br><span class="line">FIND_ORDER = <span class="string">'updatedAt desc'</span>;</span><br><span class="line"><span class="comment">// 文章每页条目数</span></span><br><span class="line">FIND_PER_PAGE = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文章查询顺序：以更新时间逆序</span></span><br><span class="line">FIND_ORDER = <span class="string">'updatedAt desc'</span>;</span><br><span class="line"><span class="comment">// 文章每页条目数</span></span><br><span class="line">FIND_PER_PAGE = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 首页显示文章</span></span><br><span class="line"><span class="comment">     * @param req</span></span><br><span class="line"><span class="comment">     * @param res</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    index:<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 获得当前需要加载第几页</span></span><br><span class="line">        <span class="keyword">var</span> page = req.param(<span class="string">'page'</span>) ? req.param(<span class="string">'page'</span>) : <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 如果是第 1 页，则需要加载分类以及标签</span></span><br><span class="line">        <span class="keyword">if</span>( page==<span class="number">1</span> ) &#123;</span><br><span class="line">            Article.find(&#123;</span><br><span class="line">                sort: FIND_ORDER,</span><br><span class="line">            &#125;).paginate(&#123;<span class="attr">page</span>: page, <span class="attr">limit</span>: FIND_PER_PAGE&#125;)</span><br><span class="line">                .populate(<span class="string">'category'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">articles</span>) </span>&#123;</span><br><span class="line">                    <span class="comment">// 每篇文章转换</span></span><br><span class="line">                    <span class="comment">// 查找分类, 及标签</span></span><br><span class="line">                    <span class="keyword">return</span> [</span><br><span class="line">                        articles,</span><br><span class="line">                        Category.find(),</span><br><span class="line">                        Tags.find()</span><br><span class="line">                    ];</span><br><span class="line">                &#125;)</span><br><span class="line">                .spread(<span class="function"><span class="keyword">function</span> (<span class="params">articles, categories, tags</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> res.view(</span><br><span class="line">                        <span class="string">'article/index'</span>,</span><br><span class="line">                        &#123;</span><br><span class="line">                            articles: articles,</span><br><span class="line">                            categories: categories,</span><br><span class="line">                            tags: tags,</span><br><span class="line">                            page: page</span><br><span class="line">                        &#125;);</span><br><span class="line">                &#125;);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Article.find(&#123;</span><br><span class="line">                    sort: FIND_ORDER,</span><br><span class="line">                &#125;).paginate(&#123;<span class="attr">page</span>: page, <span class="attr">limit</span>: FIND_PER_PAGE&#125;)</span><br><span class="line">                .populate(<span class="string">'category'</span>).exec(<span class="function"><span class="keyword">function</span> (<span class="params">err, articles</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (!err) &#123;</span><br><span class="line">                        <span class="comment">// 刷新下一页</span></span><br><span class="line">                        <span class="keyword">return</span> res.view(</span><br><span class="line">                            <span class="string">'article/_article'</span>,</span><br><span class="line">                            &#123;</span><br><span class="line">                                articles: articles,</span><br><span class="line">                                page: page</span><br><span class="line">                            &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">console</span>.log(err);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示某篇文章</span></span><br><span class="line">    show:<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> id = req.param(<span class="string">'id'</span>);</span><br><span class="line">        Article.findOne(id).populate(<span class="string">'category'</span>).</span><br><span class="line">            exec(<span class="function"><span class="keyword">function</span> (<span class="params">err, article</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(err)&#123;</span><br><span class="line">                res.notFound();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.view(<span class="string">'article/show'</span>,&#123;</span><br><span class="line">                    articles: [article]</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//..............</span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><h3 id="markdown-显示优化"><a href="#markdown-显示优化" class="headerlink" title="markdown 显示优化"></a>markdown 显示优化</h3><p>我自己小改了一下 git 的 markdown theme，主要是去掉了自带的代码高亮，来使得 markdown 解析出的内容效果更加舒适，相应文件在<a href="https://github.com/yoyoyohamapi/blog/blob/master/assets/sass/default/markdown.scss" target="_blank" rel="noopener">这儿</a>。</p><p>在 views/article/layout.swig 引入 css：</p><figure class="highlight twig"><table><tr><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="keyword">extends</span></span> '../partial/layout.swig' %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="keyword">block</span></span> stylesheets -%&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;&#123; path.style &#125;&#125;</span><span class="xml"><span class="tag"><span class="string">/article.css"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;&#123; path.bower &#125;&#125;</span><span class="xml"><span class="tag"><span class="string">/highlightjs/styles/solarized_dark.css"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;&#123; path.style &#125;&#125;</span><span class="xml"><span class="tag"><span class="string">/markdown.css"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>/&gt;</span></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;%- <span class="name"><span class="keyword">endblock</span></span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure><p>OK，访问 <a href="http://localhost:1337" target="_blank" rel="noopener"> localhost:1337 </a> 看一下效果：</p><div style="text-align:center"><br><img src="http://7pulhb.com1.z0.glb.clouddn.com/sails-4_article_index.png" width="800"><br></div><h2 id="章节预告"><a href="#章节预告" class="headerlink" title="章节预告"></a>章节预告</h2><p>下一章节中，我们将实现个人信息维护功能。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;章节概述&quot;&gt;&lt;a href=&quot;#章节概述&quot; class=&quot;headerlink&quot; title=&quot;章节概述&quot;&gt;&lt;/a&gt;章节概述&lt;/h2&gt;&lt;p&gt;在本章中，你将能学习到如下知识：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;认识 MongoDB 的 &lt;code&gt;mapReduce&lt;/code&gt; 函数，并利用其实现标签统计功能。&lt;/li&gt;
&lt;li&gt;认识 ES6 中的 Promise，了解其实现库 blue bird，为我们解决 Node 中难看的嵌套回调。&lt;/li&gt;
&lt;li&gt;如何利用 markdown 来创建文章并完成代码高亮显示。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="利用 Sails.js + MongoDB 开发博客系统" scheme="http://yoyoyohamapi.me/categories/%E5%88%A9%E7%94%A8-Sails-js-MongoDB-%E5%BC%80%E5%8F%91%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Sails" scheme="http://yoyoyohamapi.me/tags/Sails/"/>
    
      <category term="Node" scheme="http://yoyoyohamapi.me/tags/Node/"/>
    
      <category term="MongoDB" scheme="http://yoyoyohamapi.me/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>利用 Sails.js + MongoDB 开发博客系统（3）-- 账户模块</title>
    <link href="http://yoyoyohamapi.me/2015/05/03/%E5%88%A9%E7%94%A8-Sails-js-MongoDB-%E5%BC%80%E5%8F%91%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F%EF%BC%883%EF%BC%89-%E8%B4%A6%E6%88%B7%E6%A8%A1%E5%9D%97/"/>
    <id>http://yoyoyohamapi.me/2015/05/03/利用-Sails-js-MongoDB-开发博客系统（3）-账户模块/</id>
    <published>2015-05-03T02:37:57.000Z</published>
    <updated>2018-02-14T17:00:53.506Z</updated>
    
    <content type="html"><![CDATA[<h2 id="章节概述"><a href="#章节概述" class="headerlink" title="章节概述"></a>章节概述</h2><p>在本章中，你讲学习到如下知识：</p><ul><li>Sails 中如何配置 MongoDB。</li><li>Sails 中的模型层（Models）知识，如模型属性（attributes），模型生命期回调（lifecycle callbacks）等。</li><li>利用 Passport.js 来管理我们的账户认证。</li><li>认识密码加密策略 bcrypt。</li><li>认识 Sails 的核心模块 policies。</li><li>如何在 Sails 中撰写自定义配置。</li><li>如何扩展 swig 模板引擎。</li><li>semantic-ui 中表单验证模块的应用。</li></ul><a id="more"></a><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><h3 id="user-document-设计"><a href="#user-document-设计" class="headerlink" title="user document 设计"></a>user document 设计</h3><table><thead><tr><th>名称</th><th>说明</th><th>类型</th><th>限制</th></tr></thead><tbody><tr><td>siteName</td><td>站点名称</td><td>string</td><td>必选，1~10 个字符</td></tr><tr><td>siteDesc</td><td>站点简介</td><td>string</td><td>可选，不超过 20 字符</td></tr><tr><td>email</td><td>用户邮箱</td><td>string(email)</td><td>必选，唯一</td></tr><tr><td>password</td><td>密码</td><td>string</td><td>必选，原始长度不少于 6 个字符</td></tr></tbody></table><h3 id="生成-user-api"><a href="#生成-user-api" class="headerlink" title="生成 user api"></a>生成 user api</h3><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">sails <span class="keyword">generate</span> api user</span><br></pre></td></tr></table></figure><p>可以看到，Sails 为我们生成了 user 相应地模型及控制器</p><div style="text-align:center"><br><img src="http://7pulhb.com1.z0.glb.clouddn.com/sails-generate_api.png" width="300"><br></div><h2 id="配置-MongoDB-数据库连接"><a href="#配置-MongoDB-数据库连接" class="headerlink" title="配置 MongoDB 数据库连接"></a>配置 MongoDB 数据库连接</h2><h3 id="安装-Sails-对-MongoDB-的依赖"><a href="#安装-Sails-对-MongoDB-的依赖" class="headerlink" title="安装 Sails 对 MongoDB 的依赖"></a>安装 Sails 对 MongoDB 的依赖</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span> sails-mongo <span class="comment">--save</span></span><br></pre></td></tr></table></figure><h3 id="配置-MongoDB-连接"><a href="#配置-MongoDB-连接" class="headerlink" title="配置 MongoDB 连接"></a>配置 MongoDB 连接</h3><p>修改 config/connections.js:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports.connections = &#123;</span><br><span class="line">  mongo: &#123;</span><br><span class="line">    adapter: <span class="string">'sails-mongo'</span>,</span><br><span class="line">    host: <span class="string">'localhost'</span>, <span class="comment">// defaults to `localhost` if omitted</span></span><br><span class="line">    port: <span class="number">27017</span>, <span class="comment">// defaults to 27017 if omitted</span></span><br><span class="line">    database: <span class="string">'blog'</span> <span class="comment">// or omit if not relevant</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="模型层的基本配置"><a href="#模型层的基本配置" class="headerlink" title="模型层的基本配置"></a>模型层的基本配置</h3><p>修改 config/models.js，配置模型的连接数据库位 MongoDB，并为每个模型添加 updatedAt 以及 createdAt 属性:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports.models = &#123;</span><br><span class="line"></span><br><span class="line">  <span class="string">'connection'</span> : <span class="string">'mongo'</span>,</span><br><span class="line">  autoCreatedAt: <span class="literal">true</span>,</span><br><span class="line">  autoUpdatedAt: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="利用-Passport-js-来管理我们的账户认证"><a href="#利用-Passport-js-来管理我们的账户认证" class="headerlink" title="利用 Passport.js 来管理我们的账户认证"></a>利用 Passport.js 来管理我们的账户认证</h2><p><a href="http://passportjs.org/" target="_blank" rel="noopener"><strong>Passport.js</strong> </a>是 Node.js 中一个专注于登录验证的中间件，配置灵活，支持很多第三方登录验证。十分感谢 <a href="http://iliketomatoes.com/implement-passport-js-authentication-with-sails-js-0-10-2/" target="_blank" rel="noopener">这篇教程</a> 帮助我将 Passport.js 集成到 Sails 中。</p><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><p>安装<a href="https://www.npmjs.com/package/bcrypt" target="_blank" rel="noopener"> bcrypt </a>，bcrypt 被认为是比一般加盐加密更好的密码加密手段，一般的加盐加密在密码较简单是仍可能被暴力破解，bcrypt 牺牲了部分性能，来换取更高的密码存储安全，参看如下两篇文章：</p><ul><li><p><a href="http://codahale.com/how-to-safely-store-a-password/" target="_blank" rel="noopener">How To Safely Store A Password</a></p></li><li><p><a href="http://www.cnblogs.com/lixiong/archive/2011/12/24/2300098.html" target="_blank" rel="noopener">md5/sha1+salt 和 Bcrypt</a></p></li></ul><p>安装 bcrypt:</p><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install </span><span class="keyword">bcrpyt </span>--save</span><br></pre></td></tr></table></figure><p>安装 Passport.js:</p><figure class="highlight elm"><table><tr><td class="code"><pre><span class="line"><span class="title">npm</span> install pass<span class="keyword">port</span> <span class="comment">--save</span></span><br></pre></td></tr></table></figure><p>因为我们是本地验证，所以只需要 Passport 的本地验证支持</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span> passport-<span class="keyword">local</span> <span class="comment">--save</span></span><br></pre></td></tr></table></figure><h3 id="配置-user-实体"><a href="#配置-user-实体" class="headerlink" title="配置 user 实体"></a>配置 user 实体</h3><p>在此博客系统中，用户注册前需要对用户密码进行 bcrypt 加密，这将会利用到 Sails 中模型层的生命期回调<a href="http://www.sailsjs.org/documentation/concepts/models-and-orm/lifecycle-callbacks" target="_blank" rel="noopener"> Lifecycle callbacks </a>, 在此，我们用到的生命期为 <code>beforeCreate</code>，亦即模型创建前执行的回调：</p><p><strong>api/models/User.js</strong>:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bcrypt = <span class="built_in">require</span>(<span class="string">'bcrypt'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  attributes: &#123;</span><br><span class="line">    <span class="comment">// 站点名称</span></span><br><span class="line">    siteName: &#123;</span><br><span class="line">      type: <span class="string">'string'</span>,</span><br><span class="line">      required: <span class="literal">true</span>,</span><br><span class="line">      minLength:<span class="number">1</span>,</span><br><span class="line">      maxLength:<span class="number">10</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 邮箱</span></span><br><span class="line">    email: &#123;</span><br><span class="line">      type: <span class="string">'email'</span>,</span><br><span class="line">      unique: <span class="literal">true</span>,</span><br><span class="line">      required: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 密码</span></span><br><span class="line">    password: &#123;</span><br><span class="line">      type: <span class="string">'string'</span>,</span><br><span class="line">      required: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 站点简介</span></span><br><span class="line">    siteDesc: &#123;</span><br><span class="line">      type: <span class="string">'string'</span>,</span><br><span class="line">      defaultsTo: <span class="string">'暂无简介'</span>,</span><br><span class="line">      maxLength:<span class="number">40</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 是否管理员（默认为非管理员）</span></span><br><span class="line">    isAdmin: &#123;</span><br><span class="line">      type: <span class="string">'boolean'</span>,</span><br><span class="line">      defaultsTo: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建（注册）用户前，对用户密码加密</span></span><br><span class="line">  beforeCreate: <span class="function"><span class="keyword">function</span> (<span class="params">values, cb</span>) </span>&#123;</span><br><span class="line">    bcrypt.genSalt(<span class="number">10</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, salt</span>) </span>&#123;</span><br><span class="line">      bcrypt.hash(values.password, salt, <span class="function"><span class="keyword">function</span>(<span class="params">err, hash</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err) <span class="keyword">return</span> cb(err);</span><br><span class="line">        values.password = hash;</span><br><span class="line">        <span class="comment">// 执行用户定义回调</span></span><br><span class="line">        cb();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="创建路由及视图"><a href="#创建路由及视图" class="headerlink" title="创建路由及视图"></a>创建路由及视图</h3><p>先创建一个封装了登录注册逻辑的控制器 AuthController.js：</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">sails <span class="keyword">generate</span> controller auth</span><br></pre></td></tr></table></figure><p>接下来在 config/routes.js 中为我们的登录注册创建相应路由：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//config/routes.js</span></span><br><span class="line"><span class="built_in">module</span>.exports.routes = &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/***************************************************************************</span></span><br><span class="line"><span class="comment">  *                                                                          *</span></span><br><span class="line"><span class="comment">  * Make the view located at `views/homepage.ejs` (or `views/homepage.jade`, *</span></span><br><span class="line"><span class="comment">  * etc. depending on your default view engine) your home page.              *</span></span><br><span class="line"><span class="comment">  *                                                                          *</span></span><br><span class="line"><span class="comment">  * (Alternatively, remove this and add an `index.html` file in your         *</span></span><br><span class="line"><span class="comment">  * `assets` directory)                                                      *</span></span><br><span class="line"><span class="comment">  *                                                                          *</span></span><br><span class="line"><span class="comment">  ***************************************************************************/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//'/': &#123;</span></span><br><span class="line">  <span class="comment">//  view: 'homepage'</span></span><br><span class="line">  <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">'/'</span> : &#123;</span><br><span class="line">    view :<span class="string">'index'</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">//---------------Login &amp; Register</span></span><br><span class="line">    <span class="comment">// 跳转到注册页面</span></span><br><span class="line">    <span class="string">'get /register'</span>: <span class="string">'AuthController.toRegister'</span>,</span><br><span class="line">    <span class="comment">// 处理注册逻辑</span></span><br><span class="line">    <span class="string">'post /register'</span>: <span class="string">'AuthController.processRegister'</span>,</span><br><span class="line">    <span class="comment">// 跳转到登陆页</span></span><br><span class="line">    <span class="string">'get /login'</span>: &#123;</span><br><span class="line">        view: <span class="string">'passport/login'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 处理登陆逻辑</span></span><br><span class="line">    <span class="string">'post /login'</span>: <span class="string">'AuthController.processLogin'</span>,</span><br><span class="line">    <span class="comment">// 登出逻辑</span></span><br><span class="line">    <span class="string">'/logout'</span>: <span class="string">'AuthController.logout'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="创建对应的视图"><a href="#创建对应的视图" class="headerlink" title="创建对应的视图"></a>创建对应的视图</h3><blockquote><p>相应地 css 文件内容不给出，UI 设计见仁见智。</p></blockquote><p>views/passport/layout.swig：</p><figure class="highlight twig"><table><tr><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="keyword">extends</span></span> '../partial/layout.swig' %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="keyword">block</span></span> stylesheets -%&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;&#123; path.style &#125;&#125;</span><span class="xml"><span class="tag"><span class="string">/passport.css"</span>/&gt;</span></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;%- <span class="name"><span class="keyword">endblock</span></span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure><p>注意，给登录及注册页面声明待调用模块：</p><p>passport/login 及 passport/register</p><p>views/passport/login.swig:</p><figure class="highlight twig"><table><tr><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="keyword">extends</span></span> 'layout.swig' %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="keyword">set</span></span> module = 'passport/login' %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="keyword">block</span></span> title -%&#125;</span><span class="xml">欢迎登录</span><span class="template-tag">&#123;%- <span class="name"><span class="keyword">endblock</span></span> %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="keyword">block</span></span> form_content -%&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">"ui form"</span> <span class="attr">action</span>=<span class="string">"/login"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"ui dividing header"</span>&gt;</span> 欢迎登录 < span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="xml">        </span><span class="template-tag">&#123;% <span class="name"><span class="keyword">if</span></span> err -%&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"ui error message"</span> <span class="attr">style</span>=<span class="string">"display: block"</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header"</span>&gt;</span> 登录失败 < span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">p</span>&gt;</span> 账号或密码错误 < span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        </span><span class="template-tag">&#123;%- <span class="name"><span class="keyword">endif</span></span> %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"field"</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"email"</span> <span class="attr">name</span>=<span class="string">"email"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"您的邮箱"</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"field"</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">placeholder</span>=<span class="string">"您的密码"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"field"</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"ui buttons"</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"ui positive button"</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span> 登录 < span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"or"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"ui negative button"</span> <span class="attr">href</span>=<span class="string">"/register"</span>&gt;</span> 注册 < span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;%- <span class="name"><span class="keyword">endblock</span></span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure><p>views/passport/register.swig：</p><figure class="highlight twig"><table><tr><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="keyword">extends</span></span> 'layout.swig' -%&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="keyword">set</span></span> module='passport/register' %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="keyword">block</span></span> title -%&#125;</span><span class="xml">注册</span><span class="template-tag">&#123;%- <span class="name"><span class="keyword">endblock</span></span> %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="keyword">block</span></span> form_content -%&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">"ui form"</span> <span class="attr">action</span>=<span class="string">"/register"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"ui dividing header"</span>&gt;</span> 欢迎注册 < span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="xml">        </span><span class="template-tag">&#123;% <span class="name"><span class="keyword">if</span></span> err -%&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"ui error message"</span> <span class="attr">style</span>=<span class="string">"display: block"</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header"</span>&gt;</span> 注册失败 < span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">p</span>&gt;</span> 邮箱已被注册 < span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        </span><span class="template-tag">&#123;%- <span class="name"><span class="keyword">endif</span></span> %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span> = <span class="string">"field"</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"siteName"</span> <span class="attr">name</span>=<span class="string">"siteName"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"填写站点名称"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"field"</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"email"</span> <span class="attr">name</span>=<span class="string">"email"</span> <span class="attr">type</span>=<span class="string">"email"</span> <span class="attr">placeholder</span>=<span class="string">"填写邮箱"</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"field"</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">placeholder</span>=<span class="string">"填写密码（不少于 6 个字符）"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"field"</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">id</span>=<span class="string">"siteDesc"</span> <span class="attr">name</span>=<span class="string">"siteDesc"</span> <span class="attr">placeholder</span>=<span class="string">"填写站点简介"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"field"</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"ui buttons"</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"ui positive button"</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span> 注册 < span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"or"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"ui negative button"</span> <span class="attr">href</span>=<span class="string">"/login"</span>&gt;</span> 登录 < span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;%-<span class="name"><span class="keyword">endblock</span></span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure><h3 id="撰写登录验证逻辑，感谢-Giancarlo-Soverini-提供教程"><a href="#撰写登录验证逻辑，感谢-Giancarlo-Soverini-提供教程" class="headerlink" title="撰写登录验证逻辑，感谢 Giancarlo Soverini 提供教程"></a>撰写登录验证逻辑，<a href="http://iliketomatoes.com/implement-passport-js-authentication-with-sails-js-0-10-2/" target="_blank" rel="noopener">感谢 Giancarlo Soverini 提供教程</a></h3><p>在 api/controllers/AuthController.js 添加如下内容：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 验证逻辑控制器</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">var</span> passport = <span class="built_in">require</span>(<span class="string">'passport'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理注册逻辑</span></span><br><span class="line"><span class="comment">     * @param req</span></span><br><span class="line"><span class="comment">     * @param res</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    processRegister: <span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 由请求参数构造待创建 User 对象</span></span><br><span class="line">        <span class="keyword">var</span> user = req.allParams();</span><br><span class="line">        User.create(user).exec(<span class="function"><span class="keyword">function</span> <span class="title">createCB</span>(<span class="params">err, created</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(err)&#123;</span><br><span class="line">               <span class="comment">// 如果有误，返回错误</span></span><br><span class="line">                res.view(<span class="string">'passport/register'</span>,&#123;<span class="attr">err</span>:err&#125;);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 否则，将新创建的用户登录</span></span><br><span class="line">                req.login(created, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (err) &#123; <span class="keyword">return</span> next(err); &#125;</span><br><span class="line">                    <span class="keyword">return</span> res.redirect(<span class="string">'/'</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理登陆逻辑</span></span><br><span class="line"><span class="comment">     * @param req</span></span><br><span class="line"><span class="comment">     * @param res</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    processLogin: <span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 使用本地验证策略对登录进行验证</span></span><br><span class="line">        passport.authenticate(<span class="string">'local'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, user, info</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> ((err) || (!user)) &#123;</span><br><span class="line">                <span class="keyword">return</span> res.send(&#123;</span><br><span class="line">                    message: info.message,</span><br><span class="line">                    user: user</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            req.logIn(user, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (err) res.send(err);</span><br><span class="line">                <span class="keyword">return</span> res.send(&#123;</span><br><span class="line">                    message: info.message,</span><br><span class="line">                    user: user</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        &#125;)(req, res);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理登出逻辑</span></span><br><span class="line"><span class="comment">     * @param req</span></span><br><span class="line"><span class="comment">     * @param res</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    logout: <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">        req.logout();</span><br><span class="line">        res.redirect(<span class="string">'/'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>任何 Sails 的控制器方法都有两个参数，<a href="http://www.sailsjs.org/documentation/reference/request-req" target="_blank" rel="noopener"> req（请求）对象</a>及<a href="http://www.sailsjs.org/documentation/reference/response-res" target="_blank" rel="noopener"> res（响应）对象</a>。</p></blockquote><p>创建 config/passport.js 对 Passport 验证进行如下配置：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> passport = <span class="built_in">require</span>(<span class="string">'passport'</span>),</span><br><span class="line">    <span class="comment">// 使用本地登录逻辑</span></span><br><span class="line">    LocalStrategy = <span class="built_in">require</span>(<span class="string">'passport-local'</span>).Strategy,</span><br><span class="line">    <span class="comment">// 使用 bcrypt 进行密码加密</span></span><br><span class="line">    bcrypt = <span class="built_in">require</span>(<span class="string">'bcrypt'</span>);</span><br><span class="line"></span><br><span class="line">passport.serializeUser(<span class="function"><span class="keyword">function</span>(<span class="params">user, done</span>) </span>&#123;</span><br><span class="line">    done(<span class="literal">null</span>, user.id);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">passport.deserializeUser(<span class="function"><span class="keyword">function</span>(<span class="params">id, done</span>) </span>&#123;</span><br><span class="line">    User.findOne(&#123; <span class="attr">id</span>: id &#125; , <span class="function"><span class="keyword">function</span> (<span class="params">err, user</span>) </span>&#123;</span><br><span class="line">        done(err, user);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">passport.use(<span class="keyword">new</span> LocalStrategy(&#123;</span><br><span class="line">        usernameField: <span class="string">'email'</span>,</span><br><span class="line">        passwordField: <span class="string">'password'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">email, password, done</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        User.findOne(&#123; <span class="attr">email</span>: email &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err, user</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (err) &#123; <span class="keyword">return</span> done(err); &#125;</span><br><span class="line">            <span class="keyword">if</span> (!user) &#123;</span><br><span class="line">                <span class="keyword">return</span> done(<span class="literal">null</span>, <span class="literal">false</span>, &#123; <span class="attr">message</span>: <span class="string">'Incorrect email.'</span> &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            bcrypt.compare(password, user.password, <span class="function"><span class="keyword">function</span> (<span class="params">err, res</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (!res)</span><br><span class="line">                    <span class="keyword">return</span> done(<span class="literal">null</span>, <span class="literal">false</span>, &#123;</span><br><span class="line">                        message: <span class="string">'Invalid Password'</span></span><br><span class="line">                    &#125;);</span><br><span class="line">                <span class="keyword">var</span> returnUser = &#123;</span><br><span class="line">                    email: user.email,</span><br><span class="line">                    createdAt: user.createdAt,</span><br><span class="line">                    id: user.id</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">return</span> done(<span class="literal">null</span>, returnUser, &#123;</span><br><span class="line">                    message: <span class="string">'Logged In Successfully'</span></span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">));</span><br></pre></td></tr></table></figure><h2 id="访问控制（ACL）"><a href="#访问控制（ACL）" class="headerlink" title="访问控制（ACL）"></a>访问控制（ACL）</h2><p>将 Sails 启动后，访问 <a href="http://localhost:1337" target="_blank" rel="noopener"> localhost:1337/register </a> 进行用户注册:</p><div style="text-align:center"><br><img src="http://7pulhb.com1.z0.glb.clouddn.com/sails-%E6%B3%A8%E5%86%8C%E9%A1%B5%E9%9D%A2.png" width="500"><br></div><p>然后可以在 MongoDB 中看到，我们成功创建了用户:</p><div style="text-align:center"><br><img src="http://7pulhb.com1.z0.glb.clouddn.com/sails-2_user_created.png" width="300"><br></div><h3 id="Policies"><a href="#Policies" class="headerlink" title="Policies"></a>Policies</h3><p>如何对系统中的页面进行访问控制，这里就要用到 Sails 的核心组件 —<a href="http://www.sailsjs.org/documentation/concepts/policies" target="_blank" rel="noopener"> Policies </a>，接下来我们创建几个 policy 来对我们的业务逻辑进行访问控制（access control）。</p><p>首先，创建 api/policies/isAuthenticated.js，该 policy 用于判断请求是否得到授权（即用户是否登录）：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户是否被授权</span></span><br><span class="line"><span class="comment"> * @param req</span></span><br><span class="line"><span class="comment"> * @param res</span></span><br><span class="line"><span class="comment"> * @param next</span></span><br><span class="line"><span class="comment"> * @returns &#123;*&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (req.isAuthenticated()) &#123;</span><br><span class="line">        <span class="keyword">return</span> next();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> res.redirect(<span class="string">'/login'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为本博客系统为私人博客，故在跳转到注册的业务逻辑时，我们需要知道用户是否被创建，如果用户被创建，则跳转回首页，否则继续执行注册相应逻辑：</p><p>创建 api/policies/userNotCreated.js：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 检查数据库中是否已经有用户</span></span><br><span class="line">    User.find().exec(<span class="function"><span class="keyword">function</span>(<span class="params">err,users</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(users.length)&#123;</span><br><span class="line">            res.redirect(<span class="string">'/logout'</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            next();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>同时，本系统显然只有当用户存在时访问才是有效地（否则没有文章来源）。创建 api/policies/userCreated.js：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 检查数据库中是否已经有用户</span></span><br><span class="line">    User.find().exec(<span class="function"><span class="keyword">function</span>(<span class="params">err,users</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(users.length)&#123;</span><br><span class="line">            next();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            res.redirect(<span class="string">'/register'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后设置 config/policies.js，建立 policy 与各业务逻辑的映射关系：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Policy Mappings</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">module</span>.exports.policies = &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认所有行为需要登录</span></span><br><span class="line">    <span class="comment">// 若某些行为不需要，则在下面声明</span></span><br><span class="line">    <span class="string">'*'</span>: <span class="string">'isAuthenticated'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证逻辑都不需要登录</span></span><br><span class="line">    <span class="comment">// 用户创建后不再允许注册</span></span><br><span class="line">    AuthController: &#123;</span><br><span class="line">        <span class="string">'*'</span>: <span class="literal">true</span>,</span><br><span class="line">        toRegister: <span class="string">'userNotCreated'</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>true</code> 代表该业务逻辑可被任何角色访问，而通配符 <code>*</code> 则代表所有业务逻辑。</p><p>接下来重启 sails，并访问<a href="http://localhost:1337" target="_blank" rel="noopener"> localhost:1337 </a>，我们将会被跳转登录页：</p><div style="text-align:center"><br><img src="http://7pulhb.com1.z0.glb.clouddn.com/sails - 登陆页面. png" width="800"><br></div><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>诸如站点名称（siteName），站点简介（siteDesc）等属性将经常被不止一个页面所访问，如果每次我们进行数据库查询获取这两个数据将会是十分低效的，在这里，我们通过 Sails 来设置这两个属性。</p><p>创建 config/site.js：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports.site = &#123;</span><br><span class="line">    <span class="comment">// 站点名称</span></span><br><span class="line">    name  : <span class="string">""</span>,</span><br><span class="line">    <span class="comment">// 站点介绍</span></span><br><span class="line">    desc  : <span class="string">""</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在，在 swig 中，我们可以通过如下方式访问到这两个变量了：</p><figure class="highlight twig"><table><tr><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-variable">&#123;&#123; sails.config.site.name &#125;&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-variable">&#123;&#123; sails.config.site.desc &#125;&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure><p>这样的书写方式太过冗长，为此，我们修改我们的视图配置，让页面维护一个 <code>site</code> 对象：</p><p><strong>config/views.js</strong>:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> extras = <span class="built_in">require</span>(<span class="string">'swig-extras'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports.views = &#123;</span><br><span class="line">    engine: &#123;</span><br><span class="line">        <span class="comment">/* Template File Extension */</span></span><br><span class="line">        ext: <span class="string">'swig'</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Function to handle render request */</span></span><br><span class="line">        fn: <span class="function"><span class="keyword">function</span> (<span class="params">path, data, cb</span>) </span>&#123;</span><br><span class="line">            <span class="comment">/* Swig Renderer */</span></span><br><span class="line">            <span class="keyword">var</span> swig = <span class="built_in">require</span>(<span class="string">'swig'</span>);</span><br><span class="line">            <span class="comment">// 保证我们在开发环境下每次更改 swig 不用重启 sails</span></span><br><span class="line">            <span class="keyword">if</span> (data.settings.env === <span class="string">'development'</span>) &#123;</span><br><span class="line">                swig.setDefaults(&#123;<span class="attr">cache</span>: <span class="literal">false</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 维护一个 site 变量</span></span><br><span class="line">            data.site = sails.config.site;</span><br><span class="line">            <span class="comment">// 提供一个变量标示用户是否登录</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> (data.isLogged) == <span class="string">'undefined'</span>) &#123;</span><br><span class="line">                data.isLogged = !!data.req.isAuthenticated();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 绑定一些常用路径</span></span><br><span class="line"><span class="comment">             * Thanks to: https://github.com/mahdaen/sails-views-swig</span></span><br><span class="line"><span class="comment">             * */</span></span><br><span class="line">            <span class="keyword">var</span> paths = &#123;</span><br><span class="line">                script: <span class="string">'/js'</span>,</span><br><span class="line">                style: <span class="string">'/styles/default'</span>,</span><br><span class="line">                image: <span class="string">'/images'</span>,</span><br><span class="line">                font: <span class="string">'/fonts'</span>,</span><br><span class="line">                icon: <span class="string">'/icons'</span>,</span><br><span class="line">                bower: <span class="string">'/bower_components'</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!data.path) &#123;</span><br><span class="line">                data.path = paths;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> paths) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!key <span class="keyword">in</span> data.path) &#123;</span><br><span class="line">                        data.path[key] = paths[key];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 补充 extra</span></span><br><span class="line">            extras.useFilter(swig, <span class="string">'split'</span>);</span><br><span class="line">            <span class="comment">/* Render Templates */</span></span><br><span class="line">            <span class="keyword">return</span> swig.renderFile(path, data, cb);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    layout: <span class="string">'layout'</span>,</span><br><span class="line"></span><br><span class="line">    partials: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>显然，每次服务器启动的时候就应当设置这两个变量，为此，我们修改 config/bootstrap.js，该文件可以配置服务器启动时的相应动作：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports.bootstrap = <span class="function"><span class="keyword">function</span> (<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 启动时刷新站点信息</span></span><br><span class="line">    User.find().exec(<span class="function"><span class="keyword">function</span>(<span class="params">err,users</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(users.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> user = users[<span class="number">0</span>];</span><br><span class="line">            sails.config.site.name = user.siteName;</span><br><span class="line">            sails.config.site.desc = user.siteDesc;</span><br><span class="line">        &#125;</span><br><span class="line">        cb();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而每次用户信息创建或更新时也应当更新站点配置，为此，我们在 user 模型中添加新的生命期回调： <code>afterUpdate</code> 及 <code>afterCreate</code>:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">afterCreate: <span class="function"><span class="keyword">function</span> (<span class="params">createdUser, cb</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.updateSite(user);</span><br><span class="line">    cb();</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户信息更新时，更新站点信息</span></span><br><span class="line">afterUpdate: <span class="function"><span class="keyword">function</span> (<span class="params">user,cb</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.updateSite(user);</span><br><span class="line">    cb();</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新站点信息</span></span><br><span class="line">updateSite: <span class="function"><span class="keyword">function</span>(<span class="params">user</span>)</span>&#123;</span><br><span class="line">    sails.config.site.name = user.siteName;</span><br><span class="line">    sails.config.site.desc = user.siteDesc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="表单验证"><a href="#表单验证" class="headerlink" title="表单验证"></a>表单验证</h2><p>后端的属性验证已经在对应的 user 模型中设置好了，现在我们利用 semantic-ui 的 <a href="http://semantic-ui.com/collections/form.html" target="_blank" rel="noopener">表单验证模块</a> 来设置前端表单验证，让登录注册页的交互更加完整。</p><p>首先，我们要在 assets/js/common/main.js 中手动声明 semantic 表单验证组件的位置：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第三方模块声明</span></span><br><span class="line"><span class="built_in">require</span>.config(&#123;</span><br><span class="line">    baseUrl: <span class="string">'/bower_components/'</span>,</span><br><span class="line">    paths: &#123;</span><br><span class="line">        jquery: <span class="string">'jquery/dist/jquery'</span>,</span><br><span class="line">        requirejs: <span class="string">'requirejs/require'</span>,</span><br><span class="line">        <span class="string">'semantic-ui'</span>: <span class="string">'semantic-ui/dist/semantic'</span>,</span><br><span class="line">        underscore: <span class="string">'underscore/underscore'</span>,</span><br><span class="line">        backbone: <span class="string">'backbone/backbone'</span>,</span><br><span class="line">        <span class="string">'semantic-form'</span>: <span class="string">'semantic-ui/dist/components/form.min'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    packages: [</span><br><span class="line"></span><br><span class="line">    ]</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 加载 app，并运行</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">'/js/common/app.js'</span>],<span class="function"><span class="keyword">function</span>(<span class="params">app</span>)</span>&#123;</span><br><span class="line">    app.init();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>接下来，我们在 assets/js/passport 目录下创建三个文件：</p><ul><li>login.js</li><li>register.js</li><li>PassportPanel.js</li></ul><p>其中，PassportPanel.js 中提供一个账户框视图组件，该组件继承自 <code>Backbone.View</code> ，供 login 及 register 两个 module 调用。</p><p>PassportPanel.js：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">define([<span class="string">'semantic-form'</span>], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> PassportPanel = Backbone.View.extend(&#123;</span><br><span class="line">        el: $(<span class="string">'.passportContainer'</span>),</span><br><span class="line">        events: &#123;</span><br><span class="line">            <span class="string">'click input'</span>: <span class="string">'hideError'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        initialize: <span class="function"><span class="keyword">function</span> (<span class="params">which</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 初始化时绑定表单验证</span></span><br><span class="line">            <span class="keyword">if</span> (which === <span class="string">'login'</span>)</span><br><span class="line">                <span class="keyword">this</span>.bindLoginForm();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">this</span>.bindRegForm();</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 聚焦输入框时，隐藏错误提示</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        hideError: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> ($(<span class="string">'.error'</span>).length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!$(<span class="string">'.error'</span>).is(<span class="string">':hidden'</span>)) &#123;</span><br><span class="line">                    $(<span class="string">'.error'</span>).hide();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 绑定登录表单验证</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        bindLoginForm: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            $(<span class="string">'.ui.form'</span>).form(&#123;</span><br><span class="line">                inline: <span class="literal">true</span>,</span><br><span class="line">                fields: &#123;</span><br><span class="line">                    email: &#123;</span><br><span class="line">                        identifier: <span class="string">'email'</span>,</span><br><span class="line">                        rules: [</span><br><span class="line">                            &#123;</span><br><span class="line">                                type: <span class="string">'email'</span>,</span><br><span class="line">                                prompt: <span class="string">'请填写正确的邮箱'</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        ]</span><br><span class="line">                    &#125;,</span><br><span class="line">                    password: &#123;</span><br><span class="line">                        identifier: <span class="string">'password'</span>,</span><br><span class="line">                        rules: [</span><br><span class="line">                            &#123;</span><br><span class="line">                                type: <span class="string">'empty'</span>,</span><br><span class="line">                                prompt: <span class="string">'请填写密码'</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        ]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 绑定注册表单验证</span></span><br><span class="line">        bindRegForm: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            $(<span class="string">'.ui.form'</span>).form(&#123;</span><br><span class="line">                inline: <span class="literal">true</span>,</span><br><span class="line">                fields: &#123;</span><br><span class="line">                    siteName: &#123;</span><br><span class="line">                        identifier: <span class="string">'siteName'</span>,</span><br><span class="line">                        rules: [</span><br><span class="line">                            &#123;</span><br><span class="line">                                type: <span class="string">'empty'</span>,</span><br><span class="line">                                prompt: <span class="string">'站点名不能为空'</span></span><br><span class="line">                            &#125;,</span><br><span class="line">                            &#123;</span><br><span class="line">                                type: <span class="string">'maxLength[10]'</span>,</span><br><span class="line">                                prompt: <span class="string">'站点名不能超过 10 个字符'</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        ]</span><br><span class="line">                    &#125;,</span><br><span class="line">                    email: &#123;</span><br><span class="line">                        identifier: <span class="string">'email'</span>,</span><br><span class="line">                        rules: [</span><br><span class="line">                            &#123;</span><br><span class="line">                                type: <span class="string">'email'</span>,</span><br><span class="line">                                prompt: <span class="string">'请填写正确的邮箱'</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        ]</span><br><span class="line">                    &#125;,</span><br><span class="line">                    password: &#123;</span><br><span class="line">                        identifier: <span class="string">'password'</span>,</span><br><span class="line">                        rules: [</span><br><span class="line">                            &#123;</span><br><span class="line">                                type: <span class="string">'length[6]'</span>,</span><br><span class="line">                                prompt: <span class="string">'密码不能少于 6 位'</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        ]</span><br><span class="line">                    &#125;,</span><br><span class="line">                    siteDesc: &#123;</span><br><span class="line">                        identifier: <span class="string">'siteDesc'</span>,</span><br><span class="line">                        rules: [</span><br><span class="line">                            &#123;</span><br><span class="line">                                type: <span class="string">'maxLength[20]'</span>,</span><br><span class="line">                                prompt: <span class="string">'站点简介不超过 20 字符'</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        ]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> PassportPanel;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>login.js：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">define([<span class="string">'./PassportPanel.js'</span>],<span class="function"><span class="keyword">function</span>(<span class="params">PassportPanel</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        run: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">// 如果有错误，则当 focus 输入域时，自动隐藏错误提示</span></span><br><span class="line">            <span class="keyword">var</span> loginPanel = <span class="keyword">new</span> PassportPanel(<span class="string">'login'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>register.js：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">define([<span class="string">'./PassportPanel.js'</span>],<span class="function"><span class="keyword">function</span>(<span class="params">PassportPanel</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        run : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> regPanel = <span class="keyword">new</span> PassportPanel(<span class="string">'reg'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>测试一下：</p><div style="text-align: center"><br><img src="http://7pulhb.com1.z0.glb.clouddn.com/sails-%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81%E6%B5%8B%E8%AF%95.png" width="800"><br></div><h2 id="章节预告"><a href="#章节预告" class="headerlink" title="章节预告"></a>章节预告</h2><p>在下一章当中，我们开始实现博客系统的文章模块。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;章节概述&quot;&gt;&lt;a href=&quot;#章节概述&quot; class=&quot;headerlink&quot; title=&quot;章节概述&quot;&gt;&lt;/a&gt;章节概述&lt;/h2&gt;&lt;p&gt;在本章中，你讲学习到如下知识：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Sails 中如何配置 MongoDB。&lt;/li&gt;
&lt;li&gt;Sails 中的模型层（Models）知识，如模型属性（attributes），模型生命期回调（lifecycle callbacks）等。&lt;/li&gt;
&lt;li&gt;利用 Passport.js 来管理我们的账户认证。&lt;/li&gt;
&lt;li&gt;认识密码加密策略 bcrypt。&lt;/li&gt;
&lt;li&gt;认识 Sails 的核心模块 policies。&lt;/li&gt;
&lt;li&gt;如何在 Sails 中撰写自定义配置。&lt;/li&gt;
&lt;li&gt;如何扩展 swig 模板引擎。&lt;/li&gt;
&lt;li&gt;semantic-ui 中表单验证模块的应用。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="利用 Sails.js + MongoDB 开发博客系统" scheme="http://yoyoyohamapi.me/categories/%E5%88%A9%E7%94%A8-Sails-js-MongoDB-%E5%BC%80%E5%8F%91%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Sails" scheme="http://yoyoyohamapi.me/tags/Sails/"/>
    
      <category term="Node" scheme="http://yoyoyohamapi.me/tags/Node/"/>
    
      <category term="MongoDB" scheme="http://yoyoyohamapi.me/tags/MongoDB/"/>
    
  </entry>
  
</feed>
