<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>吴小蛆的巣</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoyoyohamapi.me/"/>
  <updated>2020-03-01T16:16:47.240Z</updated>
  <id>http://yoyoyohamapi.me/</id>
  
  <author>
    <name>吴晓军</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从流行的编辑器架构聊聊富文本编辑器的困境</title>
    <link href="http://yoyoyohamapi.me/2020/03/01/%E4%BB%8E%E6%B5%81%E8%A1%8C%E7%9A%84%E7%BC%96%E8%BE%91%E5%99%A8%E6%9E%B6%E6%9E%84%E8%81%8A%E8%81%8A%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E7%9A%84%E5%9B%B0%E5%A2%83/"/>
    <id>http://yoyoyohamapi.me/2020/03/01/从流行的编辑器架构聊聊富文本编辑器的困境/</id>
    <published>2020-03-01T15:54:00.000Z</published>
    <updated>2020-03-01T16:16:47.240Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2020/03/01/从流行的编辑器架构聊聊富文本编辑器的困境/cover.jpg" alt="图片取自 https://webdevtrick.com/javascript-rich-text-editor/"></p><h2 id="Why-ContentEditable-is-Terrible"><a href="#Why-ContentEditable-is-Terrible" class="headerlink" title="Why ContentEditable is Terrible?"></a>Why ContentEditable is Terrible?</h2><p>现今主流的 Web 富文本编辑器，大多都是基于 contenteditable 开发的，几年前，Medium Editor 的开发者写过一篇著名的博文：<a href="https://medium.engineering/why-contenteditable-is-terrible-122d8a40e480" target="_blank" rel="noopener">Why ContentEditable is Terrible?</a>，当中列举了一些 contenteditable 存在的一些问题：</p><a id="more"></a><h3 id="视觉内容（用户所见）与实际内容（DOM）的一对多关系"><a href="#视觉内容（用户所见）与实际内容（DOM）的一对多关系" class="headerlink" title="视觉内容（用户所见）与实际内容（DOM）的一对多关系"></a>视觉内容（用户所见）与实际内容（DOM）的一对多关系</h3><p><img src="/2020/03/01/从流行的编辑器架构聊聊富文本编辑器的困境/1-many.png" alt="1-to-many"></p><p>看上去一样的文本内容，却可能对应了多种 DOM 结构，例如下面这段文字：</p><blockquote><p>The hobbit was a very well-to-do hobbit, and his name was <strong><em>Baggins</em></strong>.</p></blockquote><p>描述这句话的 HTML 可以有多种：</p><p><img src="/2020/03/01/从流行的编辑器架构聊聊富文本编辑器的困境/multiple-html.png" alt="html">)</p><p>如果你的编辑器使用了 contenteditble ，并且将编辑行为都托管给了浏览器，那么在不同的 DOM 结构下，执行相同的操作，浏览器要能够输出一样的视觉内容。</p><h3 id="视觉选区与实际选区的多对多关系"><a href="#视觉选区与实际选区的多对多关系" class="headerlink" title="视觉选区与实际选区的多对多关系"></a>视觉选区与实际选区的多对多关系</h3><p><img src="/2020/03/01/从流行的编辑器架构聊聊富文本编辑器的困境/many-many.png" alt="many-to-many"></p><p>选区的情况则更加糟糕，一个视觉选区可能映射为多种 DOM 选区，而一个 DOM 选区也可能映射为多个视觉选区，例如我们的 HTML 为:</p><p><img src="/2020/03/01/从流行的编辑器架构聊聊富文本编辑器的困境/selection-html.png" alt="selection-html"></p><p>如果用户看到光标落在 <code>Baggins</code> 之前，那么 DOM 选区可以是：</p><p><img src="/2020/03/01/从流行的编辑器架构聊聊富文本编辑器的困境/dom-selection.png" alt="dom-selections"></p><p>在光标位置插入字符 <code>I</code>，上面不同的 DOM 选区就会让用户看到不同的文本</p><ul><li>his name was I<strong><em>Baggins</em></strong></li><li>his name was <strong>I*</strong>Baggins*</li><li>his name was <strong><em>IBaggins</em></strong></li></ul><p>而在文本：</p><blockquote><p>The hobbit was a very well-to-do hobbit, and his name was <strong><em>Baggins</em></strong>.</p></blockquote><p>的 <code>well-to-</code> 后回车，用户将看到：</p><blockquote><p>The hobbit was a very well-to<br>do hobbit, and his name was Baggins.</p></blockquote><p>从第一行末尾到第二行开头的 DOM 选区，在视觉上看有两种可能，要么在第一行末尾，要么在第二行开头。面对这样的 “悬摆 DOM 选区”，你无法告诉浏览器将其映射为哪个视觉选区。</p><p>让浏览器自己实现 contenteditbale 元素视觉与实际的统一，已经颇为不易，如果还期盼不同的对 contenteditbale 有一致的处理，就难上加难了。这也就是为什么时至今日，浏览器在功能和性能上已经大幅发展了，开发者还是不信任它的富文本处理能力，社区的 Web 富文本编辑器也还是层出不穷。</p><p>Why ContentEditable is Terrible? 还有一个副标题： <em>How Medium Editor Works?</em>，它不仅仅描述了 contenteditable 存在的缺陷，还以此为引，阐述了 Medium Editor 的工作机制。近年来社区活跃度颇高的 Slate.js，Draft.js 、ProseMirror 以及 CKEditor 等也使用了类似的机制，来规避 contenteditable 缺陷，这个机制可以被简单描述为：</p><ul><li><p><strong> 模型与视图相分离 </strong></p><ul><li>让编辑器决定数据结构（内容 + 选区），保证视觉与实际一致</li><li>方便同样的内容在不同设备设备展示</li></ul></li><li><p><strong> 自定义命令 </strong></p><ul><li>脱离实现不一的浏览器命令（<code>document.execCommand</code>），自行划定编辑器的操作范围</li></ul></li></ul><p>这种机制最小程度使用了 contenteditble —— 仅仅让一个节点的 HTML 内容允许被编辑，而如何编辑，编辑器结果则收敛到了编辑器治理：</p><p><img src="/2020/03/01/从流行的编辑器架构聊聊富文本编辑器的困境/sync-editor.png" alt="sync"></p><h2 id="防患未然：基于行为的同步策略"><a href="#防患未然：基于行为的同步策略" class="headerlink" title="防患未然：基于行为的同步策略"></a>防患未然：基于行为的同步策略</h2><p>编辑器使用了视图模型相分离的架构，就需要处理视图与模型间的同步，当用户在编辑器完成了操作后，编辑器据此更新数据模型，再通过数据模型渲染出新的页面视图即对视图：</p><p><img src="/2020/03/01/从流行的编辑器架构聊聊富文本编辑器的困境/model-view-sync.png" alt="model-view-sync"></p><p>编辑器是如何知道用户执行了哪个操作呢？答案就是 DOM 事件，假设监听到了 <code>keyCode = 8</code> 的 keydown 事件（Event），就推测用户是在执行退格（Intent），从而调用自定义的删除指令（Command），修改数据模型，最终用户看到光标前的字符被成功删除了。</p><p>基于事件拦截的数据同步，是理想型的同步链路，先更新模型，再渲染视图，由于模型和视图一一对应的关系，用户执行了相同的操作，总能获得一致的 DOM 结构，</p><p>然而，由于 DOM Event 的规范仍然在发展，各个浏览器对其的实现也不尽相同，因此，基于事件拦截的同步也不完全可靠。</p><p>举个例子来说，beforeinput event 是非常有用的一个事件，该事件在 <a href="https://www.w3.org/TR/2017/WD-input-events-1-20170321/" target="_blank" rel="noopener">Input Events Level 1</a> 被定义，并在 <a href="https://www.w3.org/TR/input-events-2/" target="_blank" rel="noopener">Input Events Level 2</a> 中获得完善，规范希望能帮助类似 Web 富文本编辑器这样的应用更容易地处理用户输入。</p><p>beforeinput event 能让开发者在输入反馈到 UI 之前，通过事件的 <code>inputType</code> 属性知悉用户输入意图（例如，当 <code>inputType</code> 是 <code>deleteContentBackward</code> 时，我们就知道用户正在向前删除内容）， 但尴尬的是：</p><ul><li>要么浏览器不支持这个事件</li><li>要么部分支持这个事件：例如覆盖到的 input type 不全</li></ul><p><img src="/2020/03/01/从流行的编辑器架构聊聊富文本编辑器的困境/beforeinput-compat.png" alt="beforeinput-compat"></p><p>因此，DOM Event 本身的不完美，也就让编辑器难以完全摸清用户意图。而对用户意图的模糊，也会造成：</p><ul><li><strong> 无法理解 </strong>：编辑器忽略了某个用户操作</li><li><strong> 理解错误 </strong>：将用户的操作理解为了另一个操作，例如用户是在输入，但被编辑器理解为了删除，造成数据模型发生非预期变更，用户看到错误的视图</li></ul><p>因此，基于事件的同步模型也是一个理想型模型，受限于浏览器支持，在实际应用中并不完全可靠。</p><h2 id="亦敌亦友：输入法"><a href="#亦敌亦友：输入法" class="headerlink" title="亦敌亦友：输入法"></a>亦敌亦友：输入法</h2><p>在编辑器的生态中，作为文本合成（Text Composition）的主要手段，输入法能让编辑器展示和处理更多的语言，是编辑器的不可获取的伙伴。然后输入法本身又不受控于编辑器，它完全由第三方厂商实现，其实现也只和操作系统有关，而你编辑器的生死存亡，却不是它的义务：</p><p><img src="/2020/03/01/从流行的编辑器架构聊聊富文本编辑器的困境/os-ime-browser.png" alt="os-ime-browser"></p><p>我们看到，当生态中加入输入法之后，链路变得更加复杂了：输入法和操作系统交互来合成文本，浏览器也通过操作系统，获得输入法状态，在输入过程中抛出对应事件。</p><p>其次，抛开这个链路不看，输入法自己也不是个 “省油的灯”：</p><ul><li><strong> 输入法繁多 </strong>：不同的操作系统版本、浏览器内核，和输入法能形成众多的组合，每种组合在 contenteditable 元素上进行文本合成的时候，难以形成一致的事件流</li><li><strong> 输入方式多样 </strong>：除了键盘能够进行文本合成，还要支持手写、语音等输入方式</li></ul><p>而 Android 因为其生态紊乱，系统版本分布广泛，使用不同内核的浏览器众多，应用市场的第三方输入法层出不穷，让基于事件进行同步的策略更加脆弱。举个例子，我们在 Android 下使用某个第三方浏览器配合上某个第三方输入法编写内容时，可能遇到：</p><ul><li><strong> 浏览器不会抛出 beforeinput 事件 </strong>：编辑器无法通过 beforeinput 事件中的 inputType 属性知悉用户行为</li><li><strong> 浏览器没有传递正确的虚拟键盘响应 </strong>：很多 Andorid 输入法都支持字词联想，当虚拟键盘呼出后，开始进入 Composing 状态，此时 keydown 事件的 <code>keyCode</code> 都会被设置为 229，那么编辑器无法也无法从 keydown 事件知悉用户行为</li></ul><blockquote><p><a href="https://lists.w3.org/Archives/Public/www-dom/2010JulSep/att-0182/keyCode-spec.html" target="_blank" rel="noopener">W3C KeyCode 规范</a> 定义了 keyCode 为 229 的 Keyboard Event 是表示输入法正在处理按键输入</p></blockquote><p>这就会造成比较恶性的现象，举个例子，当用户将光标放置在图片之后时，输入法被唤起，用户通过虚拟键盘按下了退格键希望能够删除图片。但由于编辑器既无法拦截 beforeinput 事件来判断用户是不是在执行删除，也无法通过 keydown 事件判断判断键盘的退格是否被按下，因此，也就不会生成对应的命令去修改数据模型，删除对应节点。此时，用户无论怎么疯狂点按退格，都不能把图片删掉。</p><p>因此，基于事件的同步策略，在面对输入法时，变得更加不可靠，社区目前流行的开源编辑器也仍在和 Android 输入法作斗争：</p><p><img src="/2020/03/01/从流行的编辑器架构聊聊富文本编辑器的困境/android-compat.png" alt="android-compat"></p><h2 id="亡羊补牢：基于现象的同步策略"><a href="#亡羊补牢：基于现象的同步策略" class="headerlink" title="亡羊补牢：基于现象的同步策略"></a>亡羊补牢：基于现象的同步策略</h2><p>编辑器之所以希冀于事件去同步数据模型和视图，是期望在浏览器对页面执行变更前，尽早将用户行为同步到数据模型上，实现实际内容与视觉内容的统一。但我们发现，这个本就不健壮的策略再遇到输入法之后，无法响应用户操作的概率更高了。</p><p>如果回到架构之前，仍然托管 contenteditable 的控制权给浏览器，那么，我们发现，输入法的增删改查还是能正确响应的，这也就说明了，托管给浏览器去处理 contenteditable，用户最基本的编辑诉求还是可以保障的。但我们又不能放任浏览器这么做，原因在开篇回顾 Why ContentEditable is Terrible 中也说了，因此，当浏览器处理了用户的行为并更新了视图后，我们要尽快的去 “纠正” 数据模型，亡羊补牢，犹未为晚。</p><p>浏览器提供了 <a href="https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver" target="_blank" rel="noopener">Mutation Observer</a> 来让开发者监听 DOM 变更，它的 API 非常简单，初始化观察者之后，在适当时机开始观察即可，每次观察到的变更序列，其中的元素都是 <a href="https://developer.mozilla.org/en-US/docs/Web/API/MutationRecord" target="_blank" rel="noopener">MutationRecord</a> 对象:</p><p><img src="/2020/03/01/从流行的编辑器架构聊聊富文本编辑器的困境/mutation-observer.png" alt="mutation-observer"></p><p>借助于 Mutation Observer，编辑器在观察到 DOM 变化后，可以根据变化（现象）来反推用户行为，从而生成对应的命令，去修缮数据模型：</p><p><img src="/2020/03/01/从流行的编辑器架构聊聊富文本编辑器的困境/by-mutation-observer.png" alt="mutation-to-intent"></p><p>例如，经过反复的验证发现，当用户在某个段落顶部按下退格并合并了上下两个段落后，observer 将观察到一个 mutation 序列，这个序列的特征为：</p><ul><li>第一个 mutation record 的类型为 <code>childList</code>，且 removeNodes 不为空</li><li>mutation 序列包含了多个 mutation record</li></ul><p>那么，我们就告诉编辑器，当观察到这样的 mutation 序列时，就是用户完成了合并段落，你需要去执行一条 <code>merge-block</code> 的指令，合并数据模型上的两个段落。</p><p>这种 <strong> 事后同步 </strong>，弥补了浏览器无法派发正确事件时，我们仍能推测用户行为 —— 通过现象去反推用户行为。但是，由于现象的成因可能有多个，因此我们就可能造成错误的推断：</p><p><img src="/2020/03/01/从流行的编辑器架构聊聊富文本编辑器的困境/mutilple-predication.png" alt="predication"></p><p>就拿上面的举例的 mutation 序列来说，编辑器中的图片，在加载完成之前，会先展示 loading 占位，当加载完毕后，observer 也会观察到同样特征的 mutation 序列。但是，编辑器先前已经被告知这样的序列是在合并段落，它会调用 <code>merge-block</code> 指令去修改模型，假设该指令内部还可能调用到 <code>delete</code> 指令，那么就会造成刚加载完成的图片又被删除了，用户永远也无法在编辑器中上传图片。为此，我们又得在算法中告诉编辑器如何识别图片的这个特征。</p><p>其实，算法的工作过程非常类似于机器学习中的分类问题：</p><p><strong> 提取特征 -&gt; 分析特征 -&gt; 获得所属分类 </strong></p><p>这种算法需要被不断地被训练（发现并扩充特征），才能让最后的预测更加精准。只是与机器学习不同的是，我们的是人肉学习，为了获得更多特征，去更精确的映射用户行为，开发者将疲于应付不同的 Android 设备，不同的浏览器，以及不同的输入法形成的种种组合。</p><p>综上，基于现象去同步数据模型，是更不牢靠的手段， 即便开发者投入了大量精力去获得现象和意图间的关联关系，但难免还是有 “漏网之鱼”，导致模型 <strong> 同步错误 </strong>，这也许比不能响应操作更加严重。而基于事件的同步模型，因为事件本身就表达了用户意图，所以推测会更加精准，所以，只有当事件系统不完善时（例如在 Android 设备下），我们才使用基于现象的同步做兜底，保证用户在编辑器能进行最基本的输入。</p><h2 id="DOM-的虚实调和"><a href="#DOM-的虚实调和" class="headerlink" title="DOM 的虚实调和"></a>DOM 的虚实调和</h2><p>刚才所讨论的内容，还聚焦在使用了 contenteditable 的编辑器上，如果编辑器在视图层使用了更高的抽象，例如选用了类似 React 这样的基于虚拟 DOM 的解决方案，那么问题还将加剧。</p><p><img src="/2020/03/01/从流行的编辑器架构聊聊富文本编辑器的困境/xe.png" alt="虚实调和"></p><p>现代化的前端开发中，已经很少使用真实 DOM 来表达一个组件了，如果选用了类似 React 这样的解决方案去描述实现编辑器视图（Slate.js、Draft.js 就倾向于此），就会让视图的表达 “虚实并存”：</p><ul><li><strong> 虚 </strong>：React 根据组件属性和状态，创建并且维护了一棵组件对应的 virtual DOM tree，并使用 virtual DOM tree 渲染节点内容</li><li><strong> 实 </strong>：对 contenteditable 的节点的修改会被浏览器托管，绕开了 React 去修改 DOM</li></ul><p>所以，当你尝试用与下面类似的代码创建一个 contenteditale 组件时：</p><p><img src="/2020/03/01/从流行的编辑器架构聊聊富文本编辑器的困境/react-contenteditable.png" alt="react-contenteditable"></p><p>React 会警告你要自行管控 contenteditable 的节点变更：</p><blockquote><p>Warning: A component is contentEditable and contains children managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.</p></blockquote><p>所以我们在使用诸如 Slate.js 或者 Draft.js 这样的框架时，会遇到下面这样的异常，此时整个编辑器无法继续工作：</p><blockquote><p>DOMException: Failed to execute ‘removeChild’ on ‘Node’: The node to be removed is not a child of this node.</p></blockquote><p>我们姑且称这个现象为：<strong> 虚实不调，阴阳失衡 </strong>。</p><p>在 Android 设备上，为了解决输入法问题，编辑器将输入先托管给浏览器，并 Mutation Observer 观察 DOM 变化，而后再去同步数据模型。在这样的策略下，用户的输入过程在没有结束之前，都是浏览器在处理，当中发生许许多多的变更，不再受 React 控制，很容易造成 “虚实不调”，引起编辑器崩溃。</p><p>因此，当使用了类似 React 这样的方案之后，编辑器需要更加 <strong> 谨小慎微地 </strong> 处理数据同步，在容易引起虚实不调的场合（例如段落分裂与合并），强刷（rerender）编辑器组件，调和虚实，让 DOM 与 VDOM 保持一致。而对于预料不到的场合，可能还需要借助 <code>componentDidCatch</code> 这样的 hook 去俘获异常，强刷组件。有 React 开发经验的同学都知道，对于编辑器这样内部子孙繁多的组件，重绘的开销是非常的，最终，在终端用户一侧，就是看到页面闪烁和卡顿。</p><h2 id="前路漫漫，任重道远"><a href="#前路漫漫，任重道远" class="headerlink" title="前路漫漫，任重道远"></a>前路漫漫，任重道远</h2><p>上文对 Web 富文本编辑器困局的讨论，还仅仅局限单机版的富文本编辑器，如果还要为编辑器支持多人实时协同，那么面对的挑战更加艰巨。</p><p>contenteditable is terrible, 但是编辑器已经最小化了对它的使用，比之更为严峻的是，操作系统、浏览器、输入法相互组合形成的紊乱生态 —— 一个编辑器无法控制的，但产品又期望在上面开出繁花的生态。所以才说，Web 富文本编辑器是前端的天坑之一。</p><p>面对这样的生态，做不到抛弃，编辑器只能去适应和妥协，但在其领域范围内，似乎还可以有一些突破：</p><ul><li><strong> 是否能通过交互绕开缺陷？</strong>：上面我们举例的图片无法通过退格删除的问题，但键盘不是唯一的 I/O，如果在交互上，能多一个删除图片的方式，就不会阻塞用户。</li><li><strong> 是否能脱离 contenteditable 的架构？</strong>：更大程度的以模型为核心，完全自绘内容和选区，脱离 contenteditable，让视图层更加可控。</li></ul><p>但是无论哪种解法，对编辑器的产品逻辑和开发者的技术要求都是非常大的。创建一个优秀的 Web 富文本编辑器，依然任重道远。钉钉文档团队致力于为钉钉用户提供最优质的文档服务，也因此面临着许许多多要去攻坚的技术方向，富文本编辑器就是其中之一，也希望对这个方向感兴趣的同学，和我们一起投入到这个可能会是伟大的历史进程中来：</p><p><img src="/2020/03/01/从流行的编辑器架构聊聊富文本编辑器的困境/pd.png" alt="招聘"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>编辑器技术：钉钉文字编辑技术的蜀道之难</li><li><a href="https://medium.engineering/why-contenteditable-is-terrible-122d8a40e480" target="_blank" rel="noopener">Why ContentEditable is Terrible</a></li><li><a href="https://developer.android.com/guide/topics/text/creating-input-method#kotlin" target="_blank" rel="noopener">Create an input method</a></li><li><a href="https://lists.w3.org/Archives/Public/www-dom/2010JulSep/att-0182/keyCode-spec.html" target="_blank" rel="noopener">keyCode property of key events</a></li><li><a href="https://www.zhihu.com/question/38699645" target="_blank" rel="noopener">知乎 - 为什么都说富文本编辑器是天坑</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2020/03/01/从流行的编辑器架构聊聊富文本编辑器的困境/cover.jpg&quot; alt=&quot;图片取自 https://webdevtrick.com/javascript-rich-text-editor/&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Why-ContentEditable-is-Terrible&quot;&gt;&lt;a href=&quot;#Why-ContentEditable-is-Terrible&quot; class=&quot;headerlink&quot; title=&quot;Why ContentEditable is Terrible?&quot;&gt;&lt;/a&gt;Why ContentEditable is Terrible?&lt;/h2&gt;&lt;p&gt;现今主流的 Web 富文本编辑器，大多都是基于 contenteditable 开发的，几年前，Medium Editor 的开发者写过一篇著名的博文：&lt;a href=&quot;https://medium.engineering/why-contenteditable-is-terrible-122d8a40e480&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Why ContentEditable is Terrible?&lt;/a&gt;，当中列举了一些 contenteditable 存在的一些问题：&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript 编辑器技术" scheme="http://yoyoyohamapi.me/categories/JavaScript-%E7%BC%96%E8%BE%91%E5%99%A8%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JavaScript" scheme="http://yoyoyohamapi.me/tags/JavaScript/"/>
    
      <category term="富文本编辑器" scheme="http://yoyoyohamapi.me/tags/%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>React Suspense 与 Hooks 的另类实现</title>
    <link href="http://yoyoyohamapi.me/2019/07/16/React_Suspense%E4%B8%8EHooks%E7%9A%84%E5%8F%A6%E7%B1%BB%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoyoyohamapi.me/2019/07/16/React_Suspense与Hooks的另类实现/</id>
    <published>2019-07-16T12:47:00.000Z</published>
    <updated>2019-07-16T12:54:46.273Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/07/16/React_Suspense与Hooks的另类实现/cover.png" alt=""></p><a id="more"></a><p>React 16 算的是 React 最大的一次变革，不仅底层实现基于 Fiber 重写，带来了更好的任务调度能力和性能表现，也为开发者提供了诸如 new Context、Suspense 、Hooks 等等强大的 API。</p><p>作为 React 16 新特性拥趸之一，笔者偶然读到 <a href="https://medium.freecodecamp.org/when-to-use-react-suspense-vs-react-hooks-f66ef94cb54f" target="_blank" rel="noopener">《When to use React Suspense vs React Hooks》</a> 这篇文章，千万别被其标题所迷惑，它并不是介绍怎么用 Suspense 和 Hooks 的。</p><p>与笔者之前读过的 Hooks 或者 Suspense 的原理分析不同，该文另辟蹊径，讨论了如何通过 <a href="https://www.wikiwand.com/en/Monad_(functional_programming" target="_blank" rel="noopener">Monad</a>&gt;) 来实现 Suspense 和 Hooks。但是文章 “开门见山”，在没有铺垫的情况下，直接介绍了基于 Monad 的 Suspense 和 Hooks 实现，这就会让读者觉得十分唐突，读起来十分吃力。</p><p>本文基于这篇文章，以思考怎么在函数组件中处理异步任务为引，循序渐进的铺陈 Suspense 和 Hooks 的简单实现，最后引出 Monad，构建一个二者都适用的实现机制。借此，一方面希望读者更加熟悉 Suspense 和 Hooks 的设计来由和方式，一方面也让读者感受到统一数据类型及函数式编程对业务抽象的帮助。</p><blockquote><p>由于笔者能力所限，本文不会对 Monad 和函数式编程做进一步的严肃介绍，感兴趣的读者可以阅读 <strong> 参考资料 </strong> 中的延伸阅读。</p></blockquote><h2 id="怎么让函数组件处理异步任务？"><a href="#怎么让函数组件处理异步任务？" class="headerlink" title="怎么让函数组件处理异步任务？"></a>怎么让函数组件处理异步任务？</h2><p>在 Hooks 推出之前，我们仅仅使用函数组件（Functional Component）编写纯展示组件，它是一个纯函数，给定函数的输入（Props），必然能得到一致的组件结构（DOM）。但如果我们想要打破函数纯度限制，比如我们非要在函数组件中完成一个远程数据拉取和展示，那该怎么做呢？</p><p>说的在具体一些，组件运行伊始，我们拉取数据，若数据尚未到达，则不渲染组件。自然而然地，首先我们会想到 async/await：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> App = <span class="keyword">async</span> props =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> total = <span class="keyword">await</span> fetchTotal();</span><br><span class="line">  <span class="keyword">const</span> users = <span class="keyword">await</span> fetchUsers();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;div&gt;&#123;<span class="string">`Total: <span class="subst">$&#123;total&#125;</span>`</span>&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">        &#123;users.map(user =&gt; (</span></span><br><span class="line"><span class="regexp">          &lt;li&gt;&#123;user.name&#125;&lt;/</span>li&gt;</span><br><span class="line">        ))&#125;</span><br><span class="line">      &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, document.querySelector("#app"));</span></span><br></pre></td></tr></table></figure><p>但运行这段代码，将会报错：</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">Objects are not valid as <span class="selector-tag">a</span> React child (found: [<span class="selector-tag">object</span> Promise])</span><br></pre></td></tr></table></figure><p>这是因为 async 函数最终被转换为了 Promise 对象，而不是 React 组件。那我们当然会想到说，构建一个 转换器，来实现 async function 到 React 组件的转化：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> App = transformer(<span class="keyword">async</span> props =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> total = <span class="keyword">await</span> fetchTotal();</span><br><span class="line">  <span class="keyword">const</span> users = <span class="keyword">await</span> fetchUsers();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;div&gt;&#123;<span class="string">`Total: <span class="subst">$&#123;total&#125;</span>`</span>&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">        &#123;users.map(user =&gt; (</span></span><br><span class="line"><span class="regexp">          &lt;li&gt;&#123;user.name&#125;&lt;/</span>li&gt;</span><br><span class="line">        ))&#125;</span><br><span class="line">      &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="怎样控制业务流程的暂停与继续？"><a href="#怎样控制业务流程的暂停与继续？" class="headerlink" title="怎样控制业务流程的暂停与继续？"></a>怎样控制业务流程的暂停与继续？</h2><p>在实现这个转换器之前，我们先回顾下用 async/await 编写组件的目的：</p><ul><li>使用命令式编程编排异步任务。</li><li>期望获得 await 提供的暂态能力。上例中，我们期望在 <code>total</code> 获得之后，再去拉取 <code>users</code>。</li></ul><p>那么不依赖于 async/await，还要实现运行逻辑的启停，我们可以在逻辑外层包裹一个 runner，顾名思义，它能够控制一段逻辑的运行，当遇到异步副作用时，让流程暂停，等待任务完成，当任务完成时，继续执行流程。</p><p>假定我们使用 Promise 创建了一个异步任务：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fetch = <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">"data"</span>), <span class="number">1000</span>));</span><br></pre></td></tr></table></figure><p>我们也知道，Promise 是使用 <code>then</code> 进行任务串联：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">fetchTotal()</span><br><span class="line">  .then(<span class="function"><span class="params">total</span> =&gt;</span> [total, fetchUsers()])</span><br><span class="line">  .then(<span class="function">(<span class="params">[total, users]</span>) =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure><p>如果期望 runner 能让我们基于 Promise 构建的任务跳脱出 <code>then</code> 的链式调用，而使用 async/await 的命令式风格来控制流程：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> effect = run(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> total = fetchTotal();</span><br><span class="line">  <span class="keyword">const</span> users = fetchUsers();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="/2019/07/16/React_Suspense与Hooks的另类实现/runner.png" alt="runner"></p><p>这能做到吗？首先，我们要思考，JavaScript 是否有能力 <strong> 阻断后续程序流程 </strong>？答案是有的，但要借助于异常与 try/catch，若流程中跑出了一个异常，那么逻辑就会进入 catch 块，而不会执行后续流程：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> task1 = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">throw</span> <span class="string">"error"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> ret1 = task1();</span><br><span class="line">  <span class="comment">// task1 抛出异常，task2 不再执行</span></span><br><span class="line">  <span class="keyword">const</span> ret2 = task2();</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;&#125;</span><br></pre></td></tr></table></figure><p>try-catch 可以阻断后续代码的逻辑，这帮助我们借道实现了 <strong> 暂停当前逻辑 </strong>，但我们还要解决：</p><blockquote><p>当进入暂态的任务完成后，被阻断的逻辑能继续执行。</p></blockquote><p>要回到我们的暂停位置，执行后续流程，其实就要：</p><ol><li>重新执行逻辑，回到暂停发生位置，此时要不再 throw error 进入 暂态，而是直接获得任务结果</li><li>继续后续流程</li></ol><p>因此，我们需要借助于缓存来缓存任务结果，决定再次执行任务时，是否进入暂态：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 标识当前缓存位置</span></span><br><span class="line"><span class="keyword">let</span> pos = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 缓存任务运行结果</span></span><br><span class="line"><span class="keyword">const</span> cache = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> task1 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (cache[pos]) &#123;</span><br><span class="line">    <span class="keyword">return</span> cache[pos++];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">"task1"</span>), <span class="number">1000</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> task2 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (cache[pos]) &#123;</span><br><span class="line">    <span class="keyword">return</span> cache[pos++];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">"task2"</span>), <span class="number">1000</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> main = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> step = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> ret1 = task1();</span><br><span class="line">      <span class="keyword">const</span> ret2 = task2();</span><br><span class="line">      <span class="built_in">console</span>.log(ret1, ret2);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (task) &#123;</span><br><span class="line">      task.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        cache[pos++] = value;</span><br><span class="line">        <span class="comment">// 重启流程</span></span><br><span class="line">        <span class="keyword">return</span> step();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> step();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上例中，重复代码还较多，也并不通用，只能执行 task1 与 task2。我们可以设计一个 <strong>runner</strong>，负责执行基于 Promise 编排的业务流；另外也针对异步任务做一个 <strong>wrapper</strong>，控制任务是否应当进入暂态：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当前执行的位置</span></span><br><span class="line"><span class="keyword">let</span> pos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务执行结果缓存</span></span><br><span class="line"><span class="keyword">let</span> cache = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> wrapTask = <span class="function"><span class="params">task</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (cache[pos]) &#123;</span><br><span class="line">    <span class="keyword">return</span> cache[pos++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> task;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> runner = <span class="function"><span class="params">process</span> =&gt;</span> &#123;</span><br><span class="line">  cache = [];</span><br><span class="line">  <span class="keyword">return</span> step();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 每一步都从头执行</span></span><br><span class="line">    pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> ret = process();</span><br><span class="line">      <span class="keyword">return</span> ret;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (task) &#123;</span><br><span class="line">      <span class="keyword">return</span> task.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        cache[pos] = value;</span><br><span class="line">        <span class="keyword">return</span> step();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/2019/07/16/React_Suspense与Hooks的另类实现/throw_restart.png" alt=""></p><p>现在，我们就能使用命令式风格编排基于 Promise 的业务逻辑了，下面的代码中，只有当 task1 和 task2 都完成了，才会执行 <code>console.log</code>，打印结果：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> task1 = <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">  wrapTask(<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">"task1"</span>), <span class="number">1000</span>)));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> task2 = <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">  wrapTask(<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">"task2"</span>), <span class="number">1000</span>)));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> main = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> ret1 = task1();</span><br><span class="line">  <span class="keyword">const</span> ret2 = task2();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"result is"</span>, re1, ret2);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">run(main); <span class="comment">// result is task1 task2</span></span><br></pre></td></tr></table></figure><p>这段代码的执行流程就为：</p><ul><li>从头执行业务，执行 task1，发现 cache 中没有 task1 的结果，throw task1</li><li>task1 resolved, 从头执行业务</li><li>task1 in cache, 返回 cache 中的结果赋值给 ret，任务游标 + 1，开始后续任务</li><li>task2 执行，发现 cache 中没有 task2 的结果, throw task2</li><li>task2 resolved, 从头执行业务</li><li>task1 in cahce, 返回 cache 中的结果赋值给 ret1，任务游标 + 1，开始后续任务</li><li>task2 in cahce, 返回 cache 中的结果赋值给 ret2</li><li>业务执行完成，退出</li></ul><p>OK，我们总结下基于 try/catch 与 Promise 实现暂态的原理：</p><ul><li>在 try block 中通过 throw promise 进入暂态</li><li>在 catch block 中，通过 <code>promise.then</code> 更新缓存，重启流程，以进行下一步</li></ul><h2 id="实现-React-Suspense"><a href="#实现-React-Suspense" class="headerlink" title="实现 React Suspense"></a>实现 React Suspense</h2><p>React 16 推出的 Suspense 除了做 Code-Splitting，还能实现异步组件。借助于上面实现的流程控制，我们也可以实现 React Suspense。首先，我们创建了一个 <code>withAsync</code> 来包裹函数组件：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> withAsync = <span class="function"><span class="params">func</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">AysncComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">      <span class="keyword">super</span>(props);</span><br><span class="line">      <span class="keyword">this</span>.state = &#123;</span><br><span class="line">        component: <span class="literal">null</span></span><br><span class="line">      &#125;;</span><br><span class="line">      run(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">          component: func(props)</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.state.component;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> AysncComponent;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们看到，在异步创建后，我们启动了一个 runner，来获得每一次函数组件的运行结果。现在，我们就能通过写出含有异步副作用（基于 Promise）的函数组件了：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> task1 = <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">  wrapTask(<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">"task1"</span>), <span class="number">1000</span>)));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> task2 = <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">  wrapTask(<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">"task2"</span>), <span class="number">1000</span>)));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = withAsync(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> ret1 = task1();</span><br><span class="line">  <span class="keyword">const</span> ret2 = task2();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;li&gt;&#123;ret1&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">      &lt;li&gt;&#123;ret2&#125;&lt;/</span>li&gt;</span><br><span class="line">    &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br></pre></td></tr></table></figure><p>这个 <code>withAsync</code> 不就是我们第一节说要实现的转换器吗。</p><p><img src="/2019/07/16/React_Suspense与Hooks的另类实现/async_withAsync.png" alt=""></p><blockquote><p>上面的例子你可以在 <a href="https://codesandbox.io/s/xp536m876w" target="_blank" rel="noopener">CodeSandbox</a> 上查看。</p></blockquote><h2 id="竞态优化"><a href="#竞态优化" class="headerlink" title="竞态优化"></a>竞态优化</h2><p>假如我们写了多个函数组件，就像下面这样：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> task1 = <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">  wrapTask(<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">"task1"</span>), <span class="number">1000</span>)));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> task2 = <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">  wrapTask(<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">"task2"</span>), <span class="number">2000</span>)));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> task3 = <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">  wrapTask(<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">"task3"</span>), <span class="number">4000</span>)));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> task4 = <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">  wrapTask(<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">"task4"</span>), <span class="number">5000</span>)));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App1 = withAsync(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> ret1 = task1();</span><br><span class="line">  <span class="keyword">const</span> ret2 = task2();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;li&gt;&#123;ret1&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">      &lt;li&gt;&#123;ret2&#125;&lt;/</span>li&gt;</span><br><span class="line">    &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const App2 = withAsync(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  const ret3 = task3();</span></span><br><span class="line"><span class="regexp">  const ret4 = task4();</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">      &lt;li&gt;&#123;ret3&#125;&lt;/</span>li&gt;</span><br><span class="line">      &lt;li&gt;&#123;ret4&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/u</span>l&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;App1 /&gt;</span><br><span class="line">    &lt;p&gt;-------------<span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">    &lt;App2 /&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;,</span></span><br><span class="line"><span class="regexp">  document.querySelector("#app")</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><p>预期的输出你希望是：</p><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">task1</span><br><span class="line">task2</span><br><span class="line">-------------</span><br><span class="line">task3</span><br><span class="line">task4</span><br></pre></td></tr></table></figure><p>事与愿违，实际的输出可能是：</p><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">task1</span><br><span class="line">task2</span><br><span class="line">-------------</span><br><span class="line">task1</span><br><span class="line">task2</span><br></pre></td></tr></table></figure><p>我们来分析下执行流程：</p><ul><li>从头执行 <code>&lt;App1 /&gt;</code>，执行 task1，发现 cache 中没有 task1 的结果，throw task1</li><li>从头执行 <code>&lt;App2 /&gt;</code>，执行 task3，发现 cache 中没有 task3 的结果，throw task3</li><li>task 1 resolved，刷新缓存 <code>[&#39;task1&#39;]</code>，从头执行 <code>&lt;App1 /&gt;</code></li><li>从缓存中获得 <code>&#39;task1&#39;</code> 赋值给 <code>ret1</code>，pos + 1，throw task2</li><li>task 2 resolved，刷新缓存为 <code>[&#39;task1&#39;, &#39;task2&#39;]</code>，从头执行 <code>&lt;App1 /&gt;</code></li><li>赋值 <code>ret1</code>、<code>ret2</code>，并输出 <code>task1</code> 与 <code>task2</code>，此时 pos === 2</li><li>task 3 resovled，刷新缓存为 <code>[&#39;task1&#39;, &#39;task2&#39;, &#39;task3&#39;]</code>，从头执行 <code>&lt;App2 /&gt;</code></li><li>因为 pos 被重置为 0，所以取出 <code>task1</code> 赋值给 <code>ret3</code></li><li>同理，<code>ret4</code> 将被赋值为 <code>task2</code>。最终，你看到了不符合预期的输出</li></ul><blockquote><p>这个错误的例子你可以访问 <a href="https://codesandbox.io/s/suspense-async-component-bug-umi36" target="_blank" rel="noopener">这里</a> 查看：</p></blockquote><p>分析至此，你不难看出问题所在，在原始的设计中，我们并没有考虑 <strong> 竞态处理 </strong>，共享变量 <code>pos</code> 和 <code>cache</code> 在各个任务间没有得到保护。</p><p>为此，我们考虑：</p><ul><li>为每个流程设置其私有的 <code>pos</code> 和 <code>cache</code> 上下文</li><li>每次运行流程时，绑定当前上下文到当前流程的上下文</li><li>每次执行完流程时，释放对外部上下文的绑定</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当前的流程上下文</span></span><br><span class="line"><span class="keyword">let</span> context = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> wrapTask = <span class="function"><span class="params">task</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 每次运行 task，如果 task 已经被缓存，则返回</span></span><br><span class="line">  <span class="comment">// 并更新</span></span><br><span class="line">  <span class="keyword">if</span> (context.cache[context.pos]) &#123;</span><br><span class="line">    <span class="keyword">return</span> context.cache[context.pos++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> task;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> process =&gt; &#123;</span><br><span class="line">  <span class="comment">// 为每个流程设置自己的上下文</span></span><br><span class="line">  <span class="keyword">const</span> ctx = &#123;</span><br><span class="line">    cache: [],</span><br><span class="line">    pos: <span class="number">0</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> step();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 每次流程执行，重置当前步骤到开头</span></span><br><span class="line">    ctx.pos = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 缓存当前上下文，执行完成后恢复</span></span><br><span class="line">    <span class="keyword">const</span> cachedContext = context;</span><br><span class="line">    <span class="comment">// 将上下文绑定到当前的流程的上下文</span></span><br><span class="line">    context = ctx;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> process();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (task) &#123;</span><br><span class="line">      <span class="comment">// 记录任务进入暂态时的位置，便于后面知道刷新哪个位置的缓存</span></span><br><span class="line">      <span class="keyword">const</span> pos = ctx.pos;</span><br><span class="line">      <span class="keyword">return</span> task.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 缓存当前执行结果</span></span><br><span class="line">        ctx.cache[pos] = value;</span><br><span class="line">        <span class="comment">// 重启流程</span></span><br><span class="line">        <span class="keyword">return</span> step();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 每次执行完，释放对上下文的掌控</span></span><br><span class="line">      context = cachedContext;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>基于新的实现，上例中的两个流程 <code>&lt;App1 /&gt;</code> 及 <code>&lt;App2 /&gt;</code>，每次运行时，都使用各自的上下文来刷新和读取缓存。如果对这个实现不太看得懂，读者不妨自己手写下新的执行流程就一目了然了。</p><blockquote><p>这个新的实现和用例，你可以访问 <a href="https://codesandbox.io/s/suspense-async-component-opt-pv87n" target="_blank" rel="noopener">这里</a> 查看</p></blockquote><h2 id="Hook-useState"><a href="#Hook-useState" class="headerlink" title="Hook: useState"></a>Hook: useState</h2><p>上面，我们实现了 <strong> 函数式异步组件 </strong>，我们再来看看 <code>useState</code> 这个 Hook，先回顾下它的用法：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Counter = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;&#123;count&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;+&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure><p>可以看到，<code>useState</code> 为函数式组件带了状态治理的能力。假定我们要自己实现 <code>useState</code> hook，你会怎么思考？最简单地，可以这么思考：</p><blockquote><p>每次 <code>setState</code> 后，重新运行函数，获得最新状态，并用新的状态渲染组件。</p></blockquote><p>是不是又回到了我们实现 Suspense 是要面对的问题：<strong> 反复执行流程，刷新当前结果 </strong>。那么我们不妨试试用同样的手段来实现 <code>useState</code> hook：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> useState = <span class="function"><span class="params">initial</span> =&gt;</span></span><br><span class="line">  wrapTask(</span><br><span class="line">    <span class="built_in">Promise</span>.resolve([</span><br><span class="line">      initial,</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">setState</span>(<span class="params">newState</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 如何重启流程？</span></span><br><span class="line">      &#125;</span><br><span class="line">    ])</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> process = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [count2, setCount2] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;count&#125;</span> - <span class="subst">$&#123;count2&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (count &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    setCount(count + <span class="number">1</span>);</span><br><span class="line">    setCount(count + <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">run(process());</span><br></pre></td></tr></table></figure><p>但是遗憾的是，在 <code>setState</code> 函数中，我们没有办法重启流程。这是因为：基于 Promise 封装的任务，重启流程的时机是 <strong> 任务完成（即 Promise 被 resolved）</strong>，一个 <strong> 异步 </strong> 过程，而 <code>useState</code> 的重启时机，是我们调用了 <code>setState</code> 函数之后，这是一个 <strong> 同步 </strong> 过程。因此，我们不能使用上面的 runner 来实现 <code>useState</code> Hook。</p><p>那该怎么做呢？考虑到我们此时需要调度的任务是一个同步过程，即每次它执行完成后，就要执行下一步动作，那么任务就可以定义为：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Task = <span class="function">(<span class="params">callback: (<span class="params">value: <span class="built_in">any</span></span>) =&gt; <span class="built_in">void</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure><p>即任务接受一个 callback 作为参数，当任务完成时，callback 会被调用，去重启流程。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> run = <span class="function"><span class="params">process</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 每次运行 task，如果 task 已经被缓存，则返回</span></span><br><span class="line">  <span class="comment">// 并更新</span></span><br><span class="line">  <span class="keyword">if</span> (context.cache[context.pos]) &#123;</span><br><span class="line">    <span class="keyword">return</span> context.cache[context.pos++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> task;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> process =&gt; &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> process();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (task) &#123;</span><br><span class="line">      <span class="comment">// 记录任务进入暂态时的位置，便于后面知道刷新哪个位置的缓存</span></span><br><span class="line">      <span class="keyword">const</span> pos = ctx.pos;</span><br><span class="line">      <span class="keyword">return</span> task(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 缓存当前执行结果</span></span><br><span class="line">        ctx.cache[pos] = value;</span><br><span class="line">        <span class="comment">// 重启流程</span></span><br><span class="line">        <span class="keyword">return</span> step();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 每次执行完，释放对上下文的掌控</span></span><br><span class="line">      context = cachedContext;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>则 <code>useState</code> 就可以改造为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> useState = <span class="function"><span class="params">initial</span> =&gt;</span></span><br><span class="line">  <span class="comment">// 此时我们 wrap 的 task 就为接收一个 callback 作为参数的函数</span></span><br><span class="line">  wrapTask(<span class="function"><span class="params">callback</span> =&gt;</span></span><br><span class="line">    callback([</span><br><span class="line">      initial,</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">setState</span>(<span class="params">newState</span>) </span>&#123;</span><br><span class="line">        callback([newState, setState]);</span><br><span class="line">      &#125;</span><br><span class="line">    ])</span><br><span class="line">  );</span><br></pre></td></tr></table></figure><p>这部分完整实现和例子你可以访问 <a href="https://codesandbox.io/s/nnkxz64r8j" target="_blank" rel="noopener">这里</a> 查看。</p><h2 id="了不起的-Monad"><a href="#了不起的-Monad" class="headerlink" title="了不起的 Monad"></a>了不起的 Monad</h2><p>读者可能看到了，上面我们对 React Suspense 及 <code>useState</code> hook 的实现，逻辑和代码都是非常类似的。无论我们使用 Promise 还是 callback，目的都是在于 <strong> 重启流程，以调度后续任务 </strong>，他们只是在 catch 块中重启流程的方式不同，以及任务类型的不同。</p><p>如果我们能将 Promise 和 callback 任务 <strong> 包裹（wrap）或者说提升（lift）到同一数据类型 </strong>，就能泛化出通用的 runner 了，比如像下面这样：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">task.next(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  cache[pos] = value;</span><br><span class="line">  <span class="keyword">return</span> step();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在函数式编程中，<a href="https://www.wikiwand.com/en/Monad_(functional_programming" target="_blank" rel="noopener">Monad</a>&gt;) 便能完成这个任务。关于 Monad 在这里就不做更深入的探讨了，本文介绍的是使用 Monad 去在 JavaScript 解决实际问题，而非深入浅出 Haskell 或者范畴论（笔者也远远不具备这个能力）。</p><p><img src="/2019/07/16/React_Suspense与Hooks的另类实现/lift_monad.png" alt=""></p><p>现在，对 Monad，你只需要知道：</p><blockquote><p>对不同类型的值包裹成为 monadic value，以满足使用相同数据结构（类型）进行流程编排</p></blockquote><p>通常，Monad 需要具备下面两个方法：</p><ul><li><code>of(value)</code>: 能将任意数据类型的 <code>value</code> 包裹成一个 monadic value</li><li><code>chain(monad, f)</code>: 接受一个 monadic value，该方法能被 Monad 包裹的值，并通过 <code>f</code> 将其转换为另一个 monadic value。</li></ul><blockquote><p><strong>chain</strong> 在语义上表述了 monadic value 之间的转换串联，由于其内部能够解除值的包裹，有展开铺平的意味，因此也会被写作 <code>flatMap</code>。</p></blockquote><p>现在，为了将 Promise 和 callback 提升为 Monad，就需要实现 <code>of</code> 和 <code>chain</code> 方法，即确定如何将它们提升为 Monad，又如何串联它们形成的任务：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> createRunner = <span class="function">(<span class="params">&#123; <span class="keyword">of</span>, chain &#125;</span>) =&gt;</span> process =&gt; &#123;</span><br><span class="line">  <span class="comment">// 在 runner 实现内部，我们不再关心流程是 Promise 还是 callback，</span></span><br><span class="line">  <span class="comment">// 它们都能够视作 monad 进行处理</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">of</span>(process());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (task) &#123;</span><br><span class="line">      <span class="comment">// 记录任务进入暂态时的位置，便于后面知道刷新哪个位置的缓存</span></span><br><span class="line">      <span class="keyword">const</span> pos = ctx.pos;</span><br><span class="line">      <span class="keyword">return</span> chain(task, value =&gt; &#123;</span><br><span class="line">        <span class="comment">// 缓存当前执行结果</span></span><br><span class="line">        ctx.cache[pos] = value;</span><br><span class="line">        <span class="comment">// 重启流程</span></span><br><span class="line">        <span class="keyword">return</span> step();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 每次执行完，释放对上下文的掌控</span></span><br><span class="line">      context = cachedContext;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promiseRunner = createRunner(&#123;</span><br><span class="line">  <span class="keyword">of</span>: <span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">Promise</span>.resolve(v),</span><br><span class="line">  chain: <span class="function">(<span class="params">m, f</span>) =&gt;</span> m.then(f)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> callbackRunner = createRunner(&#123;</span><br><span class="line">  <span class="keyword">of</span>: <span class="function"><span class="params">v</span> =&gt;</span> callback =&gt; callback(v),</span><br><span class="line">  chain: <span class="function">(<span class="params">m, f</span>) =&gt;</span> callback =&gt; m(<span class="function"><span class="params">value</span> =&gt;</span> f(value)(callback))</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>关于 callback 的 <code>chain</code> 方法的推导，可以看这篇文章：<a href="https://itnext.io/promises-continuation-monad-in-javascript-f2d70ceb24a4" target="_blank" rel="noopener">https://itnext.io/promises-continuation-monad-in-javascript-f2d70ceb24a4</a></p></blockquote><p>现在，通过 <a href="https://codesandbox.io/s/monadrunner-uvljx" target="_blank" rel="noopener">CodeSandbox</a> 上的例子，你可以看到，我们的 Suspense 及 useState 都是基于同一 runner 进行实现。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://medium.freecodecamp.org/when-to-use-react-suspense-vs-react-hooks-f66ef94cb54f" target="_blank" rel="noopener">When to use React Suspense vs React Hooks</a></li><li><a href="https://curiosity-driven.org/monads-in-javascript" target="_blank" rel="noopener">Monads in JavaScript</a></li><li><a href="https://itnext.io/promises-continuation-monad-in-javascript-f2d70ceb24a4" target="_blank" rel="noopener">Promises &amp; Continuation Monad in JavaScript</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2019/07/16/React_Suspense与Hooks的另类实现/cover.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="React" scheme="http://yoyoyohamapi.me/categories/React/"/>
    
    
      <category term="函数式编程" scheme="http://yoyoyohamapi.me/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="React" scheme="http://yoyoyohamapi.me/tags/React/"/>
    
      <category term="Hooks" scheme="http://yoyoyohamapi.me/tags/Hooks/"/>
    
  </entry>
  
  <entry>
    <title>使用 Hooks 创建异步组件</title>
    <link href="http://yoyoyohamapi.me/2019/04/08/%E4%BD%BF%E7%94%A8_Hooks_%E5%88%9B%E5%BB%BA%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6/"/>
    <id>http://yoyoyohamapi.me/2019/04/08/使用_Hooks_创建异步组件/</id>
    <published>2019-04-08T14:17:00.000Z</published>
    <updated>2019-04-08T14:20:53.313Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/04/08/使用_Hooks_创建异步组件/cover.png" alt=""></p><a id="more"></a><h2 id="基于-Class-的思维方式"><a href="#基于-Class-的思维方式" class="headerlink" title="基于 Class 的思维方式"></a>基于 Class 的思维方式</h2><p>在 Hooks 之前，如果需要在组件中执行异步任务，例如数据的增删改查，我们只能使用 class 组件，这是因为，一方面，我们需要 <strong> 状态 </strong> 来存储任务的加载状况、错误以及数据，另一方面，我们也需要 <strong> 生命周期 </strong> 来调度任务：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">List</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    loading: <span class="literal">false</span>,</span><br><span class="line">    error: <span class="literal">null</span>,</span><br><span class="line">    data: [],</span><br><span class="line">    page: <span class="number">1</span>,</span><br><span class="line">    pageSize: <span class="number">10</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    fetch()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  componentDidUpdate(prevProps, prevState) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; page, pageSize &#125; = <span class="keyword">this</span>.state</span><br><span class="line">    <span class="keyword">if</span> (prevState.page != page || prevState.pageSize != pageSize) &#123;</span><br><span class="line">      fetch()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  handlePaginationChange = <span class="function">(<span class="params">page, pageSize</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      page,</span><br><span class="line">      pageSize</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  fetch = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 设置加载态，重置错误 </span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      loading: <span class="literal">true</span>,</span><br><span class="line">      error: <span class="literal">null</span></span><br><span class="line">    &#125;)</span><br><span class="line">  </span><br><span class="line">    API.fetchList(&#123;</span><br><span class="line">      page: <span class="keyword">this</span>.state.page,</span><br><span class="line">      pageSize: <span class="keyword">this</span>.state.pageSize</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        loading: <span class="literal">false</span>,</span><br><span class="line">        data</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        loading: <span class="literal">false</span>,</span><br><span class="line">        error,</span><br><span class="line">        data: []</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; page, pageSize, loading, data, error &#125; = <span class="keyword">this</span>.state</span><br><span class="line">    <span class="keyword">return</span> error </span><br><span class="line">      ? <span class="xml"><span class="tag">&lt;<span class="name">Error</span> <span class="attr">error</span>=<span class="string">&#123;error&#125;</span>&gt;</span> </span></span><br><span class="line"><span class="xml">      : (</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;&gt;</span></span></span><br><span class="line">          &lt;Table</span><br><span class="line">            data=&#123;this.state.data&#125;</span><br><span class="line">            loading=&#123;loading&#125;</span><br><span class="line">          /&gt;</span><br><span class="line">          &lt;Pagination </span><br><span class="line">            page=&#123;page&#125; </span><br><span class="line">            pageSize=&#123;pageSize&#125; </span><br><span class="line">            onChange=&#123;this.handlePaginationChange&#125;</span><br><span class="line">          /&gt;</span><br><span class="line">        &lt;/&gt;</span><br><span class="line">      )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例的列表组件为我们展示了，基于 Class 创建一个异步组件，我们需要：</p><ol><li>创建并维护异步服务所需要的 <strong> 状态 </strong>：loading, error 与 data</li><li>在组件生命期中，调用 <strong> 异步任务 </strong>，还需要留意任务的调用 <strong> 粒度控制 </strong>（如上例中 <code>componentDidUpdate</code> 中的 if 分支）</li></ol><h2 id="基于-Hook-的思维方式"><a href="#基于-Hook-的思维方式" class="headerlink" title="基于 Hook 的思维方式"></a>基于 Hook 的思维方式</h2><p>我们知道，当 React 推出了 Hooks 后，为原本单薄的函数组件带来了：</p><ul><li><strong> 状态管理 </strong>：通过 <code>useState</code> hook</li><li><strong> 副作用治理 </strong>：通过 <code>useEffect</code> hook</li></ul><p>这两个能力能够让函数组件像类组件一样，创建异步任务，维护对应的数据状态：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> List = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [loading, setLoading] = useState(<span class="literal">false</span>)</span><br><span class="line">  <span class="keyword">const</span> [error, setError] = useState(<span class="literal">null</span>)</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = useState(<span class="literal">null</span>)</span><br><span class="line">  <span class="keyword">const</span> [page, setPage] = useState(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">const</span> [pageSize, setPageSize] = uesState(<span class="number">10</span>)</span><br><span class="line">  </span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setLoading(<span class="literal">true</span>)</span><br><span class="line">    setError(<span class="literal">null</span>)</span><br><span class="line">    API.fetchList(&#123;</span><br><span class="line">      page,</span><br><span class="line">      pageSize</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">      setLoading(<span class="literal">false</span>)</span><br><span class="line">      setData(data)</span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">      setLoading(<span class="literal">false</span>)</span><br><span class="line">      setError(error)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, [page, pageSize])</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> handlePaginationChange = useCallback(<span class="function">(<span class="params">page, pageSize</span>) =&gt;</span> &#123;</span><br><span class="line">    setPage(page)</span><br><span class="line">    setPageSize(pageSize)</span><br><span class="line">  &#125;, [])</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> error </span><br><span class="line">    ? <span class="xml"><span class="tag">&lt;<span class="name">Error</span> <span class="attr">error</span>=<span class="string">&#123;error&#125;</span>&gt;</span> </span></span><br><span class="line"><span class="xml">    : (</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;&gt;</span></span></span><br><span class="line">          &lt;Table</span><br><span class="line">            data=&#123;data&#125;</span><br><span class="line">            loading=&#123;loading&#125;</span><br><span class="line">          /&gt;</span><br><span class="line">          &lt;Pagination </span><br><span class="line">            page=&#123;page&#125; </span><br><span class="line">            pageSize=&#123;pageSize&#125; </span><br><span class="line">            onChange=&#123;handlePaginationChange&#125;</span><br><span class="line">          /&gt;</span><br><span class="line">        &lt;/&gt;</span><br><span class="line">      )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 hooks 与函数组件来创建异步组件时，我们的关注的是：</p><ul><li><strong> 异步副作用是什么 </strong>：即 <code>useEffect</code> 的第一个参数</li><li><strong> 异步副作用的依赖是什么 </strong>，即 <code>useEffect</code> 的第二个参数</li></ul><blockquote><p>上例中，异步副作用即 <code>API.fetchList</code>，这个副作用依赖了两个参数：<code>page</code> 及 <code>pageSize</code>。</p></blockquote><p>乍看之下，貌似我们仍在用 “状态 + 副作用” 的方式编排异步组件，但现在：</p><ul><li>我们不用再关注各个 <strong> 生命期 </strong>：一个 <code>useEffect</code> 足够</li><li>我们不用再 <strong> 命令式地 </strong> 调度任务：只需要声明任务的依赖，当依赖变动时，任务能被自动调度</li></ul><p>这样我们能够用 React 进一步的实践 <a href="https://www.wikiwand.com/en/Functional_reactive_programming" target="_blank" rel="noopener">函数响应式编程（FRP）</a>。类似的模式并不新鲜，几年前 <a href="https://cycle.js.org/" target="_blank" rel="noopener">Cycle.js</a> 就已经这么做了：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;run&#125; <span class="keyword">from</span> <span class="string">'@cycle/run'</span></span><br><span class="line"><span class="keyword">import</span> &#123;div, label, input, hr, h1, makeDOMDriver&#125; <span class="keyword">from</span> <span class="string">'@cycle/dom'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params">sources</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> input$ = sources.DOM.select(<span class="string">'.field'</span>).events(<span class="string">'input'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> name$ = input$.map(<span class="function"><span class="params">ev</span> =&gt;</span> ev.target.value).startWith(<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> vdom$ = name$.map(<span class="function"><span class="params">name</span> =&gt;</span></span><br><span class="line">    div([</span><br><span class="line">      label(<span class="string">'Name:'</span>),</span><br><span class="line">      input(<span class="string">'.field'</span>, &#123;<span class="attr">attrs</span>: &#123;<span class="attr">type</span>: <span class="string">'text'</span>&#125;&#125;),</span><br><span class="line">      hr(),</span><br><span class="line">      h1(<span class="string">'Hello '</span> + name),</span><br><span class="line">    ])</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">DOM</span>: vdom$ &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(main, &#123; <span class="attr">DOM</span>: makeDOMDriver(<span class="string">'#app-container'</span>) &#125;)</span><br></pre></td></tr></table></figure><p>不同的是，Cycle.js 偏爱 Hyperscript，React 则是 JSX，也没有使用 FRP 框架或者 Observable（RxJS 或者 xstream）去组织依赖。</p><h3 id="useService：响应式服务调度"><a href="#useService：响应式服务调度" class="headerlink" title="useService：响应式服务调度"></a><code>useService</code>：响应式服务调度</h3><p>上文中，使用了 hooks 和函数组件来创建异步组件，相较于基于 class 创建的异步组件，<code>useEffect</code> 砍掉了生命期，也砍掉了生命期内的命令式地调度粒度控制，代码着实精简不少。但是这还不够，我们仍能观察到一些样板代码：</p><ul><li>服务状态的创建及维护：loading、error 与 data</li><li>服务调用粒度的控制：当参数变动时，服务就该被调度，但现在，我们仍在 <code>useEffect</code> 中显式地声明它们</li></ul><p>在继续精简代码之前，我们还需要明确一点：Hooks 的到来，并不只是为函数组件带来了状态管理及副作用治理的能力，我们使用 Hooks，也不只是去重复 class 组件能做的事儿。它的到来，更带来了独立于 HOC 和 render props 之外的是新的逻辑复用方式，我们可以将其归纳为：</p><p><img src="/2019/04/08/使用_Hooks_创建异步组件/hook.png" alt="hook.png"> </p><p>即，配置了一个 Hook 之后，若声明了依赖，则每当依赖变动，将获得新的数据。基于此，我们就可以概括出异步任务的对应的 Hook：</p><p><img src="/2019/04/08/使用_Hooks_创建异步组件/useService.png" alt="useService.png"> </p><p>即，我们定义了异步任务，并声明其依赖为请求参数，那么，<code>useService</code> hook 将为我们返回任务的加载状况、报错以及数据，另外，当任意接口参数变动时，服务也会被自动调度。</p><p>现在，在组件中，一个 hook 就能搞定异步任务：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> List = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [page, setPage] = useState(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">const</span> [pageSize, setPageSize] = uesState(<span class="number">10</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> &#123; loading, error, response &#125; = useService(API.fetchList, &#123;page, pageSize&#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> handlePaginationChange = useCallback(<span class="function">(<span class="params">page, pageSize</span>) =&gt;</span> &#123;</span><br><span class="line">    setPage(page)</span><br><span class="line">    setPageSize(pageSize)</span><br><span class="line">  &#125;, [])</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> error </span><br><span class="line">    ? <span class="xml"><span class="tag">&lt;<span class="name">Error</span> <span class="attr">error</span>=<span class="string">&#123;error&#125;</span> /&gt;</span> </span></span><br><span class="line"><span class="xml">    : (</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;&gt;</span></span></span><br><span class="line">          &lt;Table</span><br><span class="line">            data=&#123;this.state.data&#125;</span><br><span class="line">            loading=&#123;loading&#125;</span><br><span class="line">          /&gt;</span><br><span class="line">          &lt;Pagination </span><br><span class="line">            page=&#123;page&#125; </span><br><span class="line">            pageSize=&#123;pageSize&#125; </span><br><span class="line">            onChange=&#123;handlePaginationChange&#125;</span><br><span class="line">          /&gt;</span><br><span class="line">        &lt;/&gt;</span><br><span class="line">      )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>useService</code> 的实现大致如下，要留意的是，在此实现中，我们对先后两次的参数进行了 <strong> 深度比较 </strong>，保证只有在参数变动时，请求才会被发出：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; isEqual &#125; <span class="keyword">from</span> <span class="string">'lodash'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useService</span>(<span class="params">service, params</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> prevParams = useRef(<span class="literal">null</span>)</span><br><span class="line">  <span class="keyword">const</span> [loading, setLoading] = useState(<span class="literal">false</span>)</span><br><span class="line">  <span class="keyword">const</span> [error, setError] = useState(<span class="literal">null</span>)</span><br><span class="line">  <span class="keyword">const</span> [response, setResponse] = useState(<span class="literal">null</span>)</span><br><span class="line">  </span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isEqual(prevParams.current, params)) &#123;</span><br><span class="line">      prevParams.current = params</span><br><span class="line">      setLoading(<span class="literal">true</span>)</span><br><span class="line">      setError(<span class="literal">null</span>)</span><br><span class="line">      service(params)</span><br><span class="line">      .then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        setLoading(<span class="literal">false</span>)</span><br><span class="line">        setResponse(response)</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        setLoading(<span class="literal">false</span>)</span><br><span class="line">        setError(error)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> &#123; loading, error, response &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子你可以在 <a href="https://codesandbox.io/s/38666polx1" target="_blank" rel="noopener">CodeSandbox</a> 查看，尝试切换页码，或者页面大小，你能看到请求被发出，而切换表格尺寸时，因为参数没有发生变化，请求将不会发出，即 effect 不会被执行。</p><p>诚然，我们也可以使用 HOC 或者 render props 实现上面的复用，比如下面展示的这样，但它们在层次上容易形成组件嵌套，不如 Hooks + 函数组件那样简洁直接：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">List</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; page, pageSize &#125; = <span class="keyword">this</span>.state</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Service params=&#123;&#123;page, pageSize&#125;&#125; service=&#123;fetchList&#125;&gt;</span><br><span class="line">      &#123;(&#123;loading, error, response&#125;) =&gt; error </span><br><span class="line">        ? <span class="xml"><span class="tag">&lt;<span class="name">Error</span> <span class="attr">error</span>=<span class="string">&#123;error&#125;</span> /&gt;</span> </span></span><br><span class="line"><span class="xml">        : (</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;&gt;</span></span></span><br><span class="line">              &lt;Table</span><br><span class="line">                data=&#123;response&#125;</span><br><span class="line">                loading=&#123;loading&#125;</span><br><span class="line">              /&gt;</span><br><span class="line">              &lt;Pagination </span><br><span class="line">                page=&#123;page&#125; </span><br><span class="line">                pageSize=&#123;pageSize&#125; </span><br><span class="line">                onChange=&#123;this.handlePaginationChange&#125;</span><br><span class="line">              /&gt;</span><br><span class="line">            &lt;/&gt;</span><br><span class="line">          )&#125;</span><br><span class="line">      &lt;/Service&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="useServiceCallback：手动服务调度"><a href="#useServiceCallback：手动服务调度" class="headerlink" title="useServiceCallback：手动服务调度"></a><code>useServiceCallback</code>：手动服务调度</h2><p>有些时候，我们也需要手动控制一个服务的调用，例如创建、删除等操作，对于这样的需求，我们可以再封装一个 <code>useServiceCallback</code> hook，除了 loading、error、response，它还能够返回服务调用函数。</p><p>下例中，每当我们在 Auto Complete 组件中键入内容，都手动调用下搜索服务进行搜索：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Search = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [api, &#123; loading, error, response &#125;] = useServiceCallback(search);</span><br><span class="line">  <span class="keyword">const</span> handleSearch = useCallback(</span><br><span class="line">    value =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (value.length) &#123;</span><br><span class="line">        api(&#123;</span><br><span class="line">          text: value</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    [api]</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;AutoComplete</span><br><span class="line">      dataSource=&#123;response || []&#125;</span><br><span class="line">      onSearch=&#123;handleSearch&#125;</span><br><span class="line">      placeholder=<span class="string">"等待输入..."</span></span><br><span class="line">    /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>它的实现你可以在 <a href="https://codesandbox.io/s/q4xj087064" target="_blank" rel="noopener">CodeSandbox</a> 上查看，并且我们还用 <code>useServiceCallback</code> 实现了 <code>useService</code>。</p><h2 id="Bonus：使用-RxJS-丰富异步能力"><a href="#Bonus：使用-RxJS-丰富异步能力" class="headerlink" title="Bonus：使用 RxJS 丰富异步能力"></a>Bonus：使用 RxJS 丰富异步能力</h2><p>在实际项目中，我们对于某个服务，可能还有这些诉求：</p><ul><li><strong> 竞态处理 </strong>：服务响应同时到来时，如何处理它们彼此间的竞争。例如在列表数据获取中，我们希望只响应最后一次的数据。</li><li><strong> 重试 </strong>：某些服务失败时，我们希望能够重试</li><li><strong> 加载延迟 </strong>：我们希望能够超过一定容忍期，再设置加载中，这样能够避免短暂的转菊花带来的闪动问题。</li><li><strong> 粒度控制 </strong>：单位时间周期内，只发送一次请求</li></ul><p>想要让我们的 <code>useService</code> 优雅地实现这些能力，就不得不搬出 RxJS 了，它能让我们 <strong> 声明式地 </strong> 编排异步流程。在  Hooks 推出后，我们也能更加自然的将 RxJS 能力注入到 Hooks 中，实现 RxJS 与 React 组件的解耦。</p><p>如何使用 RxJS 丰富我们 <code>useService</code> 的 hook 能力就不再本文赘述了，对此感兴趣的同学，可以在 <a href="https://codesandbox.io/s/k3jwq5rl3o" target="_blank" rel="noopener">CodeSandbox</a> 上看到实现和范例。现在，我们的 service hook 用起来仍然简单，但是功能更加强大：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> List = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [page, setPage] = useState(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">const</span> [pageSize, setPageSize] = uesState(<span class="number">10</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> &#123; loading, error, response &#125; = useAdvancedService(&#123;</span><br><span class="line">    service: API.fetchList,</span><br><span class="line">    <span class="comment">/** 加载延迟 */</span></span><br><span class="line">    loadingDelay: <span class="number">500</span>,</span><br><span class="line">    <span class="comment">/** 重试次数 */</span></span><br><span class="line">    retry: <span class="number">3</span>,</span><br><span class="line">    <span class="comment">/** 每次重试延迟 */</span></span><br><span class="line">    retryDelay: <span class="number">500</span>,</span><br><span class="line">    <span class="comment">/** 竞态处理策略 */</span></span><br><span class="line">    race: <span class="string">'switch'</span>,</span><br><span class="line">    <span class="comment">/** 成功回调 */</span></span><br><span class="line">    onSuccess: <span class="function">(<span class="params">resp</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Fetch success'</span>, resp)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">/** 失败回调 */</span></span><br><span class="line">    onError: <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">'Fetch error'</span>, error)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> handlePaginationChange = useCallback(<span class="function">(<span class="params">page, pageSize</span>) =&gt;</span> &#123;</span><br><span class="line">    setPage(page)</span><br><span class="line">    setPageSize(pageSize)</span><br><span class="line">  &#125;, [])</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> error </span><br><span class="line">    ? <span class="xml"><span class="tag">&lt;<span class="name">Error</span> <span class="attr">error</span>=<span class="string">&#123;error&#125;</span> /&gt;</span> </span></span><br><span class="line"><span class="xml">    : (</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;&gt;</span></span></span><br><span class="line">          &lt;Table</span><br><span class="line">            data=&#123;this.state.data&#125;</span><br><span class="line">            loading=&#123;loading&#125;</span><br><span class="line">          /&gt;</span><br><span class="line">          &lt;Pagination </span><br><span class="line">            page=&#123;page&#125; </span><br><span class="line">            pageSize=&#123;pageSize&#125; </span><br><span class="line">            onChange=&#123;handlePaginationChange&#125;</span><br><span class="line">          /&gt;</span><br><span class="line">        &lt;/&gt;</span><br><span class="line">      )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当然，当 React 官方的 cache + AsyncComponent 组件 stable 后，我们可能会有更完美的异步组件撰写方式和编排体验，关于 RxJS 与 React Hooks 结合，我也在我的 <a href="https://yoyoyohamapi.gitbooks.io/-rxjs-react-sql/content/" target="_blank" rel="noopener">《使用 RxJS 与 React 实现一个 SQL 编辑器》</a> 进行了深一步的探究，感兴趣的读者可以关注下，目前它在连载中</p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://reactjs.org/docs/hooks-intro.html" target="_blank" rel="noopener">React Hooks</a> </li><li><a href="https://overreacted.io/a-complete-guide-to-useeffect/" target="_blank" rel="noopener">A Complete Guide to useEffect</a></li><li><a href="https://www.learnrxjs.io/operators/creation/interval.html" target="_blank" rel="noopener">learn-rxjs</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2019/04/08/使用_Hooks_创建异步组件/cover.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="React" scheme="http://yoyoyohamapi.me/categories/React/"/>
    
    
      <category term="函数式编程" scheme="http://yoyoyohamapi.me/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="React" scheme="http://yoyoyohamapi.me/tags/React/"/>
    
      <category term="Hooks" scheme="http://yoyoyohamapi.me/tags/Hooks/"/>
    
  </entry>
  
  <entry>
    <title>Cycle.js 状态管理模型</title>
    <link href="http://yoyoyohamapi.me/2018/12/16/Cycle.js_%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoyoyohamapi.me/2018/12/16/Cycle.js_的状态管理模型/</id>
    <published>2018-12-16T15:16:00.000Z</published>
    <updated>2019-04-08T14:01:54.064Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分形（fractal）"><a href="#分形（fractal）" class="headerlink" title="分形（fractal）"></a>分形（fractal）</h2><p>当今前端领域，最流行的状态管理模型毫无疑问是 redux，但遗憾的是，redux 并不是一个分形架构。什么是分形架构：</p><blockquote><p>如果子组件能够以同样的结构，作为一个应用使用，这样的结构就是分形架构。</p></blockquote><a id="more"></a><p>在分形架构下，每个应用都组成为更大的应用使用，而在非分形架构下，应用往往依赖于一个统揽全局的 <strong> 协调器（orchestrators）</strong>，各个组件并不能以同样的结构当做应用使用，而是统一接收这个协调器协调。例如，redux 只是聚焦于状态管理，而不涉及组件的视图实现，无法构成一个完整的应用闭环，因此 redux 不是一个分形架构，在 redux 中，协调器就是全局 <code>Store</code> 。</p><p><img src="https://staltz.com/img/redux-unidir-ui-arch.jpg" alt="Redux diagram"></p><p>我们再看下 redux 灵感来源 —— Elm：</p><p><img src="https://staltz.com/img/mvu-unidir-ui-arch.jpg" alt="Model-View-Update diagram"></p><p>在 Elm 架构下，每个组件都有一个完整的应用闭环：</p><ul><li>一个 Model 类型</li><li>一个 Model 的初始实例</li><li>一个 View 函数</li><li>一个 Action type 以及对应的更新函数</li></ul><p>因此，Elm 就是分形架构的，每个 Elm 组件也是一个 Elm 应用。</p><h2 id="Cycle-js"><a href="#Cycle-js" class="headerlink" title="Cycle.js"></a>Cycle.js</h2><p>分形架构的好处显而易见，就是复用容易，组合方便，Cycle.js 推崇的也是分形架构。其将应用抽象为了一个纯函数 <code>main(sources)</code>，该函数接收一个 <code>sources</code> 参数，用来从外部环境获得诸如 DOM、HTTP 这样的副作用，再输出对应的 <code>sinks</code> 去影响外部环境。</p><p><img src="https://cycle.js.org/img/cycle-nested-frontpage.svg" alt="img"></p><p>基于这种简单而直接的抽象，Cycle.js 容易做到分形，即每个 Cycle.js 应用（每个 <code>main</code> 函数）可以组合为更大的 Cycle.js 应用：</p><p><img src="https://cycle.js.org/img/nested-components.svg" alt="nested components"> 在分形体系下，通过 <code>run</code> API，能驱动任何 Cycle.js 应用运行，无论它是一个简单的 Cycle.js 应用，还是一个嵌套复合的 Cycle.js 应用。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;run&#125; <span class="keyword">from</span> <span class="string">'@cycle/run'</span></span><br><span class="line"><span class="keyword">import</span> &#123;div, label, input, hr, h1, makeDOMDriver&#125; <span class="keyword">from</span> <span class="string">'@cycle/dom'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params">sources</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> input$ = sources.DOM.select(<span class="string">'.field'</span>).events(<span class="string">'input'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> name$ = input$.map(<span class="function"><span class="params">ev</span> =&gt;</span> ev.target.value).startWith(<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> vdom$ = name$.map(<span class="function"><span class="params">name</span> =&gt;</span></span><br><span class="line">    div([</span><br><span class="line">      label(<span class="string">'Name:'</span>),</span><br><span class="line">      input(<span class="string">'.field'</span>, &#123;<span class="attr">attrs</span>: &#123;<span class="attr">type</span>: <span class="string">'text'</span>&#125;&#125;),</span><br><span class="line">      hr(),</span><br><span class="line">      h1(<span class="string">'Hello '</span> + name),</span><br><span class="line">    ])</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">DOM</span>: vdom$ &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(main, &#123; <span class="attr">DOM</span>: makeDOMDriver(<span class="string">'#app-container'</span>) &#125;)</span><br></pre></td></tr></table></figure><h2 id="Cycle-js-的状态管理"><a href="#Cycle-js-的状态管理" class="headerlink" title="Cycle.js 的状态管理"></a>Cycle.js 的状态管理</h2><h3 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h3><p>上面我们提到，Cycle.js 推崇的是分形应用结构，因此，redux 这样的状态管理器就不是 Cycle.js 愿意使用的，它会让全局只有一个 redux 应用，而不是多个可拆卸的 Cycle.js 分形应用。基于此，若要引入状态管理模型，其设计应当不改变 Cycle.js 应用的基本结构：从外部世界接收 <code>sources</code>，输出 <code>sinks</code> 到外部世界。</p><p>另外，由于 Cycle.js 是一个响应式前端框架，那么状态管理仍然保持是响应式的，即以 stream/observable 为基础。如果你熟悉响应式编程，基于 Elm 的理念，以 RxJs 为例，我们可以很轻松的实现一个状态管理模型：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> action$ = <span class="keyword">new</span> Subject()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> incrReducer$ = action$.pipe(</span><br><span class="line">  filter(<span class="function">(<span class="params">&#123;type&#125;</span>) =&gt;</span> type === <span class="string">'INCR'</span>),</span><br><span class="line">  mapTo(<span class="function"><span class="keyword">function</span> <span class="title">incrReducer</span>(<span class="params">state</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> state + <span class="number">1</span></span><br><span class="line">  &#125;)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> decrReducer$ = action$.pipe(</span><br><span class="line">  filter(<span class="function">(<span class="params">&#123;type&#125;</span>) =&gt;</span> type === <span class="string">'DECR'</span>),</span><br><span class="line">  mapTo(<span class="function"><span class="keyword">function</span> <span class="title">decrReducer</span>(<span class="params">state</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> state - <span class="number">1</span></span><br><span class="line">  &#125;)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reducer$ = merge(incrReducer$, decrReducer$)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> state$ = reducer$.pipe(</span><br><span class="line">  scan(<span class="function">(<span class="params">state, reducer</span>) =&gt;</span> reducer(state), initState),</span><br><span class="line">  startWith(initState),</span><br><span class="line">  shareReplay(<span class="number">1</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>基于上述的前提，Cycle.sj 状态管理模型的基础设计也跃然纸上：</p><ul><li>将状态源 <code>state$</code> 放入 <code>sources</code> 中，输入给 Cycle.js 应用</li><li>Cycle.js 应用则将 <strong>reducer$</strong> 放入 <code>sinks</code> 中，输出到外部世界</li></ul><blockquote><p>参看 <a href="https://github.com/cyclejs/cyclejs/blob/master/state/src/withState.ts" target="_blank" rel="noopener"><code>@cycle/state</code> 的 <code>withState</code> 的源码</a>，其响应式状态管理模型实现亦大致如上。</p></blockquote><p>在实际实现中，Cycle.js 通过 <code>@cycle/state</code> 暴露的 <code>withState</code>  来为 Cycle.js 注入状态管理模型：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;withState&#125; <span class="keyword">from</span> <span class="string">'@cycle/state'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params">sources</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> state$ = sources.state.stream</span><br><span class="line">  <span class="keyword">const</span> vdom$ = state$.map(<span class="function"><span class="params">state</span> =&gt;</span> <span class="comment">/*render virtual DOM*/</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> reducer$ = xs.periodic(<span class="number">1000</span>)</span><br><span class="line">  .mapTo(<span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">prevState</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// return new state</span></span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> sinks = &#123;</span><br><span class="line">    DOM: vdom$,</span><br><span class="line">    state: reducer$</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sinks</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wrappedMain = withState(main)</span><br><span class="line"></span><br><span class="line">run(wrappedMain, drivers)</span><br></pre></td></tr></table></figure><p>在思考了如何让 Cycle.js 引入状态管理模型后仍然保持分形后，我们还要再状态管理模型中解决下面这些问题：</p><ul><li>如何声明应用初始状态</li><li>应用如何读取以及修改某个状态</li></ul><h3 id="初始化状态"><a href="#初始化状态" class="headerlink" title="初始化状态"></a>初始化状态</h3><p>为了遵循响应式，我们可以声明一个 <code>initReducer$</code>，其默认发出一个 <code>initReducer</code>，在这个 reducer 中，直接返回组件的初始状态：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> initReducer$ = xs.of(<span class="function"><span class="keyword">function</span> <span class="title">initReducer</span>(<span class="params">prevState</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">count</span>:<span class="number">0</span> &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reducer$ = xs.merge(initReducer$, someOtherReducer$);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sinks = &#123;</span><br><span class="line">  state: reducer$,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="使用洋葱模型传递状态"><a href="#使用洋葱模型传递状态" class="headerlink" title="使用洋葱模型传递状态"></a>使用洋葱模型传递状态</h3><p>实际项目中，应用总是由多个组件组成，并且组件间还会存在层级关系，因此，还需要思考：</p><ol><li>怎么传递状态到组件</li><li>怎么传递 reducer 到外部</li></ol><p>假定我们的状态树是：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">  visitors: &#123;</span><br><span class="line">    count: <span class="number">300</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假定我们的组件需要 <code>count</code> 状态，就有两种设计思路：</p><p>（1）在组件中直接声明要摘取的状态，如何处理子状态变动：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params">sources</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> count$ = sources.state.visitors.count</span><br><span class="line">  <span class="keyword">const</span> reducer$ = incrAction$.mapTo(<span class="function"><span class="keyword">function</span> <span class="title">incr</span>(<span class="params">prevState</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> prevState + <span class="number">1</span></span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">      visitors: &#123;</span><br><span class="line">        count: reducer$</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）保持组件的纯净，其获得的 <code>state$</code> ，输出的 <code>reducer$</code> 不用考虑当前状态树形态，二者都只相对于组件自己：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params">sources</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> state$ = sources.state</span><br><span class="line">  <span class="keyword">const</span> reducer$ = incrAction$.mapTo(<span class="function"><span class="keyword">function</span> <span class="title">incr</span>(<span class="params">prevState</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> prevState + <span class="number">1</span></span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    state: reducer$</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两种方式各有好处，第一种方式更加灵活，适合层级嵌套较深的场景。第二种则让组件逻辑更加内聚，拥有更高的组件自治能力，在简单场景下可能表现得更加直接。这里我们首先探讨第二种传递状态方式。</p><p>在第二种状态传递方式下，我们要将 <code>count</code> 传递给对应的组件，就需要 <strong> 从外到内 </strong> 逐层的剥开状态，直到拿到组件需要的状态：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">stateA$ <span class="comment">// Emits object `&#123;visitors: &#123;count: 300&#125;&#125;&#125;`</span></span><br><span class="line">stateB$ <span class="comment">// Emits object `&#123;count: 300&#125;`</span></span><br><span class="line">stateC$ <span class="comment">// Emits object `300`</span></span><br></pre></td></tr></table></figure><p>而组件输出 reducer 时，则需要 <strong> 由内到外 </strong> 进行 reduce：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">reducerC$ <span class="comment">// Emits function `count =&gt; count + 1`</span></span><br><span class="line">reducerB$ <span class="comment">// Emits function `visitors =&gt; (&#123;count: reducerC(visitors.count)&#125;)`</span></span><br><span class="line">reducerA$ <span class="comment">// Emits function `appState =&gt; (&#123;visitors: reducerB(appState.visitors)&#125;)`</span></span><br></pre></td></tr></table></figure><p>这形成了一个类似 <strong> 洋葱 </strong>（cycle state 的前身正是 cycle-onionify）的状态管理模型：我们由外部世界开始，层层剥开外衣，拿到状态；在逐层进行 reduce 操作，由内到外进行状态更新：</p><p><img src="https://github.com/staltz/cycle-onionify/raw/master/diagram.png" alt="Diagram"></p><p>具体看一个例子，假定父组件获得如下的状态：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  foo: string,</span><br><span class="line">  bar: number,</span><br><span class="line">  child: &#123;</span><br><span class="line">    count: number,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>child</code> 子状态是其子组件需要的状态，此时，洋葱模型下就要考虑：</p><ul><li>将 <code>child</code> 从状态树中剥离，传递给子组件</li><li>收集子组件输出的 <code>reducer$</code>，合并后继续向外输出</li></ul><p>首先，我们需要使用 <code>@cycle/isolate</code> 隔离子组件，其暴露了一个 <code>isolate(component, scope)</code> 函数，该函数接受两个参数：</p><ul><li><code>component</code>：需要隔离的组件，即一个接受 <code>sources</code> 并返回 <code>sinks</code> 的函数</li><li><code>scope</code>：组件被隔离到的 scope。scope 决定了 DOM，state 等外部环境如何划分其资源到组件</li></ul><p>该函数最终将返回隔离组件输出的 <code>sinks</code>。获得了子组件的 <code>reducer$</code> 之后，还要与父组件的 <code>reducer$</code> 进行合并，继续向外抛出。</p><p>例如下面的代码中，<code>isolate(Child, &#39;child&#39;)(sources)</code> 将 <code>Child</code> 组件隔离到了名为 <code>child</code> 的 scope 下，因此， <code>@cycle/state</code> 能够知道，要从状态树上选出名为 <code>child</code> 的状态子树给 <code>Child</code> 组件。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">sources</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> state$ = sources.state.stream; <span class="comment">// emits &#123; foo, bar, child &#125;</span></span><br><span class="line">  <span class="keyword">const</span> childSinks = isolate(Child, <span class="string">'child'</span>)(sources);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> parentReducer$ = xs.merge(initReducer$, someOtherReducer$);</span><br><span class="line">  <span class="keyword">const</span> childReducer$ = childSinks.state;</span><br><span class="line">  <span class="keyword">const</span> reducer$ = xs.merge(parentReducer$, childReducer$);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    state: reducer$</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，为了保证父组件不存在时，子组件能够独立运行的能力，需要在子组件中进行识别这种场景（<code>prevState === undefined</code>），并返回对应状态：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">sources</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> state$ = sources.state.stream; <span class="comment">// emits &#123; count &#125; </span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> defaultReducer$ = xs.of(<span class="function"><span class="keyword">function</span> <span class="title">defaultReducer</span>(<span class="params">prevState</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> prevState === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: <span class="number">0</span>&#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> prevState</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 这里，reducer 将处理 &#123; count &#125; state</span></span><br><span class="line">  <span class="keyword">const</span> reducer$ = xs.merge(defaultReducer$, someOtherReducer$);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    state: reducer$</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好的习惯是，每个组件我们都声明一个 <code>defaultReducer$</code>，用来照顾其单独使用时的场景，以及存在父组件时的场景。</p><blockquote><p>关于组件隔离的来由，可以参看：<a href="https://cycle.js.org/components.html#components" target="_blank" rel="noopener">Cycle.js Components 一节</a></p></blockquote><h3 id="使用-Lens-机制传递状态"><a href="#使用-Lens-机制传递状态" class="headerlink" title="使用 Lens 机制传递状态"></a>使用 Lens 机制传递状态</h3><p>在洋葱模型中，数据通过父组件传递到子组件，这里父组件仅仅能够从自身的状态树摘取一棵子树给子组件，因此，这个模型在灵活性上受到了一些限制：</p><ul><li><strong> 个数上 </strong>：只能传递一个子状态</li><li><strong> 规模上 </strong>：不能传递整个状态</li><li><strong>I/O 上 </strong>：只能读取，不能修改状态</li></ul><p>如果你有下面的需求，这种模式就难以胜任：</p><ul><li>组件需要多个状态，例如需要获得 <code>state.foo</code> 及 <code>state.status</code></li><li>父子组件需要访问同一部分状态，例如父组件和子组件需要获得 <code>state.foo</code> </li><li>当子组件的状态变动后，需要联动修改状态树，而不只是通过 <code>reducer$</code> 修改其自身状态</li></ul><p>为此，就需要考虑使用上文中我们提到的第一种状态共享方式。我们给到的多少有些粗糙，Cycle.js 则是引入了 lens 机制来处理洋葱模型无法照顾到的这些场景，顾名思义，这能让组件拥有 <strong> 洞察（读取）</strong> 并且 <strong> 更改（写入）</strong> 状态的能力。</p><p>简单来说，lens 通过 getter/setter 定义了对某个数据的读写。</p><p>为了实现这个机制，Cycle.js 让 <code>isolate</code> 在隔离组件实例时，接受组件自定义的 lens 作为 scope selector，以让 <code>@cycle/state</code> 组件要如何读取以及修改状态。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fooLens = &#123;</span><br><span class="line">  get: <span class="function"><span class="params">state</span> =&gt;</span> state.foo,</span><br><span class="line">  set: <span class="function">(<span class="params">state, childState</span>) =&gt;</span> (&#123;...state, <span class="attr">foo</span>: childState&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fooSinks = isolate(Foo, &#123;<span class="attr">state</span>: fooLens&#125;)(sources);</span><br></pre></td></tr></table></figure><p>上面代码中，通过自定义 lens，组件 <code>Foo</code> 能够获得状态树上的 <code>foo</code> 状态，而当 <code>Foo</code> 修改了 <code>foo</code> 后，将联动修改状态树上的 <code>foo</code> 状态。</p><h3 id="处理动态列表"><a href="#处理动态列表" class="headerlink" title="处理动态列表"></a>处理动态列表</h3><p>渲染动态列表是前端最常见的需求之一，在 Cycle.js 引入状态管理之前，这一直是 Cycle.js 做不好的一个点，甚至 André Staltz 还专门开了一篇 <a href="https://github.com/cyclejs/cyclejs/issues/312" target="_blank" rel="noopener">issue</a> 来讨论如何更在 Cycle.js 中更优雅的处理动态列表。</p><p>现在，基于上述的状态管理模型，只需要一个 <code>makeCollection</code> API，即可在 Cycle.js 中，创建一个动态列表：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">sources</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> array$ = sources.state.stream;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> List = makeCollection(&#123;</span><br><span class="line">    item: Child,</span><br><span class="line">    itemKey: <span class="function">(<span class="params">childState, index</span>) =&gt;</span> <span class="built_in">String</span>(index),</span><br><span class="line">    itemScope: <span class="function"><span class="params">key</span> =&gt;</span> key,</span><br><span class="line">    collectSinks: <span class="function"><span class="params">instances</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        state: instances.pickMerge(<span class="string">'state'</span>),</span><br><span class="line">        DOM: instances.pickCombine(<span class="string">'DOM'</span>)</span><br><span class="line">        .map(<span class="function"><span class="params">itemVNodes</span> =&gt;</span> ul(itemVNodes))</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> listSinks = List(sources);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> reducer$ = xs.merge(listSinks.state, parentReducer$);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    state: reducer$</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到上面的代码，基于 <code>@cylce/state</code> 创建一个动态列表，我们需要告诉 <code>@cycle/state</code>：</p><ul><li>列表元素是什么</li><li>每个元素在状态中的位置</li><li><p>每个元素的 scope</p></li><li><p>列表的 <code>reducer$</code>：<code>instances.pickMerge(&#39;state&#39;)</code>，其约等于:</p><ul><li><code>xs.merge(instances.map(sink =&gt; sink.state))</code></li></ul></li><li>列表的 <code>vdom$</code>：<code>instances.pickCombine(&#39;DOM&#39;)</code>，其约等于：<ul><li><code>xs.combine(instances.map(sink =&gt; sink.DOM))</code></li></ul></li></ul><p><strong> 新增列表元素 </strong> 只需要在列表容器的 <code>reducer$</code> 中，为数组新增一个元素即可：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reducer$ = xs.periodic(<span class="number">1000</span>).map(<span class="function"><span class="params">i</span> =&gt;</span> <span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">prevArray</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> prevArray.concat(&#123;<span class="attr">count</span>: i&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong> 删除元素 </strong> 则需要子组件在删除行为触发时，将其状态标识为 <code>undefiend</code>，Cycle.js 内部会据此从列表数组中删除该状态，进而删除子组件及其输出的 sinks：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">sources</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> deleteReducer$ = deleteAction$.mapTo(<span class="function"><span class="keyword">function</span> <span class="title">deleteReducer</span>(<span class="params">prevState</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> reducer$ = xs.merge(deleteReducer$, someOtherReducer$)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    state: reducer$</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Cycle.js 相比较于前端三大框架（Angular/React/Vue）来说，算是小众的不能再小众的框架，学习这样的框架并不是为了 <strong> 标新立异 </strong>，考虑到你的团队，你也很难在大型工程中将它作为支持框架。但是，这不妨碍我们从 Cycle.js 的设计中获得启发和灵感，它多少能让你感受到：</p><ul><li>也许我们的应用就是一个和外部世界打交道的环</li><li>什么是分形</li><li>响应式程序设计的魅力</li><li>什么是 lens 机制？如何在 JavaScript 应用中使用 lens</li><li>…</li></ul><p>另外，Cycle.js 的作者 André Staltz 也是一个颇具个人魅力和表达能力的开发者，推荐你关注他的：</p><ul><li>André Staltz 的博客：<a href="https://staltz.com/" target="_blank" rel="noopener">https://staltz.com/</a></li><li>André Staltz 在 egghead.io 上的 RxJs 和 Cycle.js 教程，你不仅能学到 API，还能学到框架设计思路：<a href="https://egghead.io/instructors/andre-staltz" target="_blank" rel="noopener">https://egghead.io/instructors/andre-staltz</a></li><li>André Staltz 参加并演讲的一系列会议：<a href="https://www.youtube.com/results?search_query=andre+staltz" target="_blank" rel="noopener">https://www.youtube.com/results?search_query=andre+staltz</a></li></ul><p>最后，不要盲目崇拜，只要疯狂学习和探索。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://staltz.com/unidirectional-user-interface-architectures.html" target="_blank" rel="noopener">UNIDIRECTIONAL USER INTERFACE ARCHITECTURES</a></p></li><li><p><a href="https://cycle.js.org/api/state.html" target="_blank" rel="noopener">Cycle State</a></p></li><li><p><a href="https://medium.com/javascript-inside/an-introduction-into-lenses-in-javascript-e494948d1ea5" target="_blank" rel="noopener">An Introduction Into Lenses In JavaScript</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;分形（fractal）&quot;&gt;&lt;a href=&quot;#分形（fractal）&quot; class=&quot;headerlink&quot; title=&quot;分形（fractal）&quot;&gt;&lt;/a&gt;分形（fractal）&lt;/h2&gt;&lt;p&gt;当今前端领域，最流行的状态管理模型毫无疑问是 redux，但遗憾的是，redux 并不是一个分形架构。什么是分形架构：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果子组件能够以同样的结构，作为一个应用使用，这样的结构就是分形架构。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Cycle.js" scheme="http://yoyoyohamapi.me/categories/Cycle-js/"/>
    
    
      <category term="JavaScript" scheme="http://yoyoyohamapi.me/tags/JavaScript/"/>
    
      <category term="函数式编程" scheme="http://yoyoyohamapi.me/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Cycle.js" scheme="http://yoyoyohamapi.me/tags/Cycle-js/"/>
    
  </entry>
  
  <entry>
    <title>更好用的 Redux</title>
    <link href="http://yoyoyohamapi.me/2018/09/04/%E6%9B%B4%E5%A5%BD%E7%94%A8%E7%9A%84_Redux/"/>
    <id>http://yoyoyohamapi.me/2018/09/04/更好用的_Redux/</id>
    <published>2018-09-04T15:15:00.000Z</published>
    <updated>2018-10-14T10:01:00.488Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2018/09/04/更好用的_Redux/cover.png" alt="cover"></p><blockquote><p>本文是 《使用 RxJS + Redux 管理应用状态》系列第三篇文章，将介绍我们在使用 Redux 时的困惑，如何重新思考 Redux 定下的范式，以及我们能为此做出的努力。返回第一篇：<a href="http://yoyoyohamapi.me/2018/08/18/%E4%BD%BF%E7%94%A8_redux-observable_%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6%E8%87%AA%E6%B2%BB/">使用 redux-observable 实现组件自治</a></p><p>本系列的文章地址汇总：</p><ul><li><a href="http://yoyoyohamapi.me/2018/08/18/%E4%BD%BF%E7%94%A8_redux-observable_%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6%E8%87%AA%E6%B2%BB/">使用 redux-observable 实现组件自治</a></li><li><a href="http://yoyoyohamapi.me/2018/08/21/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA_redux-observable/">如何实现一个 redux-observable</a></li><li><a href="http://yoyoyohamapi.me/2018/09/04/%E6%9B%B4%E5%A5%BD%E7%94%A8%E7%9A%84_Redux/">更好用的 Redux</a></li></ul></blockquote><a id="more"></a><h2 id="为什么我们需要-Redux？"><a href="#为什么我们需要-Redux？" class="headerlink" title="为什么我们需要 Redux？"></a>为什么我们需要 Redux？</h2><p>首先要明确的是，Redux 并不是 React 独有的一个插件，它是顺应前端组件化开发潮流而诞生的一种状态管理模型，你在 Vue 或者 Angular 中也可以使用这个模型。</p><p>目前，大家都比较认可的是，某一时刻的应用或者组件状态，将对应此时应用或者组件的 UI：</p><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">UI = f(<span class="keyword">state</span>)</span><br></pre></td></tr></table></figure><p>那么，在前端组件化开发的时候，就需要思考两个问题：</p><ol><li><strong> 状态来源 </strong></li><li><strong> 状态管理 </strong></li></ol><p>组件所具有的状态，一搬来源于两个方面：</p><ol><li><strong> 自身具有的状态 </strong>：例如一个 Button 组件自身含有一个计数状态 count，表示自己被点击的次数。</li><li><strong> 外部注入的状态 </strong>：例如一个 Modal 组件，就需要由外部注入一个是否显示的状态 visible。React 将外部注入的状态称为 <strong>props</strong>。</li></ol><p>状态源为组件输送了其需要的状态，进而，组件的外观形态也得到了确认。在简单工程和简单组件中，我们思考了状态来源也就行了，如果引入额外的状态管理方案（例如我们为一个使用 Redux 管理一个按钮组件的状态），反而会加重每个组件的负担，造成了多余的抽象和依赖。</p><p>而对于 <strong> 大型前端工程 </strong> 和复杂组件来说，其往往具有如下特点：</p><ol><li><strong> 数据复杂 </strong></li><li><strong> 组件丰富 </strong></li></ol><p>在这种场景下，朴素的状态管理就显得捉襟见肘了，主要体现在下面几个方面：</p><ol><li>当组件 <strong> 层级过深 </strong> 时，如何优雅得呈递组件需要的状态，或者说组件如何更方便取得自己需要的状态</li><li>如何 <strong> 回溯 </strong> 到某个状态</li><li>如何更好的 <strong> 测试 </strong> 状态管理</li></ol><p>Redux 正是要去解决这些问题，从而让大型前端工程的状态更加可控。Redux 提出了一套约定模型，让状态的更新和派发都集中了：</p><p><img src="/2018/09/04/更好用的_Redux/redux.png" alt="redux"></p><p>Redux 所使用的模型是受到了 Elm 的启发：</p><p><img src="/2018/09/04/更好用的_Redux/elm.png" alt="Elm 架构"></p><p>在 Elm 中，流动于应用中的是 <strong> 消息（msg）</strong> ：一个由 <strong> 消息类型（type）</strong> 所标识，并且携带了 <strong> 内容（payload）</strong> 的数据结构。消息决定了数据模型（<strong>model</strong>）怎么更新，而数据又决定了 UI 形态。</p><p>而在 Redux 中，消息被称替代为 <strong> 动作（action）</strong>，并且使用 <strong>reducer</strong> 来描述状态随行为的变迁。另外，与 Elm 不同的是，Redux 专注于状态管理，而不再处理视图（View），因此 ，Redux 也不是分型的（关于分型架构的介绍，可以看 的 <a href="https://staltz.com/unidirectional-user-interface-architectures.html" target="_blank" rel="noopener">博文</a>）。</p><p>在了解到 Redux 的利好，或者被 Redux 的流行所吸引后，我们引入 Redux 作为应用的状态管理器，这让整个应用的状态变动都变得无比清晰，状态在一条链路上涌动，我们甚至可以回到或者前进到某个状态。然而，Redux 就真的完美无缺吗？</p><h2 id="不完美的-Redux"><a href="#不完美的-Redux" class="headerlink" title="不完美的 Redux"></a>不完美的 Redux</h2><p>Redux 当然不完美，它最困扰我们的就是下面两个方面：</p><ol><li>啰嗦的样板代码</li><li>低下的异步任务处理能力</li></ol><p>假定前端需要从服务端拉取一些数据并进行展示，在 Redux 的模式下，完成从数据拉取到状态更新，就需要经历：</p><p>（1）定义若干的 <strong>action type</strong>:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> FETCH_START = <span class="string">'FETCH_START'</span></span><br><span class="line"><span class="keyword">const</span> FETCH_SUCCESS = <span class="string">'FETCH_SUCCESSE'</span></span><br><span class="line"><span class="keyword">const</span> FETCH_ERROR = <span class="string">'FETCH_ERROR'</span></span><br></pre></td></tr></table></figure><p>（2）定义若干 <strong>action creator</strong>，这里假定我们使用 redux-thunk 驱动异步任务：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fetchSuccess = <span class="function"><span class="params">data</span> =&gt;</span> (&#123;</span><br><span class="line">  type: FETCH_START,</span><br><span class="line">  payload: &#123; data &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fetchError = <span class="function"><span class="params">error</span> =&gt;</span> (&#123;</span><br><span class="line">  type: FETCH_ERROR,</span><br><span class="line">  payload: &#123; error &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fetchData = <span class="function">(<span class="params">params</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">dispatch, getState</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> api.fetch(params)</span><br><span class="line">      .then(fetchSuccess)</span><br><span class="line">    .catch(fetchError)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）在 <strong>reducer</strong> 中，对不同 action type，通过 switch-case 声明不同的状态更新方式：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state = initialState, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; type, payload &#125; = action</span><br><span class="line">  <span class="keyword">switch</span>(action.type)&#123;</span><br><span class="line">    <span class="keyword">case</span> FETCH_START: &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, <span class="attr">loading</span>: <span class="literal">true</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> FETCH_SUCCESS: &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, <span class="attr">loading</span>: <span class="literal">false</span>, <span class="attr">data</span>: payload.data &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> FETCH_ERROR: &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, <span class="attr">loading</span>: <span class="literal">false</span>, <span class="attr">data</span>: <span class="literal">null</span>, <span class="attr">error</span>: payload.error&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个流程带来的问题是：</p><ol><li><strong> 个人开发不够专注 </strong>：工程中，我们是 <strong> 分散管理 </strong> action type、action 及 reducer 的，走完一套流程，需要在当中不停的跳跃，思路不够集中。</li><li><strong> 多人协作不够高效 </strong>：同样是因为 action type、action 及 reducer 的分散，多人协作时就会出现名字冲突，相似业务的流程重复等问题。这对我们的应用状态设计提出了比较高的要求。优秀的设计是状态易于定位，变迁流程清晰，无冗余状态，而低下的设计就会让状态膨胀难于定位，变迁流程错综复杂，冗余状态随处可见。</li></ol><h2 id="怎么用好-Redux"><a href="#怎么用好-Redux" class="headerlink" title="怎么用好 Redux"></a>怎么用好 Redux</h2><p>当我们受困于 Redux 的负面影响时，切到其他的状态管理方案（例如 <a href="https://github.com/mobxjs/mobx" target="_blank" rel="noopener">mobx</a> 或者 <a href="https://github.com/mobxjs/mobx-state-tree" target="_blank" rel="noopener">mobx-state-stree）</a>，也不太现实，一方面是迁移成本大，一方面你也不知道新的状态管理方案是否就是银弹。但是，对 Redux 的负面影响无动于衷或者忍气吞声，也只会让问题越滚越大，直到失控。</p><p>在开始讨论如何更好地 Redux 之前，我们需要明确一点，样板代码和异步能力的缺乏，<strong> 是 Redux 自身设计的结果，而非目的 </strong>，换句话说，Redux 设计出来，并不是要让开发者去撰写样本代码，或者去纠结怎么处理异步状态更新。</p><p>我们需要再定义一个角色，让他来代替我们去写样板代码，让他给予我们最优秀的异步任务处理能力，让他负责一切 Redux 中恶心的事儿。因此，这个角色就是一个让 Redux 变得更加优雅的框架，至于如何创建这个角色，需要我们从单个组件开始，重新梳理下应用形态，并着眼于：</p><ol><li>如何打掉 Redux 的样板代码</li><li>如何更优雅地处理异步任务</li></ol><h3 id="组件的样子"><a href="#组件的样子" class="headerlink" title="组件的样子"></a>组件的样子</h3><p>一个组件的生态大概是这样的：</p><p><img src="/2018/09/04/更好用的_Redux/component.png" alt=""></p><p>即：<strong> 数据经处理形成页面状态，页面状态决定  UI 渲染 </strong>。</p><h3 id="应用的样子"><a href="#应用的样子" class="headerlink" title="应用的样子"></a>应用的样子</h3><p>而组件生态（UI + 状态 + 状态管理方式）的组合就构成了我们应用：</p><p><img src="/2018/09/04/更好用的_Redux/components.png" alt="生态组合"></p><p>这里组件生态特意只展示了 <strong> 数据到状态 </strong> 这一步，因为 Redux 处理的正是这个部分。我们暂且可以定义数据到状态的过程为 <strong>flow</strong>，即一个业务流的意思。</p><h3 id="应用划分"><a href="#应用划分" class="headerlink" title="应用划分"></a>应用划分</h3><p>借鉴于 Elm，我们可以按数据模型对应用进行划分：</p><p><img src="/2018/09/04/更好用的_Redux/architecture.png" alt="应用划分"></p><p>其中，模型具有的属性有：</p><ul><li><code>name</code>: 模型名称</li><li><code>state</code>：模型的初始状态</li><li><code>reducers</code>：处理当前模型状态的 state</li><li><code>selectors</code>：服务于当前模型的 state selectors</li><li><code>flows</code>：当前模型涉及的业务流（副作用）</li></ul><blockquote><p>这个经典的划分模型正是 <a href="https://github.com/dvajs/dva" target="_blank" rel="noopener">Dva</a> 的应用划分手段，只是模型属性略有不同。</p></blockquote><p>假定我们创建了 user 模型和 post 模型，那么框架将挂载他们的状态到 user 和 post 状态子树下：</p><p><img src="/2018/09/04/更好用的_Redux/model_state_tree.png" alt=""></p><h3 id="约定-——-打掉样板代码"><a href="#约定-——-打掉样板代码" class="headerlink" title="约定 —— 打掉样板代码"></a>约定 —— 打掉样板代码</h3><p>有了模型这个概念后，框架就能定义一系列的约定去减少样板代码的书写。首先，我们回顾下以前我们是怎么定义的一个 action type 的：</p><ul><li>action 名称</li><li>指定一个 namespace 防止名字冲突</li></ul><p>例如，我们这样定义用户数据拉取相关的 action type：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> FETCH = <span class="string">'USRE/FETCH'</span></span><br><span class="line"><span class="keyword">const</span> FETCH_SUCCESS = <span class="string">'USER/FETCH_SUCCESSE'</span></span><br><span class="line"><span class="keyword">const</span> FETCH_ERROR = <span class="string">'USER/FETCH_ERROR'</span></span><br></pre></td></tr></table></figure><p>其中， <code>FETCH</code> 对应的是一个 <strong> 异步 </strong> 拉取数据的 action，<code>FETCH_SUCCESS</code> 和 <code>FETCH_ERROR</code> 则对应两个 <strong> 同步 </strong> 修改状态的 action。</p><p><strong> 同步 action 约定 </strong></p><p>对于同步的、不包含副作用的 action，我们直接将其呈递到 reducer，是不会破坏 reducer 纯度的。 因此，我们不妨约定： model 下 reducer 的 <strong> 名字 </strong> 映射一个直接对状态操作的 action type：</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">SYNC_ACTION_TYPE</span> = MODEL_NAME/REDUCER_NAME</span><br></pre></td></tr></table></figure><p>例如下面这个 user model：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> userModel = &#123;</span><br><span class="line">  name: <span class="string">'user'</span>,</span><br><span class="line">  state: &#123;</span><br><span class="line">    list: [],</span><br><span class="line">    total: <span class="number">0</span>,</span><br><span class="line">    loading: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  reducers: &#123;</span><br><span class="line">    fetchStart(state, payload) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, <span class="attr">loading</span>:<span class="literal">true</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们派发了一个类型为 <code>user/fetchStart</code> 的 action 之后，action 就带着其 payload 进入到 <code>user.fetchStart</code> 这个 reducer 下，进行状态变更。</p><p><strong> 异步 action 约定 </strong></p><p>对于异步的 action，我们就不能直接在 reducer 进行异步任务处理，而 model 中的 flow 就是异步任务的集装箱：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ASYNC_ACTION_TYPE = MODEL_NAME/FLOW_NAME</span><br></pre></td></tr></table></figure><p>例如下面这个 model：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  name: <span class="string">'user'</span>,</span><br><span class="line">  state: &#123;</span><br><span class="line">    list: [],</span><br><span class="line">    total: <span class="number">0</span>,</span><br><span class="line">    loading: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  flows: &#123;</span><br><span class="line">    fetch() &#123;</span><br><span class="line">      <span class="comment">// ... 处理一些异步任务 </span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们在 UI 里面发出了个 <code>user/fetch</code>，由于 user model 中存在一个名为 fetch 的 flow，那么就进入到这个 flow 中进行异步任务的处理。</p><p><strong> 状态的覆盖与更新 </strong></p><p>如果每个状态的更新都去撰写一个对应的 reducer 就太累了，因此，我们可以考虑为每个模型定义一个 change reducer，用于 <strong> 直接 </strong> 更新状态：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> userModel = &#123;</span><br><span class="line">  name: <span class="string">'user'</span>,</span><br><span class="line">  state: &#123;</span><br><span class="line">    list: [],</span><br><span class="line">    pagination: &#123;</span><br><span class="line">      page: <span class="number">1</span>,</span><br><span class="line">      total: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    loading: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  reducers: &#123;</span><br><span class="line">    change(state, action) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, ...action.payload &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，当我们派发了下面的一个 action，就将能够将 <code>loading</code> 状态置为 true：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">dispatch(&#123;</span><br><span class="line">  type: <span class="string">'user/change'</span>,</span><br><span class="line">  payload: &#123;</span><br><span class="line">    loading: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>但是，这种更新是 <strong> 覆盖式 </strong> 的，假定我们想要更新状态中的当前页面信息：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">dispatch(&#123;</span><br><span class="line">  type: <span class="string">'user/change'</span>,</span><br><span class="line">  payload: &#123;</span><br><span class="line">    pagination: &#123; <span class="attr">page</span>: <span class="number">1</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>状态就会变为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  list: [],</span><br><span class="line">  pagination: &#123;</span><br><span class="line">  page: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  loading: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>pagination</code> 状态被整个覆盖掉了，其中的总数状态 <code>total</code> 就丢失了。</p><p>因此，我们还要定义一个 patch reducer，意为对状态的 <strong> 补丁更新 </strong>，它只会影响到 action payload 中声明的子状态：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; merge &#125; <span class="keyword">from</span> <span class="string">'lodash.merge'</span></span><br><span class="line"><span class="keyword">const</span> userModel = &#123;</span><br><span class="line">  name: <span class="string">'user'</span>,</span><br><span class="line">  state: &#123;</span><br><span class="line">    list: [],</span><br><span class="line">    pagination: &#123;</span><br><span class="line">      page: <span class="number">1</span>,</span><br><span class="line">      total: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    loading: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  reducers: &#123;</span><br><span class="line">    change(state, action) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        &#123; ...state, ...action.payload &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    patch(state, action) &#123;</span><br><span class="line">      <span class="keyword">return</span> deepMerge(state, action.payload)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们尝试只更新分页：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">dispatch(&#123;</span><br><span class="line">  type: <span class="string">'user/patch'</span>,</span><br><span class="line">  payload: &#123;</span><br><span class="line">    pagination: &#123; <span class="attr">page</span>: <span class="number">1</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>新的状态就是：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  list: [],</span><br><span class="line">  pagination: &#123;</span><br><span class="line">  page: <span class="number">1</span>,</span><br><span class="line">    total: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  loading: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：这里的实现不是生产环境的实现，直接使用 lodash 的 merge 是不够的，实际项目中还要进行一定改造。</p></blockquote><h3 id="异步任务的组织"><a href="#异步任务的组织" class="headerlink" title="异步任务的组织"></a>异步任务的组织</h3><p>Dva 使用了 redux-saga 进行副作用（主要是异步任务）的组织，Rematch 则使用了 async/await 进行组织。从长期的实践来看，我更偏向于使用 redux-observable，尤其是在其 1.0 版本的发布之后，更是带来了可观察的 <code>state$</code>，使得我们能更加透彻地实践响应式编程。我们回顾下前文中提到的该模式的好处：</p><ul><li>统一数据源，observable 之间可组合</li><li>声明式编程，代码直爽简洁</li><li>优秀的竞态处理能力</li><li>测试友好</li><li>便于实现组件自治</li></ul><p>因此，对于模型异步任务的处理，我们选择 redux-observable：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> user:Model&lt;UserState&gt; = &#123;</span><br><span class="line">  name: <span class="string">'user'</span>,</span><br><span class="line">  state: &#123;</span><br><span class="line">    list: [],</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  reducers: &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  flows: &#123;</span><br><span class="line">    fetch(flow$, action$, state$) &#123;</span><br><span class="line">      <span class="comment">// ....</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与 epic 的函数签名略有不同的是，每个 flow 多了一个 <code>flow$</code> 参数，以上例来说，它就相当于：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">action$.ofType(<span class="string">'user/fetch'</span>)</span><br></pre></td></tr></table></figure><p>这个参数便于我们更快的取到需要的 action。</p><h3 id="处理加载态与错误态"><a href="#处理加载态与错误态" class="headerlink" title="处理加载态与错误态"></a>处理加载态与错误态</h3><p>前端工程中经常会有错误展示和加载展示的需求，</p><p><img src="/2018/09/04/更好用的_Redux/loading&amp;error.png" alt="loading 与 error"></p><p>如果我们手动管理每个模型的加载态和错误态就太麻烦了，因此在根状态下，单独划分两棵状态子树用于处理加载态与错误态，这样，便于框架去治理加载与错误，开发者直接在状态树上取用即可：</p><ul><li>loading </li><li>error</li></ul><p><img src="/2018/09/04/更好用的_Redux/state_tree.png" alt=""></p><p>如图，加载态和错误态还需要根据粒度进行划分，有大粒度的 flow 级别，用于标识一个 flow 是否正在进行中；也有小粒度的 service 级别，用于标识某个异步服务是否在进行中。</p><p>例如，若：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">loading.flows[<span class="string">'user/fetch'</span>] === <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>即表示 user model 下的 <code>fetch</code> flow 正在进行中。</p><p>若：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">loading.services[<span class="string">'/api/fetchUser'</span>] === <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>即表示 <code>/api/fetchUser</code> 这个服务正在进行中。</p><h3 id="响应式的服务治理"><a href="#响应式的服务治理" class="headerlink" title="响应式的服务治理"></a>响应式的服务治理</h3><p>前端调用后端服务操纵数据是一个广泛的需求，因此，我们还希望所谓的中间角色（框架）能够在我们的业务流中注入服务，完成服务和应用状态的交互：观察调用状况，自动捕获调用异常，适时地修改应用 loading 态和 error 态，方便用户直接在顶层状态取用服务运行状况。</p><p>另外，在响应式编程的范式下，框架提供的服务治理，在处理服务的成功和错误时应该也是响应式的，即成功和错误将是预定义的流（observable 对象），从而让开发者能更好的利用到响应式编程的能力：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> user:Model&lt;UserState&gt; = &#123;</span><br><span class="line">  name: <span class="string">'user'</span>,</span><br><span class="line">  state: &#123;</span><br><span class="line">    list: [],</span><br><span class="line">    total: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  reducers: &#123;</span><br><span class="line">    fetchSuccess(state, payload) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, list: payload.list, total: payload.total &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    fetchError(state, payload) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, list:&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  flows: &#123;</span><br><span class="line">    fetch(flow$, action$, state$, dependencies) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; service &#125; = dependencies</span><br><span class="line">      <span class="keyword">return</span> flow$.pipe(</span><br><span class="line">        withLatestFrom(state$, <span class="function">(<span class="params">action, state</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 拼装请求参数 </span></span><br><span class="line">          <span class="keyword">return</span> params</span><br><span class="line">        &#125;),</span><br><span class="line">        switchMap(<span class="function"><span class="params">params</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> [success$, error$] = service(getUsers(params))</span><br><span class="line">          <span class="keyword">return</span> merge(</span><br><span class="line">            success$.pipe(</span><br><span class="line">              map(<span class="function"><span class="params">resp</span> =&gt;</span> (&#123;</span><br><span class="line">                <span class="keyword">type</span>: <span class="string">'user/fetchSuccess'</span>,</span><br><span class="line">                payload: &#123;</span><br><span class="line">                  list: resp.list,</span><br><span class="line">                  total: resp.total</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;))</span><br><span class="line">            ),</span><br><span class="line">            error$.pipe(</span><br><span class="line">              map(<span class="function"><span class="params">error</span> =&gt;</span> (&#123;</span><br><span class="line">              <span class="keyword">type</span>: <span class="string">'user/fetchError'</span></span><br><span class="line">            &#125;))</span><br><span class="line">            )</span><br><span class="line">          )</span><br><span class="line">        &#125;)</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="reobservable"><a href="#reobservable" class="headerlink" title="reobservable"></a>reobservable</h2><p>上面的种种思考，概括下来其实就是 Dva architecture + redux-observable，前者能够打掉 Redux 冗长啰嗦的样板代码，后者则负责异步任务治理。</p><p>比较遗憾的是，Dva 没有使用 redux-observable 进行副作用管理，也没有相关插件实现使用 redux-observable 或者 RxJS 进行副作用管理，并且，通过 Dva 暴露的 hook 去实现一个 redux-observable 的 Dva 中间件也颇为不畅，因此，笔者尝试撰写了一个 <a href="https://github.com/reobservable/reobservable" target="_blank" rel="noopener">reobservable</a> 来实现上面提到框架，它与 Dva 不同的是：</p><ol><li>只关注应用状态，不涉及组件路由的其他生态</li><li>集成 loading 和 error 处理</li><li>使用 redux-observable 而不是 redux-saga 处理副作用</li><li>响应式的服务处理，支持应用自定义服务细节</li></ol><p>如果你的应用使用了 Redux，你苦于 Redux 种种负面影响，并且你还是一个响应式编程和 RxJS 的爱好者，你可以尝试下 reobservable。但是如果你偏爱 saga，或者 async await，你还是应该选择 Dva 或者 Rematch，术业有专攻。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://hackernoon.com/redesigning-redux-b2baee8b8a38" target="_blank" rel="noopener">Redesigning Redux</a></li><li><a href="https://guide.elm-lang.org/architecture/" target="_blank" rel="noopener">The Elm Architecture</a></li><li><a href="https://staltz.com/unidirectional-user-interface-architectures.html" target="_blank" rel="noopener">UNIDIRECTIONAL USER INTERFACE ARCHITECTURES</a></li></ul><h2 id="关于本系列"><a href="#关于本系列" class="headerlink" title="关于本系列"></a>关于本系列</h2><ul><li>本系列将从介绍 redux-observable 1.0 开始，阐述自己在结合 RxJS 到 Redux 中的心得体会。涉及内容会有 redux-observable 实践介绍，redux-observable 实现原理探究，最后会介绍下自己当前基于 redux-observble + dva architecture 的一个 state 管理框架 reobservable。</li><li>本系列不是 RxJS 或者 Redux 入门，不再讲述他们的基础概念，宣扬他们的核心优势。如果你搜索 RxJS 不小心进到了这个系列，对 RxJS 和 FRP 程序设计产生了兴趣，那么入门我会推荐：<ul><li><a href="https://www.learnrxjs.io/" target="_blank" rel="noopener">learnrxjs.io</a></li><li>Andre Staltz 在 <a href="https://egghead.io/courses/introduction-to-reactive-programming" target="_blank" rel="noopener">egghead.io</a> 上的一系列课程</li><li>程墨的 <a href="https://item.jd.com/12336101.html" target="_blank" rel="noopener">《深入浅出 RxJS》</a></li></ul></li><li>本系列更不是教程，只是介绍自己在 Redux 中应用 RxJS 的一些思路，希望更多人能指出当中存在的误区，或者交流更优雅的实践。</li><li>由衷的感谢实践路上一些师兄的帮助，尤其感谢腾讯云的 questguo 学长在模式上的指导。reobservable 脱胎于腾讯云 questguo 主导的 React 框架 —— TCFF，期待未来 TCFF 的开源。</li><li>感谢小雨的设计支援。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2018/09/04/更好用的_Redux/cover.png&quot; alt=&quot;cover&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文是 《使用 RxJS + Redux 管理应用状态》系列第三篇文章，将介绍我们在使用 Redux 时的困惑，如何重新思考 Redux 定下的范式，以及我们能为此做出的努力。返回第一篇：&lt;a href=&quot;http://yoyoyohamapi.me/2018/08/18/%E4%BD%BF%E7%94%A8_redux-observable_%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6%E8%87%AA%E6%B2%BB/&quot;&gt;使用 redux-observable 实现组件自治&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本系列的文章地址汇总：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://yoyoyohamapi.me/2018/08/18/%E4%BD%BF%E7%94%A8_redux-observable_%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6%E8%87%AA%E6%B2%BB/&quot;&gt;使用 redux-observable 实现组件自治&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://yoyoyohamapi.me/2018/08/21/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA_redux-observable/&quot;&gt;如何实现一个 redux-observable&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://yoyoyohamapi.me/2018/09/04/%E6%9B%B4%E5%A5%BD%E7%94%A8%E7%9A%84_Redux/&quot;&gt;更好用的 Redux&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="React" scheme="http://yoyoyohamapi.me/categories/React/"/>
    
    
      <category term="React" scheme="http://yoyoyohamapi.me/tags/React/"/>
    
      <category term="Redux" scheme="http://yoyoyohamapi.me/tags/Redux/"/>
    
      <category term="RxJS" scheme="http://yoyoyohamapi.me/tags/RxJS/"/>
    
  </entry>
  
  <entry>
    <title>如何实现一个 redux-observable</title>
    <link href="http://yoyoyohamapi.me/2018/08/21/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA_redux-observable/"/>
    <id>http://yoyoyohamapi.me/2018/08/21/实现一个_redux-observable/</id>
    <published>2018-08-21T07:06:18.000Z</published>
    <updated>2018-11-18T04:26:15.782Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2018/08/21/实现一个_redux-observable/cover.png" alt=""></p><blockquote><p>本文是 《使用 RxJS + Redux 管理应用状态》系列第二篇文章，将会介绍 redux-observable 的设计哲学和实现思路。返回第一篇：<a href="http://yoyoyohamapi.me/2018/08/18/%E4%BD%BF%E7%94%A8_redux-observable_%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6%E8%87%AA%E6%B2%BB/">使用 redux-observable 实现组件自治</a></p><p>本系列的文章地址汇总：</p><ul><li><a href="http://yoyoyohamapi.me/2018/08/18/%E4%BD%BF%E7%94%A8_redux-observable_%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6%E8%87%AA%E6%B2%BB/">使用 redux-observable 实现组件自治</a></li><li><a href="http://yoyoyohamapi.me/2018/08/21/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA_redux-observable/">如何实现一个 redux-observable</a></li></ul></blockquote><a id="more"></a><h2 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h2><p>Redux 脱胎于 Elm 架构，其状态管理视角和流程非常清晰和明确：</p><p><img src="/2018/08/21/实现一个_redux-observable/redux.png" alt=""></p><ol><li>dispatch 了一个 action</li><li>reducer 俘获 action，并根据 action 类型进行不同的状态更新逻辑</li><li>周而复始地进行这个过程</li></ol><p>这个过程是同步的，Redux 为了保护 reducer 的纯度是不推荐在 reducer 中处理副作用的（如 HTTP 请求）。因此，就出现了 redux-thunk、redux-saga 这样的 Redux 中间件去处理副作用。</p><p>这些中间件本质都是俘获 dispatch 的内容，并在这个过程中进行副作用处理，最终 dispatch 一个新的 action 给 reducer，让 reducer 专心做一个纯的状态机。</p><h2 id="用-observable-管理副作用"><a href="#用-observable-管理副作用" class="headerlink" title="用 observable 管理副作用"></a>用 observable 管理副作用</h2><p>假定我们在 UI 层能派发出一个数据拉取的 <code>FETCH</code> action，拉取数据后，将派发拉取成功的 <code>FETCH_SUCCESS</code> action 或者是数据拉取失败的 <code>FETCH_ERROR</code> action 到 reducer。</p><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">          FETCH</span><br><span class="line">            <span class="string">|</span></span><br><span class="line">      fetching data...</span><br><span class="line">            <span class="string">|</span></span><br><span class="line">           / \</span><br><span class="line">          /   \</span><br><span class="line">FETCH_SUCCESS FETCH_ERROR</span><br></pre></td></tr></table></figure><p>如果我们用 FRP 模式来思考这个过程，FETCH 就不是一个独立的个体，而是存在于一条会派发 FETCH action 的流上（observable）：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span><span class="meta">---</span> <span class="string">FETCH</span> <span class="bullet">----</span> <span class="string">FETCH</span> <span class="bullet">----</span> </span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span><span class="meta">---</span> <span class="string">FETCH_SUCCESS</span> <span class="bullet">----</span> <span class="string">FETCH_SUCCESS</span> <span class="bullet">----</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span><span class="meta">---</span> <span class="string">FETCH_ERROR</span> <span class="bullet">----</span> <span class="string">FETCH_ERROR</span> <span class="bullet">----</span></span><br></pre></td></tr></table></figure><p>若我们将 FETCH 流定义为 <code>fetch$</code>，则 FETCH_SUCCESS 和 FETCH_ERROR 都将来自于 <code>fetch$</code>：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fetch$: Observable&lt;FetchAction&gt; = <span class="comment">//....</span></span><br><span class="line">fetch$.pipe(</span><br><span class="line">  switchMap(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">from</span>(api.fetch).pipe(</span><br><span class="line">    <span class="comment">// 拉取数据成功 </span></span><br><span class="line">    switchMap(<span class="function"><span class="params">resp</span> =&gt;</span> (&#123;</span><br><span class="line">      <span class="keyword">type</span>: FETCH_SUCCESS,</span><br><span class="line">      payload: &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// 拉取数据失败 </span></span><br><span class="line">    catchError(<span class="function"><span class="params">error</span> =&gt;</span> of(&#123;</span><br><span class="line">      <span class="keyword">type</span>: FETCH_ERROR,</span><br><span class="line">      payload: &#123;</span><br><span class="line">        <span class="comment">// ....</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;))</span><br><span class="line">  ))</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>除此之外，我们可以用一个流来承载页面所有的 action：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> action$: Observable&lt;Action&gt;</span><br></pre></td></tr></table></figure><p>那么， <code>fetch$</code> 亦可以由 <code>action$</code> 流转得到：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fetch$ = action$.pipe(</span><br><span class="line">  filter(<span class="function">(<span class="params">&#123;<span class="keyword">type</span>&#125;</span>) =&gt;</span> <span class="keyword">type</span> === FETCH)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这样，我们就形成了使用 observable 流转 action 的模式：</p><p><img src="/2018/08/21/实现一个_redux-observable/使用 observable 流转 action.png" alt="使用 observable 流转 action"></p><p>接下来，我们尝试讲这个模式整合到 Redux 中，让 observable 来负责应用的 action 流转和副作用处理。</p><h2 id="构建中间件"><a href="#构建中间件" class="headerlink" title="构建中间件"></a>构建中间件</h2><p>Redux 提供的中间件机制能让我们干预每个到来的 action， 借此处理一些业务逻辑，然后再返还一个 action 给 reducer：</p><p><img src="/2018/08/21/实现一个_redux-observable/middleware.png" alt="middleware"></p><p>中间件的函数构成如下：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> middleware: Middleware = <span class="function"><span class="params">store</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 初始化中间件 </span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">next</span> =&gt;</span> action =&gt; &#123; </span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(</span><br><span class="line">  rootReducer,</span><br><span class="line">  applyMiddleware(middleware)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>现在，当中间件初始化时，我们进行 <code>action$</code> 。当新的 action 到来时：</p><ol><li>将 action 交给 reducer 处理</li><li>想 <code>action$</code> 中放入 action</li><li><code>action$</code> 可以转化另一个的 action 流</li></ol><p>因此，<code>action$</code> 既是观察者又是可观察对象，是一个 Subject 对象：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> createMiddleware = (): <span class="function"><span class="params">Middleware</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> action$ = <span class="keyword">new</span> Subject()</span><br><span class="line">  <span class="keyword">const</span> middleware: Middleware = <span class="function"><span class="params">store</span> =&gt;</span> next =&gt; <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 将 action 交给 reducer 处理 </span></span><br><span class="line">    <span class="keyword">const</span> result = next(action)</span><br><span class="line">    <span class="comment">// 将 action 放到 action$ 中进行流转 </span></span><br><span class="line">    action$.next(action)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> middleware</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="流的转换器"><a href="#流的转换器" class="headerlink" title="流的转换器"></a>流的转换器</h2><p>现在，在中间件中，我们初始化了 <code>action$</code>，但是如何得到 <code>fetch$</code> 这些由 <code>action$</code> 派生的流呢？因此，我们还需要告知中间件如果通过 <code>action$</code> 生成更多的流，不妨定义一个转换器，由它负责 <code>action$</code> 的流转，并在当中处理副作用：</p><p><img src="/2018/08/21/实现一个_redux-observable/transformer.png" alt=""></p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Transformer &#123;</span><br><span class="line">  (action$: Observable&lt;Action&gt;): Observable&lt;Action&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fetchTransformer: Transformer = <span class="function">(<span class="params">action$</span>) =&gt;</span> &#123;</span><br><span class="line">  action$.pipe(</span><br><span class="line">    filter(<span class="function">(<span class="params">&#123;<span class="keyword">type</span>&#125;</span>) =&gt;</span> <span class="keyword">type</span> === FETCH),</span><br><span class="line">    switchMap(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">from</span>(api.fetch).pipe(</span><br><span class="line">      switchMap(<span class="function"><span class="params">resp</span> =&gt;</span> (&#123;</span><br><span class="line">        <span class="keyword">type</span>: FETCH_SUCCESS,</span><br><span class="line">        payload: &#123;</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;),</span><br><span class="line">      catchError(<span class="function"><span class="params">error</span> =&gt;</span> of(&#123;</span><br><span class="line">        <span class="keyword">type</span>: FETCH_ERROR,</span><br><span class="line">        payload: &#123;</span><br><span class="line">          <span class="comment">// ....</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;))</span><br><span class="line">    ))</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用中，我们可能定义不同的转换器，从而得到派发不同 action 的流：</p><p><img src="/2018/08/21/实现一个_redux-observable/transformers.png" alt="多个 transformer "></p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> newActionsStreams: Observable&lt;Action&gt;[] = transformers.map(<span class="function"><span class="params">transformer</span> =&gt;</span> transformer(action$))</span><br></pre></td></tr></table></figure><p>由于这些 action 还具有一致的数据结构，因此我们可以将这些流进行合并，由合并后的流负责派发 action 到 reducer：</p><p><img src="/2018/08/21/实现一个_redux-observable/merge.png" alt="合并多个流"></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> newAction$ = merge(newActionStreams)</span><br></pre></td></tr></table></figure><p>那么，修改我们的中间件实现：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> createMiddleware = (...transformers): <span class="function"><span class="params">Middleware</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> action$ = <span class="keyword">new</span> Subject()</span><br><span class="line">  <span class="comment">// 运行各个 transformer，并将转换的流进行合并 </span></span><br><span class="line">  <span class="keyword">const</span> newAction$ = merge(tramsformer.map(<span class="function"><span class="params">transformer</span> =&gt;</span> transformer(action$)))</span><br><span class="line">  <span class="keyword">const</span> middleware: Middleware = <span class="function"><span class="params">store</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 订阅 newAction$</span></span><br><span class="line">    newAction$.subscribe(<span class="function"><span class="params">action</span> =&gt;</span> store.dispatch(action))</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">next</span> =&gt;</span> action =&gt; &#123;</span><br><span class="line">      <span class="comment">// 将 action 交给 reducer 处理 </span></span><br><span class="line">      <span class="keyword">const</span> result = next(action)</span><br><span class="line">      <span class="comment">// 将 action 放到 action$ 中进行流转 </span></span><br><span class="line">      action$.next(action)</span><br><span class="line">      <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> middleware</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优化：ofType-operator"><a href="#优化：ofType-operator" class="headerlink" title="优化：ofType operator"></a>优化：<code>ofType</code> operator</h2><p>由于我们总是需要 <code>filter(action =&gt; action.type === SOME_TYPE)</code> 来过滤 action，因此可以封装一个 operator 来优化这个过程：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ofType: OperatorFunction&lt;Observable&lt;Action&gt;, Observable&lt;Action&gt;&gt; = <span class="function">(<span class="params"><span class="keyword">type</span>: <span class="built_in">String</span></span>) =&gt;</span> pipe(</span><br><span class="line">  filter(<span class="function"><span class="params">action</span> =&gt;</span> action.type === <span class="keyword">type</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fetchTransformer: Transformer = (action$) &#123;</span><br><span class="line">  <span class="keyword">return</span> action$.pipe(</span><br><span class="line">    filter(<span class="function">(<span class="params">&#123;<span class="keyword">type</span>&#125;</span>) =&gt;</span> <span class="keyword">type</span> === FETCH),</span><br><span class="line">    switchMap(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">from</span>(api.fetch)),</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再考虑到我们可能不只过滤一个 action type，因此可以优化我们的 <code>ofType</code> operator 为：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ofType: OperatorFunction&lt;Observable&lt;Action&gt;, Observable&lt;Action&gt;&gt; = </span><br><span class="line">  (...types: <span class="built_in">String</span>[]) =&gt; pipe(</span><br><span class="line">    filter(<span class="function">(<span class="params">action: Action</span>) =&gt;</span> types.indexOf(action.type) &gt; <span class="number">-1</span>)</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> counterTransformer: Transformer = (action$) &#123;</span><br><span class="line">  <span class="keyword">return</span> action$.pipe(</span><br><span class="line">    ofType(INCREMENT, DECREMENT),</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面这个测试用例将用来测试我们的中间件是否能够工作了：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'should transform action'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">const</span> reducer: Reducer = <span class="function">(<span class="params">state = 0, action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span>(action.type) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'PONG'</span>:</span><br><span class="line">        <span class="keyword">return</span> state + <span class="number">1</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> state</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> transformer: Transformer = <span class="function">(<span class="params">action$</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> action$.pipe(</span><br><span class="line">        ofType(<span class="string">'PING'</span>),</span><br><span class="line">        mapTo(&#123;<span class="keyword">type</span>: <span class="string">'PONG'</span>&#125;)</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> middleware = createMiddleware(transformer)</span><br><span class="line">  <span class="keyword">const</span> store = createStore(reducer, applyMiddleware(middleware))</span><br><span class="line">  store.dispatch(&#123;<span class="keyword">type</span>: <span class="string">'PING'</span>&#125;)</span><br><span class="line">  expect(store.getState()).to.be.equal(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="优化：获得-state"><a href="#优化：获得-state" class="headerlink" title="优化：获得 state"></a>优化：获得 state</h2><p>在 action 的流转过程可能还需要获得应用状态，例如，<code>fetch$</code> 中获取数据前，需要封装请求参数，部分参数可能来自于应用状态。因此，我们可以考虑为每个 transformer 再传递当前的 store 对象，使它能拿到当前的应用状态：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Transformer &#123;</span><br><span class="line">  (action$: Observable&lt;Action&gt;, store: Store): Observable&lt;Action&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> createMiddleware = (...transformers): <span class="function"><span class="params">Middleware</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> action$ = <span class="keyword">new</span> Subject()</span><br><span class="line">  <span class="keyword">const</span> middleware: Middleware = <span class="function"><span class="params">store</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 将 store 也传递给 transformer</span></span><br><span class="line">    <span class="keyword">const</span> newAction$ = merge(tramsformer.map(<span class="function"><span class="params">transformer</span> =&gt;</span> transformer(action$, store)))</span><br><span class="line">    newAction$.subscribe(<span class="function"><span class="params">action</span> =&gt;</span> store.dispatch(action))</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">next</span> =&gt;</span> action =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> result = next(action)</span><br><span class="line">      action$.next(action)</span><br><span class="line">      <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> middleware</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，当需要取用状态的时候，就通过 <code>store.getState()</code> 拿取：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fetchTransformer: Transformer = (action$, store) &#123;</span><br><span class="line">  <span class="keyword">return</span> action$.pipe(</span><br><span class="line">    filter(<span class="function">(<span class="params">&#123;<span class="keyword">type</span>&#125;</span>) =&gt;</span> <span class="keyword">type</span> === FETCH),</span><br><span class="line">    switchMap(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; query, page, pageSize &#125; = store.getState()</span><br><span class="line">      <span class="keyword">const</span> params = &#123; query, page, pageSize &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">from</span>(api.fetch, params)</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优化：观察状态"><a href="#优化：观察状态" class="headerlink" title="优化：观察状态"></a>优化：观察状态</h2><p>在响应式编程体系下，一切数据源都应当是可被观察的，而上面我们对状态的取值确是主动的（proactive）的，正确的方式是应当观察状态的变化，并在变化时作出决策：</p><p><img src="/2018/08/21/实现一个_redux-observable/state$.png" alt="state$"></p><p>为此，类似 <code>action$</code>，我们也将 state 流化，使得应用状态成为一个可观察对象，并将 <code>state$</code> 传递给 transformer：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Transformer &#123;</span><br><span class="line">  (action$: Observable&lt;Action&gt;, state$: Observable&lt;State&gt;): Observable&lt;Action&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> createMiddleware = (...transformers): <span class="function"><span class="params">Middleware</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> action$ = <span class="keyword">new</span> Subject()</span><br><span class="line">  <span class="keyword">const</span> state$ = <span class="keyword">new</span> Subject()</span><br><span class="line">  <span class="keyword">const</span> middleware: Middleware = <span class="function"><span class="params">store</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 由各个 transformer 获得应用的 action$</span></span><br><span class="line">    <span class="keyword">const</span> newAction$ = merge(tramsformer.map(<span class="function"><span class="params">transformer</span> =&gt;</span> transformer(action$, state$)))</span><br><span class="line">    <span class="comment">// 新的 action 到来时，将其又 dispatch 到 Redux 生态 </span></span><br><span class="line">    newAction$.subscribe(<span class="function"><span class="params">action</span> =&gt;</span> store.dispatch(action))</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">next</span> =&gt;</span> action =&gt; &#123;</span><br><span class="line">      <span class="comment">// 将 action 交给 reducer</span></span><br><span class="line">      <span class="keyword">const</span> result = next(action)</span><br><span class="line">      <span class="comment">// 获得 reducer 处理后的新状态 </span></span><br><span class="line">      state$.next(state)</span><br><span class="line">      <span class="comment">// 将 action 放入 action$</span></span><br><span class="line">      action$.next(action)</span><br><span class="line">      <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> middleware</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当业务流程需要状态时，就可以自由组合 <code>state$</code> 得到：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fetchTransformer: Transformer = (action$, state$) &#123;</span><br><span class="line">  <span class="keyword">return</span> action$.pipe(</span><br><span class="line">    filter(<span class="function">(<span class="params">&#123;<span class="keyword">type</span>&#125;</span>) =&gt;</span> <span class="keyword">type</span> === FETCH),</span><br><span class="line">    withLatestFrom(state$),</span><br><span class="line">    switchMap(<span class="function">(<span class="params">[action, state]</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; query, page, pageSize &#125; = state</span><br><span class="line">      <span class="keyword">const</span> params = &#123; query, page, pageSize &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">from</span>(api.fetch, params)</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>乍看之下，似乎不如 <code>store.getState()</code> 来的方便，为了获得当前状态，我们还额外引入了一个 operator <code>withLatestFrom</code>。但是，要注意到，我们引入 <code>state$</code> 不只为了获得状态和统一模式，更重要是为了 <strong> 观察 </strong> 状态。</p><p>举个例子，我们有一个备忘录组件，每次内容变动时，我们就存储一下草稿。如果我们能观察状态变动，通过响应式编程模式，当状态变动时，自动形成草稿存储的业务：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> saveDraft$: Observable&lt;Action&gt; = state$.pipe(</span><br><span class="line">  <span class="comment">// 选出当前 </span></span><br><span class="line">  pluck(<span class="string">'content'</span>),</span><br><span class="line">  <span class="comment">// 只有当内容变动时才考虑存储草稿 </span></span><br><span class="line">  distinctUntilChanged(),</span><br><span class="line">  <span class="comment">// 只在 1 s 内保存一次 </span></span><br><span class="line">  throttleTime(<span class="number">1000</span>),</span><br><span class="line">  <span class="comment">// 调用服务存储草稿 </span></span><br><span class="line">  switchMap(<span class="function"><span class="params">content</span> =&gt;</span> <span class="keyword">from</span>(api.saveDraft(content)))</span><br><span class="line">  <span class="comment">// ....</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>大家也可以在回顾系列第一篇所介绍的内容，正是由于 redux-observable 在 1.0 版本引入了 <code>state$</code>，我们才得以解耦组件的业务关系，实现单个组件的自治。</p><h2 id="优化：响应初始状态"><a href="#优化：响应初始状态" class="headerlink" title="优化：响应初始状态"></a>优化：响应初始状态</h2><p>现在，我们可以测试一下现在的中间件，看能否观察应用状态了：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'should observe state'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">const</span> reducer: Reducer = <span class="function">(<span class="params">state = &#123;step: 10, counter: 0&#125;, action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span>(action.type) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'PONG'</span>:</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          ...state,</span><br><span class="line">          counter: action.counter</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> state</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> transformer: Transformer = <span class="function">(<span class="params">action$, state$</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> action$.pipe(</span><br><span class="line">        ofType(<span class="string">'PING'</span>),</span><br><span class="line">      withLatestFrom(state$, <span class="function">(<span class="params">action, state</span>) =&gt;</span> state.step + state.counter),</span><br><span class="line">        map(<span class="function"><span class="params">counter</span> =&gt;</span> (&#123;<span class="keyword">type</span>: <span class="string">'PONG'</span>, counter&#125;))</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> middleware = createMiddleware(transformer)</span><br><span class="line">  <span class="keyword">const</span> store = createStore(reducer, applyMiddleware(middleware))</span><br><span class="line">  store.dispatch(&#123;<span class="keyword">type</span>: <span class="string">'PING'</span>&#125;)</span><br><span class="line">  expect(store.getState().counter).to.be.equal(<span class="number">10</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>遗憾的是，这个测试用例将不会通过，通过调试发现，当我们 dispatch 了 PING action 后，<code>withLatestFrom</code> 没有拿到最近一次的 state。这是为什么呢？原来是因为 Redux 的 init action 并没有暴露给中间件进行拦截，因此，应用的初始状态没能被送入 <code>state$</code> 中，观察者无法观察到初始状态。</p><p>为了解决这个问题，在创建了 store 后，我们可以尝试 dispatch 一个无意义的 action 给中间件，强制将初始状态先送入 <code>state$</code> 中：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> middleware = createMiddleware(transformer)</span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer, applyMiddleware(middleware))</span><br><span class="line"><span class="comment">// 派发一个 action 去获得初始状态 </span></span><br><span class="line">store.dispatch(&#123;<span class="keyword">type</span>: <span class="string">'@@INIT_STATE'</span>&#125;)</span><br></pre></td></tr></table></figure><p>这个方式虽然能让测试通过，但缺不是很优雅，我们让用户手动去派发一个无意义的 action，这会让用户感觉很困惑。因此，我们考虑为中间件单独设置一个 API，用以在 store 创建后，完成一些任务：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置一个 store 副本 </span></span><br><span class="line"><span class="keyword">let</span> cachedStore: Store</span><br><span class="line"><span class="keyword">const</span> createMiddleware = (...transformers): <span class="function"><span class="params">Middleware</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> action$ = <span class="keyword">new</span> Subject()</span><br><span class="line">  <span class="keyword">const</span> state$ = <span class="keyword">new</span> Subject()</span><br><span class="line">  <span class="keyword">const</span> newAction$ = merge(transformers.map(<span class="function"><span class="params">transformer</span> =&gt;</span> transformer(action$, state$)))</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> middleware: Middleware = <span class="function"><span class="params">store</span> =&gt;</span> &#123;</span><br><span class="line">    cachedStore = store</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">next</span> =&gt;</span> action =&gt; &#123;</span><br><span class="line">      <span class="comment">// 将 action 交给 reducer</span></span><br><span class="line">      <span class="keyword">const</span> result = next(action)</span><br><span class="line">      <span class="comment">// 获得 reducer 处理后的新状态 </span></span><br><span class="line">      state$.next(state)</span><br><span class="line">      <span class="comment">// 将 action 放入 action$</span></span><br><span class="line">      action$.next(action)</span><br><span class="line">      <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  middleware.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 开始对 action 的订阅 </span></span><br><span class="line">    newAction$.subscribe(cachedStore.dispatch)</span><br><span class="line">    <span class="comment">// 2. 将初始状态传递给 state$</span></span><br><span class="line">    state$.next(cachedStore.getState())</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> middleware</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们为中间件提供了一个 <code>run</code> 方法，来让中间件在 store 创建以后完成一些工作。当我们创建好 store 后，运行 <code>run</code> 方法来运行中间件：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> middleware = createMiddleware(transformer)</span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer, applyMiddleware(middleware))</span><br><span class="line"><span class="comment">// 运行我们的中间件 </span></span><br><span class="line">middleware.run()</span><br></pre></td></tr></table></figure><h2 id="优化：相互关联的-transformer"><a href="#优化：相互关联的-transformer" class="headerlink" title="优化：相互关联的 transformer"></a>优化：相互关联的 transformer</h2><p>再考虑一个更加场景，各个 transformer 之间可能存在关联，各个 trasformer 也可能直接发出 action，而不需要依赖于 <code>action$</code>：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'should queue synchronous actions'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> reducer = <span class="function">(<span class="params">state = [], action</span>) =&gt;</span> state.concat(action)</span><br><span class="line">    <span class="keyword">const</span> transformer1 = <span class="function">(<span class="params">action$, state$</span>) =&gt;</span> action$.pipe(</span><br><span class="line">      ofType(<span class="string">'FIRST'</span>),</span><br><span class="line">      mergeMap(<span class="function"><span class="params">()</span> =&gt;</span> of(&#123; <span class="keyword">type</span>: <span class="string">'SECOND'</span> &#125;, &#123; <span class="keyword">type</span>: <span class="string">'THIRD'</span>&#125; ))</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">const</span> transformer2 = <span class="function">(<span class="params">action$, state$</span>) =&gt;</span> action$.pipe(</span><br><span class="line">        ofType(<span class="string">'SECOND'</span>),</span><br><span class="line">        mapTo(&#123;<span class="keyword">type</span>: <span class="string">'FORTH'</span>&#125;)</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> middleware = createMiddleware(transformer1, transformer2)</span><br><span class="line">    <span class="keyword">const</span> store = createStore(reducer, applyMiddleware(middleware))</span><br><span class="line">    middleware.run()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> actions = store.getState()</span><br><span class="line">    actions.shift() <span class="comment">// remove redux init action</span></span><br><span class="line">    expect(actions).to.deep.equal([</span><br><span class="line">      &#123; <span class="keyword">type</span>: <span class="string">'FIRST'</span> &#125;,</span><br><span class="line">      &#123; <span class="keyword">type</span>: <span class="string">'SECOND'</span> &#125;,</span><br><span class="line">      &#123; <span class="keyword">type</span>: <span class="string">'THIRD'</span> &#125;,</span><br><span class="line">      &#123; <span class="keyword">type</span>: <span class="string">'FORTH'</span> &#125;</span><br><span class="line">    ])</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在这个测试用例中，我们看到的 action 序列是：</p><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">FIRST</span></span><br><span class="line"><span class="attribute">SECOND</span></span><br><span class="line"><span class="attribute">THIRD</span></span><br><span class="line"><span class="attribute">FORTH</span></span><br></pre></td></tr></table></figure><p>但是，在当前的实现中，你将得到：</p><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">FIRST</span></span><br><span class="line"><span class="attribute">SECOND</span></span><br><span class="line"><span class="attribute">FORTH</span></span><br><span class="line"><span class="attribute">THIRD</span></span><br></pre></td></tr></table></figure><p>这并不符合预期。但是，问题又出在哪里呢？我们分析下程序执行过程：</p><ol><li>发出 first action</li><li>调度 first action，派生出 second action 及 third action 的 observable</li><li>调度 second action，派生出 forth action 的 observable</li><li>调度 forth action</li><li>调度 third action</li></ol><p>问题显然就出在第 2、3 步，如果第 2 步中，我们控制 observable <strong> 吐出值 </strong> 的速度，将同时到来的 second 和 third action 缓存到队列，并依次执行，就能得到我们期望的输出。</p><p>幸运的是，RxJS 中提供了 <a href="http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-observeOn" target="_blank" rel="noopener"> <code>observeOn</code></a> 这个 operator 来控制 <strong> 数据源发出值的节奏 </strong>。其第一个参数接收一个调度器，用于告知数据源以怎样的速录调度任务，这里我们将使用 <a href="https://rxjs-dev.firebaseapp.com/api/index/const/queueScheduler" target="_blank" rel="noopener"><strong>Queue Scheduler</strong></a> 将各个 action 缓存到队列，当此时再无 action 时，各个 action 出队并被调度：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createEpicMiddleware = <span class="function">(<span class="params">...epics</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> action$ = <span class="keyword">new</span> Subject().pipe(observeOn(queueScheduler)) <span class="keyword">as</span> Subject&lt;Action&gt;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> middleware</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，再次运行测试用例，你讲看到符合期望的 action 序列：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">FIRST</span><br><span class="line">SECOND</span><br><span class="line">THIRD</span><br><span class="line">FORTH</span><br></pre></td></tr></table></figure><p>这是因为：</p><ol><li>发出 first action</li><li>调度 first action，入队</li><li>此时没有 action，first action 出队，<code>store.dispatch(first)</code>，派生出 second action 及 third action 的 observable</li><li>second action 入队，third action 入队</li><li>此时没有等待的 action，则 second action 出队，<code>store.dispatch(second)</code>，派生出 forth action 的 observable</li><li>forth action 入队</li><li>此时没有等待的 action，队首元素 third action 出队，<code>store.dispatch(third)</code></li><li>forth action 出队，<code>store.dispatch(forth)</code></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>截止目前，我们的中间件已经允许我们通过 FRP 模式梳理应用状态了，这个中间件的实现已经非常类似于 redux-observable 的实现了。当然，大家生产环境还是用更流行，更稳定的 redux-observable，本文旨在帮助大家更好的理解如何在 Redux 中集成 RxJS 更好的管理状态，通过一步一步对中间件的优化，也让大家理解了了 redux-observable 的设计哲学和实现原理。本文实现的 mini redux-observable 我也放到了我的 <a href="https://github.com/yoyoyohamapi/toys/tree/master/redux-observable" target="_blank" rel="noopener">github</a> 上，包含了一些测试用例和一个小的 demo。</p><p>接下来，我们将探索将 redux-observable 以及 FRP 这套模式集成到 dva 架构的前端框架中，dva 架构帮助砍掉 Redux 冗长的样板代码，而 redux-observable 则专注于副作用处理。</p><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html" target="_blank" rel="noopener">RxJS API document</a></li><li><a href="https://staltz.com/primer-on-rxjs-schedulers.html" target="_blank" rel="noopener">PRIMER ON RXJS SCHEDULERS</a></li><li><a href="https://github.com/redux-observable/redux-observable/pull/493" target="_blank" rel="noopener">redux-observable #493 pull request</a></li><li><a href="https://www.youtube.com/watch?v=AL8dG1tuH40&amp;t=2366s" target="_blank" rel="noopener">Gerard Sans — Bending time with Schedulers and RxJS 5</a></li></ul><h2 id="关于本系列"><a href="#关于本系列" class="headerlink" title="关于本系列"></a>关于本系列</h2><ul><li>本系列将从介绍 redux-observable 1.0 开始，阐述自己在结合 RxJS 到 Redux 中的心得体会。涉及内容会有 redux-observable 实践介绍，redux-observable 实现原理探究，最后会介绍下自己当前基于 redux-observble + dva architecture 的一个 state 管理框架 reobservable。</li><li>本系列不是 RxJS 或者 Redux 入门，不再讲述他们的基础概念，宣扬他们的核心优势。如果你搜索 RxJS 不小心进到了这个系列，对 RxJS 和 FRP 程序设计产生了兴趣，那么入门我会推荐：<ul><li><a href="https://www.learnrxjs.io/" target="_blank" rel="noopener">learnrxjs.io</a></li><li>Andre Staltz 在 <a href="https://egghead.io/courses/introduction-to-reactive-programming" target="_blank" rel="noopener">egghead.io</a> 上的一系列课程</li><li>程墨的 <a href="https://item.jd.com/12336101.html" target="_blank" rel="noopener">《深入浅出 RxJS》</a></li></ul></li><li>本系列更不是教程，只是介绍自己在 Redux 中应用 RxJS 的一些思路，希望更多人能指出当中存在的误区，或者交流更优雅的实践。</li><li>由衷的感谢实践路上一些师兄的帮助，尤其感谢腾讯云的 questguo 学长在模式上的指导。reobservable 脱胎于腾讯云 questguo 主导的 React 框架 —— TCFF，期待未来 TCFF 的开源。</li><li>感谢小雨的设计支援。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2018/08/21/实现一个_redux-observable/cover.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文是 《使用 RxJS + Redux 管理应用状态》系列第二篇文章，将会介绍 redux-observable 的设计哲学和实现思路。返回第一篇：&lt;a href=&quot;http://yoyoyohamapi.me/2018/08/18/%E4%BD%BF%E7%94%A8_redux-observable_%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6%E8%87%AA%E6%B2%BB/&quot;&gt;使用 redux-observable 实现组件自治&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本系列的文章地址汇总：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://yoyoyohamapi.me/2018/08/18/%E4%BD%BF%E7%94%A8_redux-observable_%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6%E8%87%AA%E6%B2%BB/&quot;&gt;使用 redux-observable 实现组件自治&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://yoyoyohamapi.me/2018/08/21/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA_redux-observable/&quot;&gt;如何实现一个 redux-observable&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="React" scheme="http://yoyoyohamapi.me/categories/React/"/>
    
    
      <category term="React" scheme="http://yoyoyohamapi.me/tags/React/"/>
    
      <category term="Redux" scheme="http://yoyoyohamapi.me/tags/Redux/"/>
    
      <category term="RxJS" scheme="http://yoyoyohamapi.me/tags/RxJS/"/>
    
  </entry>
  
  <entry>
    <title>使用 redux-observable 实现组件自治</title>
    <link href="http://yoyoyohamapi.me/2018/08/18/%E4%BD%BF%E7%94%A8_redux-observable_%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6%E8%87%AA%E6%B2%BB/"/>
    <id>http://yoyoyohamapi.me/2018/08/18/使用_redux-observable_实现组件自治/</id>
    <published>2018-08-18T02:35:00.000Z</published>
    <updated>2018-08-26T14:56:10.040Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2018/08/18/使用_redux-observable_实现组件自治/cover.png" alt=""></p><h1 id="使用-redux-observable-实现组件自治"><a href="#使用-redux-observable-实现组件自治" class="headerlink" title="使用 redux-observable 实现组件自治"></a>使用 redux-observable 实现组件自治</h1><blockquote><p>本文是 《使用 RxJS + Redux 管理应用状态》系列第一篇文章，旨在介绍 redux-obervable v1 版本为 React + Redux 带来的组件自治能力。</p><p>本系列的文章地址汇总：</p><ul><li><a href="http://yoyoyohamapi.me/2018/08/18/%E4%BD%BF%E7%94%A8_redux-observable_%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6%E8%87%AA%E6%B2%BB/">使用 redux-observable 实现组件自治</a></li><li><a href="http://yoyoyohamapi.me/2018/08/21/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA_redux-observable/">如何实现一个 redux-observable</a></li></ul></blockquote><a id="more"></a><h2 id="redux-observable-简介"><a href="#redux-observable-简介" class="headerlink" title="redux-observable 简介"></a>redux-observable 简介</h2><p><a href="https://github.com/redux-observable/redux-observable" target="_blank" rel="noopener">redux-observable</a> 是 redux 一个中间件，使用了 RxJs 来驱动 action 副作用。与其目的类似的有大家比较熟悉的 <a href="https://github.com/reduxjs/redux-thunk" target="_blank" rel="noopener">redux-thunk</a> 和 <a href="https://github.com/redux-saga/redux-saga" target="_blank" rel="noopener">redux-saga</a>。通过集成 redux-observable，我们可以在 Redux 中使用到 RxJS 所提供的函数响应式编程（FRP）的能力，从而更轻松的管理我们的异步副作用（前提是你熟悉了 RxJS）。</p><p><strong>Epic</strong> 是 redux-observable 的核心概念和基础类型，几乎承载了 redux-observable 的所有。从形式上看，Epic 是一个函数，其接收一个 <strong>action stream</strong>，输出一个新的 action stream：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">action$: Observable&lt;Action&gt;, state$: StateObservable&lt;State&gt;</span>): <span class="title">Observable</span>&lt;<span class="title">Action</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，Epic 扮演了 stream 转换器的能力。</p><p>在 redux-observable 的视角下，Redux 作为中央状态收集器，当一个 action 被 dispatch，历经某个同步或者异步任务，将 dispatch 一个新的 action，携带着它的负载（payload）到 reducer，如此反复。这么看的话，Epic 定义了 action 因果关系。</p><p>同时，FRP 模式的 RxJS 还带来了如下能力：</p><ul><li><strong> 竞态处理能力 </strong></li><li><strong> 声明式地任务处理 </strong></li><li><strong> 测试友好 </strong></li><li><strong> 组件自治 </strong>（redux-observable 1. 0 开始支持）</li></ul><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>本系列是假定读者有了 FRP 和 RxJS 的基础，因此，关于 RxJS 和 redux-observable 不再赘述。</p><p>现在，我们实践一个常见的业务需求 —— 列表页。通过这个例子，将展示 redux-observable 1.0 新的特性，并展示在 1.0 下实现的组件自治。</p><blockquote><p><strong> 组件自治 </strong>：组件只用关注如何治理自己。</p></blockquote><p>先看到列表页的诉求：</p><ul><li>间隔一段时间轮询数据列表</li><li>支持搜索，触发搜索时，重新轮询</li><li>支持字段排序，排序状况变动，重新轮询</li><li>支持分页，页面容量修改，分页状况变动，重新轮询</li><li>组件卸载时，结束轮询</li></ul><p>在前端组件化开发的思路下，我们可能会设计如下容器组件（Container），其中基础组件基于 <a href="https://ant.design/" target="_blank" rel="noopener">ant design</a>：</p><ul><li><p><strong> 数据表格（含分页）</strong>：基于 <strong>Table</strong> 组件</p></li><li><p><strong> 搜索框：</strong>：基于 <strong>Input</strong> 组件</p></li><li><p><strong> 排序选择框：</strong> 基于 <strong>Select </strong> 组件</p></li></ul><p>在 React + Redux 的架构下，容器组件通过 <code>connect</code> 方法从状态树上采摘自己所需要的状态，因此，先要认识到，这些容器组件必定存在一个 <strong> 耦合 </strong>—— Redux：</p><p><img src="/2018/08/18/使用_redux-observable_实现组件自治/rxjs_redux_list_page.png" alt="列表页"></p><p>接下来将会讨论两种不同的模式下，列表应用的状态管理和副作用处理，它们分别是基于 redux-thunk 或者 redux-saga 的传统模式，以及基于 redux-observable 的 FRP 模式。大家可以看到不同模式下，除了基础的对于 Redux 的耦合，组件及其数据生态（状态与副作用）上耦合状况的差异。</p><p>当然，为了让大家更好的理解文章，我也撰写了一个 <strong><a href="https://github.com/yoyoyohamapi/self-government-component-with-redux-observable" target="_blank" rel="noopener">demo</a></strong>，大家可以 clone &amp; run。接下来的代码也都来源于这个 demo。demo 一个 github 小应用，其中你看到用户列表背后是基于 FRP 模式的，Repo 列表则是基于传统模式的：</p><p><img src="/2018/08/18/使用_redux-observable_实现组件自治/rxjs_redux_demo.png" alt="demo screenshot"></p><h2 id="传统模式下组件的耦合"><a href="#传统模式下组件的耦合" class="headerlink" title="传统模式下组件的耦合"></a>传统模式下组件的耦合</h2><p>在传统的模式下，我们需要面对一个现实，对于状态的获取是 <strong> 主动式（proactive）</strong> 的：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> state = store.getState()</span><br></pre></td></tr></table></figure><p>亦即我们需要 <strong> 主动取用状态 </strong>，而无法监听状态变化。因此，在这种模式下，我们组件化开发的思路会是：</p><ul><li>组件挂载，开启轮询<ul><li>搜索时，结束上次轮询，构建新的请求参数，开始新的轮询</li><li>排序变动时，结束上次轮询，构建新的请求参数，开始新的轮询</li><li>分页变动时，结束上次轮询，构建新的请求参数，开始新的轮询</li></ul></li><li>组件卸载，结束轮询</li></ul><p>在这种思路下，我们撰写搜索，排序，分页等容器时，当容器涉及的取值变动时，不仅需要在状态树上更新这些值，还需要去重启一下轮询。</p><p><img src="/2018/08/18/使用_redux-observable_实现组件自治/rxjs_redux_traditional.png" alt="组件耦合"></p><p>假定我们使用 redux-thunk 来处理副作用，代码大致如下：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> pollingTimer: <span class="built_in">number</span> = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchUsers</span>(<span class="params"></span>): <span class="title">ThunkResult</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">dispatch, getState</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> delay = pollingTimer === <span class="literal">null</span> ? <span class="number">0</span> : <span class="number">15</span> * <span class="number">1000</span></span><br><span class="line">    pollingTimer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      dispatch(&#123;</span><br><span class="line">        <span class="keyword">type</span>: FETCH_START,</span><br><span class="line">        payload: &#123;&#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">const</span> &#123; repo &#125;: &#123; repo: IState &#125; = getState()</span><br><span class="line">      <span class="keyword">const</span> &#123; pagination, sort, query &#125; = repo</span><br><span class="line">      <span class="comment">// 封装参数 </span></span><br><span class="line">      <span class="keyword">const</span> param: ISearchParam = &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 进行请求 </span></span><br><span class="line">      <span class="comment">// fetch(param)...</span></span><br><span class="line">  &#125;, delay)</span><br><span class="line">&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">polling</span>(<span class="params"></span>): <span class="title">ThunkResult</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</span><br><span class="line">    dispatch(stopPolling())</span><br><span class="line">    dispatch(&#123;</span><br><span class="line">      <span class="keyword">type</span>: POLLING_START,</span><br><span class="line">      payload: &#123;&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    dispatch(fetchUsers())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">stopPolling</span>(<span class="params"></span>): <span class="title">IAction</span> </span>&#123;</span><br><span class="line">  clearTimeout(pollingTimer)</span><br><span class="line">  pollingTimer = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="keyword">type</span>: POLLING_STOP,</span><br><span class="line">    payload: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">changePagination</span>(<span class="params">pagination: IPagination</span>): <span class="title">ThunkResult</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</span><br><span class="line">    dispatch(&#123;</span><br><span class="line">      <span class="keyword">type</span>: CHANGE_PAGINATION,</span><br><span class="line">      payload: &#123;</span><br><span class="line">        pagination</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    dispatch(polling())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">changeQuery</span>(<span class="params">query: <span class="built_in">string</span></span>): <span class="title">ThunkResult</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</span><br><span class="line">    dispatch(&#123;</span><br><span class="line">      <span class="keyword">type</span>: CHANGE_QUERY,</span><br><span class="line">      payload: &#123;</span><br><span class="line">        query</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    dispatch(polling())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">changeSort</span>(<span class="params">sort: <span class="built_in">string</span></span>): <span class="title">ThunkResult</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</span><br><span class="line">    dispatch(&#123;</span><br><span class="line">      <span class="keyword">type</span>: CHANGE_SORT,</span><br><span class="line">      payload: &#123;</span><br><span class="line">        sort</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    dispatch(polling())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，涉及到 <strong> 请求参数 </strong> 的几个组件，如筛选项目，分页，搜索等，当它们 dispatch 了一个 action 修改对应的业务状态后，<strong> 还需要手动 dispatch 一个重启轮询的 action 结束上一次轮询，开启下一次轮询 </strong>。</p><p>或许这个场景的复杂程度你觉得也还能接受，但是假想我们有一个更大的项目，或者现在的项目未来会扩展得很大，那么组件势必会越来越多，参与协作的开发者也会越来越多。协作的开发者就需要时刻关注到自己撰写的组件是否会是其他开发者撰写的组件的影响因子，如果是的话，影响有多大，又该怎么处理？</p><blockquote><p>这里提到的组件不单纯指 UI Component，还包括了组件涉及的数据生态。因为绝大部分前端开发者撰写业务组件时，除了 UI，还要实现 UI 涉及的业务逻辑。</p></blockquote><p>我们归纳下使用传统模式梳理数据流以及副作用面临的问题：</p><ol><li><strong> 过程式编程 </strong>，代码啰嗦</li><li><strong> 竞态处理 </strong> 需要人为地通过标志量等进行控制</li><li><strong> 组件间耦合 </strong> 大，彼此牵连。</li></ol><h2 id="FRP-模式与组件自治"><a href="#FRP-模式与组件自治" class="headerlink" title="FRP 模式与组件自治"></a>FRP 模式与组件自治</h2><p>在 FRP 模式下，遵循 <strong>passive</strong> 模式，state 应当被观察和响应，而不是主动获取。因此，redux-observable 从 <a href="https://github.com/redux-observable/redux-observable/blob/master/CHANGELOG.md#100-alpha0-2018-04-04" target="_blank" rel="noopener">1.0</a>  开始，不再推荐使用 <code>store.getState()</code> 进行状态获取，Epic 有了新的函数签名， 第二个参数为 <code>state$</code>：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">action$: Observable&lt;Action&gt;, state$: StateObservable&lt;State&gt;</span>): <span class="title">Observable</span>&lt;<span class="title">Action</span>&gt;</span></span><br></pre></td></tr></table></figure><p>state$ 的引入，让 redux-observable 达到了它的里程碑，现在，我们能在 Redux 中更进一步地实践 FRP。比如下面这个例子（来源自 redux-observable 官方），当 <code>googleDocument</code> 状态变动时，我们就自动存储 google 文档：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> autoSaveEpic = <span class="function">(<span class="params">action$, state$</span>) =&gt;</span></span><br><span class="line">  action$.pipe(</span><br><span class="line">    ofType(AUTO_SAVE_ENABLE),</span><br><span class="line">    exhaustMap(<span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">      state$.pipe(</span><br><span class="line">        pluck(<span class="string">'googleDocument'</span>),</span><br><span class="line">        distinctUntilChanged(),</span><br><span class="line">        throttleTime(<span class="number">500</span>, &#123; <span class="attr">leading</span>: <span class="literal">false</span>, <span class="attr">trailing</span>: <span class="literal">true</span> &#125;),</span><br><span class="line">        concatMap(<span class="function"><span class="params">googleDocument</span> =&gt;</span></span><br><span class="line">          saveGoogleDoc(googleDocument).pipe(</span><br><span class="line">            map(<span class="function"><span class="params">()</span> =&gt;</span> saveGoogleDocFulfilled()),</span><br><span class="line">            catchError(<span class="function"><span class="params">e</span> =&gt;</span> <span class="keyword">of</span>(saveGoogleDocRejected(e)))</span><br><span class="line">          )</span><br><span class="line">        ),</span><br><span class="line">        takeUntil(action$.pipe(</span><br><span class="line">          ofType(AUTO_SAVE_DISABLE)</span><br><span class="line">        ))</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  );</span><br></pre></td></tr></table></figure><p>回过头来，我们还可以将列表页的需求概括为：</p><ul><li>间隔一段时间轮询数据列表</li><li>参数（排序，分页等）变动时，重新发起轮询</li><li>主动进行搜索时，重新发起轮询</li><li>组件卸载时结束轮询</li></ul><p>在 FRP 模式下，我们定义一个轮询 epic：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pollingEpic: Epic = <span class="function">(<span class="params">action$, state$</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> stopPolling$ = action$.ofType(POLLING_STOP)</span><br><span class="line">  <span class="keyword">const</span> params$: Observable&lt;ISearchParam&gt; = state$.pipe(</span><br><span class="line">    map(<span class="function">(<span class="params">&#123;user&#125;: &#123;user: IState&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; pagination, sort, query &#125; = user</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        q: <span class="string">`<span class="subst">$&#123;query ? query + '' :''&#125;</span>language:javascript`</span>,</span><br><span class="line">        language: <span class="string">'javascript'</span>,</span><br><span class="line">        page: pagination.page,</span><br><span class="line">        per_page: pagination.pageSize,</span><br><span class="line">        sort,</span><br><span class="line">        order: EOrder.Desc</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    distinctUntilChanged(isEqual)</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> action$.pipe(</span><br><span class="line">    ofType(LISTEN_POLLING_START, SEARCH),</span><br><span class="line">    combineLatest(params$, <span class="function">(<span class="params">action, params</span>) =&gt;</span> params),</span><br><span class="line">    switchMap(<span class="function">(<span class="params">params: ISearchParam</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> polling$ = merge(</span><br><span class="line">        interval(<span class="number">15</span> * <span class="number">1000</span>).pipe(</span><br><span class="line">          takeUntil(stopPolling$),</span><br><span class="line">          startWith(<span class="literal">null</span>),</span><br><span class="line">          switchMap(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">from</span>(fetch(params)).pipe(</span><br><span class="line">            map(<span class="function">(<span class="params">&#123;data&#125;: ISearchResp</span>) =&gt;</span> (&#123;</span><br><span class="line">              <span class="keyword">type</span>: FETCH_SUCCESS,</span><br><span class="line">              payload: &#123;</span><br><span class="line">                total: data.total_count,</span><br><span class="line">                list: data.items</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;)),</span><br><span class="line">            startWith(&#123;</span><br><span class="line">              <span class="keyword">type</span>: FETCH_START,</span><br><span class="line">              payload: &#123;&#125;</span><br><span class="line">            &#125;),</span><br><span class="line">            catchError(<span class="function">(<span class="params">error: AxiosError</span>) =&gt;</span> of(&#123;</span><br><span class="line">              <span class="keyword">type</span>: FETCH_ERROR,</span><br><span class="line">              payload: &#123;</span><br><span class="line">                error: error.response.statusText</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;))</span><br><span class="line">          )),</span><br><span class="line">          startWith(&#123;</span><br><span class="line">            <span class="keyword">type</span>: POLLING_START,</span><br><span class="line">            payload: &#123;&#125;</span><br><span class="line">          &#125;)</span><br><span class="line">      ))</span><br><span class="line">      <span class="keyword">return</span> polling$</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是对这个 Epic 的一些解释。</p><ul><li>首先我们声明轮询结束流，当轮询结束流有值产生时，轮询会被终止：</li></ul><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> stopPolling$ = action$.ofType(POLLING_STOP)</span><br></pre></td></tr></table></figure><ul><li>参数来源于状态，由于现在状态可观测，我们可以从状态流 <code>state$</code> 派发一个下游 —— <strong> 参数流 </strong>：</li></ul><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> params$: Observable&lt;ISearchParam&gt; = state$.pipe(</span><br><span class="line">  map(<span class="function">(<span class="params">&#123;user&#125;: &#123;user: IState&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; pagination, sort, query &#125; = user</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">// 构造参数 </span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;),</span><br><span class="line">  distinctUntilChanged(isEqual)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><blockquote><p>我们预期参数流都是最新的参数，因此使用了 <code>dinstinctUntilChanged(isEqual)</code> 来判断两次参数的异同</p></blockquote><ul><li>主动进行搜索，或者参数变动时，将创建轮询流（借助到了 <code>combineLatest</code> operator），最终，新的 action 仰仗于数据拉取结果：</li></ul><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> action$.pipe(</span><br><span class="line">  ofType(LISTEN_POLLING_START, SEARCH),</span><br><span class="line">  combineLatest(params$, <span class="function">(<span class="params">action, params</span>) =&gt;</span> params),</span><br><span class="line">  switchMap(<span class="function">(<span class="params">params: ISearchParam</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> polling$ = merge(</span><br><span class="line">      interval(<span class="number">15</span> * <span class="number">1000</span>).pipe(</span><br><span class="line">        takeUntil(stopPolling$),</span><br><span class="line">        <span class="comment">// 自动开始轮询 </span></span><br><span class="line">        startWith(<span class="literal">null</span>),</span><br><span class="line">        switchMap(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">from</span>(fetch(params)).pipe(</span><br><span class="line">          map(<span class="function">(<span class="params">&#123;data&#125;: ISearchResp</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// ... 处理响应 </span></span><br><span class="line">          &#125;),</span><br><span class="line">          startWith(&#123;</span><br><span class="line">            <span class="keyword">type</span>: FETCH_START,</span><br><span class="line">            payload: &#123;&#125;</span><br><span class="line">          &#125;),</span><br><span class="line">          catchError(<span class="function">(<span class="params">error: AxiosError</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">          &#125;)</span><br><span class="line">        )),</span><br><span class="line">        startWith(&#123;</span><br><span class="line">          <span class="keyword">type</span>: POLLING_START,</span><br><span class="line">          payload: &#123;&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      ))</span><br><span class="line">    <span class="keyword">return</span> polling$</span><br><span class="line">  &#125;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>OK，我们现在 <strong> 只需要 </strong> 在数据表格这个容器组件挂载时 dispatch 一个 <code>LISTEN_POLLING_START</code> 事件，即可开始我们的轮询，在其对应的 Epic 中，它完全知道什么时候去结束轮询，什么时候去重启轮询。我们的分页组件，排序选择组件都不再需要关心重启轮询这个需求。例如分页组件的状态变动的 action 就只需要修改状态即可，而不用再去关注轮询：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">changePagination</span>(<span class="params">pagination: IPagination</span>): <span class="title">IAction</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="keyword">type</span>: CHANGE_PAGINATION,</span><br><span class="line">    payload: &#123;</span><br><span class="line">      pagination</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 FRP 模式下，passive 模型让我们观测了 state，声明了轮询的诱因，让轮询收归到了数据表格组件中， 解除了轮询和数据表格与分页，搜索，排序等组件的耦合。实现了数据表格的 <strong> 组件自治 </strong>。</p><p><img src="/2018/08/18/使用_redux-observable_实现组件自治/rxjs_redux_frp.png" alt=""></p><p>总结，利用 FRP 进行副作用处理带来了：</p><ul><li><strong> 声明式地（declarative）</strong> 描述异步任务，代码简洁</li><li>使用 <code>switchMap</code> operator 处理 <strong> 竞态 </strong> 任务</li><li>尽可能减少组件耦合，来达到 <strong> 组件自治 </strong>。利于多人协作的大型工程。</li></ul><p>其带来的利好算是拳拳打到了传统模式的痛处。下图是一个更直观的对比，同样的业务逻辑，靠上的是 redux-saga 实现，考下则是 redux-observable 实现。你一眼就能感受到谁更简洁明了：</p><p><img src="/2018/08/18/使用_redux-observable_实现组件自治/rxjs_redux_saga.jpg" alt=""></p><p><img src="/2018/08/18/使用_redux-observable_实现组件自治/rxjs_redux_observable.jpg" alt=""></p><h2 id="接入-redux-observable"><a href="#接入-redux-observable" class="headerlink" title="接入 redux-observable"></a>接入 redux-observable</h2><p>redux-observable 只是 redux 一个中间件，因此它可以和你现在的 redux-thunk，redux-saga 等共存，redux-observable 的作者你可以渐进地接入 redux-observable 去处理一些复杂的业务逻辑，当你基本熟悉了 RxJS 和 FRP 模式，你会发现它可以做一切。</p><p>后续，考虑到整个工程的风格控制，还是建议只选择一套模型，FRP 在复杂场景下表现力卓著，在简单场景下，也不会大炮打蚊子。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文叙述了如何 redux-observable 1.0 提供的 <code>state$</code>，解耦组件之间的业务关联，实现单个组件的业务自治。</p><p>接下来，将通过一步步实现一个类 redux-observable 中间件，向大家阐述 redux-observable 设计理念和实现原理。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://redux-observable.js.org/docs" target="_blank" rel="noopener">redux-observable official docs</a></li></ul><hr><h2 id="关于本系列"><a href="#关于本系列" class="headerlink" title="关于本系列"></a>关于本系列</h2><ul><li><p>本系列将从介绍 redux-observable 1.0 开始，阐述自己在结合 RxJS 到 Redux 中的心得体会。涉及内容会有 redux-observable 实践介绍，redux-observable 实现原理探究，最后会介绍下自己当前基于 redux-observble + dva architecture 的一个 state 管理框架 reobservable。</p></li><li><p>本系列不是 RxJS 或者 Redux 入门，不再讲述他们的基础概念，宣扬他们的核心优势。如果你搜索 RxJS 不小心进到了这个系列，对 RxJS 和 FRP 程序设计产生了兴趣，那么入门我会推荐：</p><ul><li><a href="https://www.learnrxjs.io/" target="_blank" rel="noopener">learnrxjs.io</a></li><li>Andre Staltz 在 <a href="https://egghead.io/courses/introduction-to-reactive-programming" target="_blank" rel="noopener">egghead.io</a> 上的一系列课程</li><li>程墨的 <a href="https://item.jd.com/12336101.html" target="_blank" rel="noopener">《深入浅出 RxJS》</a></li></ul></li><li><p>本系列更不是教程，只是介绍自己在 Redux 中应用 RxJS 的一些思路，希望更多人能指出当中存在的误区，或者交流更优雅的实践。</p></li><li><p>由衷的感谢实践路上一些师兄的帮助，尤其感谢腾讯云的 questguo 学长在模式上的指导。reobservable 脱胎于腾讯云 questguo 主导的 React 框架 —— TCFF，期待未来 TCFF 的开源。</p></li><li><p>感谢小雨的设计支援。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2018/08/18/使用_redux-observable_实现组件自治/cover.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;使用-redux-observable-实现组件自治&quot;&gt;&lt;a href=&quot;#使用-redux-observable-实现组件自治&quot; class=&quot;headerlink&quot; title=&quot;使用 redux-observable 实现组件自治&quot;&gt;&lt;/a&gt;使用 redux-observable 实现组件自治&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本文是 《使用 RxJS + Redux 管理应用状态》系列第一篇文章，旨在介绍 redux-obervable v1 版本为 React + Redux 带来的组件自治能力。&lt;/p&gt;
&lt;p&gt;本系列的文章地址汇总：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://yoyoyohamapi.me/2018/08/18/%E4%BD%BF%E7%94%A8_redux-observable_%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6%E8%87%AA%E6%B2%BB/&quot;&gt;使用 redux-observable 实现组件自治&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://yoyoyohamapi.me/2018/08/21/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA_redux-observable/&quot;&gt;如何实现一个 redux-observable&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="React" scheme="http://yoyoyohamapi.me/categories/React/"/>
    
    
      <category term="React" scheme="http://yoyoyohamapi.me/tags/React/"/>
    
      <category term="Redux" scheme="http://yoyoyohamapi.me/tags/Redux/"/>
    
      <category term="RxJS" scheme="http://yoyoyohamapi.me/tags/RxJS/"/>
    
  </entry>
  
  <entry>
    <title>callbag，一个有趣的规范</title>
    <link href="http://yoyoyohamapi.me/2018/02/14/callbag/"/>
    <id>http://yoyoyohamapi.me/2018/02/14/callbag/</id>
    <published>2018-02-14T09:23:00.000Z</published>
    <updated>2018-02-14T17:05:28.507Z</updated>
    
    <content type="html"><![CDATA[<h2 id="push-和-pull-模型"><a href="#push-和-pull-模型" class="headerlink" title="push 和 pull 模型"></a>push 和 pull 模型</h2><p>如果你了解 RxJs，在响应式编程中，Observable 和 Obsever 是 push 模型，与之对应的，还有一个 pull 模型：</p><p><img src="https://i.stack.imgur.com/HwvQv.png" alt=""></p><ul><li><strong>Pull（<code>f(): B</code>）</strong>：返回一个值。</li><li><strong>Push（<code>f(x: A): void</code>）</strong>：响应式的，当有值产生时，会发出一个事件，并携带上这个值。订阅了该事件的观察者（Observer）将获得反馈。</li></ul><p>JavaScript 中的 <code>Math.random()</code>、<code>window.outerHeight</code> 等都是 pull 模型：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> height = <span class="built_in">window</span>.outerHeight();</span><br><span class="line"><span class="comment">// 或者是迭代器写法 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">getWindowHeight</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="built_in">window</span>.outerHeight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> iter = getWindowHeight()</span><br><span class="line">iter.next()</span><br></pre></td></tr></table></figure><p>pull 模型包含两个部分：</p><ul><li><strong> 生产者 </strong>：负责生产数据，是数据源</li><li><strong> 消费者 </strong>：负责消费数据，是数据的使用方</li></ul><p>在 pull 模型中，数据是 <strong> 按需索取 </strong> 的。</p><p>再通过 RxJs 看一个 push 模型的例子：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Rx.Observable</span><br><span class="line">    .fromEvent(<span class="built_in">document</span>, <span class="string">'click'</span>)</span><br><span class="line">  .map(<span class="function"><span class="params">event</span> =&gt;</span> <span class="string">`Event time: <span class="subst">$&#123;event.timeStamp&#125;</span>`</span>)</span><br><span class="line">    .subscribe(<span class="function"><span class="keyword">function</span> <span class="title">observer</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>push 模型的组成包含了两个部分：</p><ul><li><strong> 可观察（可监听）对象 </strong>：是数据来源</li><li><strong> 观察者（监听者）</strong>：是数据的使用方</li></ul><p>与 pull 模型不同，观察者 <strong> 不能主动索取数据 </strong>，而是观察数据源，当数据源有数据时，才可消费和使用。</p><p>push 模型有这么一些优点：</p><ul><li><strong> 高度复用的可观察对象 </strong>：通过对源可观察对象使用不同的运算子，可构建出新的可观察对象。</li><li><strong> 延迟执行 </strong>：可观察对象只有被观察者订阅，才会派发数据。</li><li><strong> 声明式、描述未来的代码 </strong>：我们只用声明数据源和数据消费方式，而不用关心数据交付时的细节。</li></ul><p><a href="https://cycle.js.org/" target="_blank" rel="noopener">Cycle.js</a> 的作者 Andre Staltz 长久以来面对一个问题，Cycle.js 及其推荐使用的响应式编程库 <a href="https://github.com/staltz/xstream" target="_blank" rel="noopener">xstream</a> 都是 push 模型的，这让框架的模型和业务代码都受益于 push 模型的优点。但是，实际项目中，我们还是有不少 pull 模型下的需求，Andre Staltz 也开了一个 <a href="https://github.com/cyclejs/cyclejs/issues/581" target="_blank" rel="noopener">issue</a> ，讨论如何更好的使用代码描述 pull 模型。</p><a id="more"></a><h2 id="push-与-pull-可以是同型的"><a href="#push-与-pull-可以是同型的" class="headerlink" title="push 与 pull 可以是同型的"></a>push 与 pull 可以是同型的</h2><p>stalz 看到，我们的 Observable 和 Observer：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Observer &#123;</span><br><span class="line">  next(x): <span class="built_in">void</span>;</span><br><span class="line">  error(e): <span class="built_in">void</span>;</span><br><span class="line">  complete(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Observable &#123;</span><br><span class="line">  subscribe(observer): Subscription;</span><br><span class="line">  unsubsribe(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过函数进行描述：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observable</span>(<span class="params">msgType, msgPayload</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li><code>msgType == 0</code>：payload 是 observer，意味着 observer 向 observable 问好，需要订阅这个 observerble。（subscribe）</li><li><code>msgType == 1</code>：意味着 observer 将取消对 observable 的订阅。（unsubscribe）</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observer</span>(<span class="params">msgType, msgPayload</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>当：</p><ul><li><code>msgType == 1</code>：对应 <code>observer.next(payload)</code>，即 observable 交付数据给 observer，此时 payload 携带了数据。</li><li><code>msgType == 2</code> 且 payload 为 <code>undefined</code>：对应于 <code>observer.complete()</code>。</li><li><code>msgType == 2</code> 且 payload 含有值：对应于 <code>observer.error(payload)</code>，此时 payload 描述了错误。</li></ul><p>进一步概括就是：</p><p><strong>Observer</strong>:</p><ul><li><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">observer</span><span class="params">(<span class="number">1</span>, data)</span></span>: void</span><br></pre></td></tr></table></figure><ul><li>数据交付 ：observable 将数据交付给 observer</li></ul></li><li><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">observer</span><span class="params">(<span class="number">2</span>, err)</span></span>: void</span><br></pre></td></tr></table></figure><ul><li>出错：observable 将错误告知 observer</li></ul></li><li><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">observer</span><span class="params">(<span class="number">2</span>)</span></span>: void</span><br></pre></td></tr></table></figure><ul><li>完成：observable 不再有数据，告知 observer 任务完成</li></ul></li></ul><p><strong>Observable</strong>:</p><ul><li><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">observable</span><span class="params">(<span class="number">0</span>, observer)</span></span>: void</span><br></pre></td></tr></table></figure><ul><li>问好：observer 订阅了 observable</li></ul></li><li><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">observable</span><span class="params">(<span class="number">2</span>)</span></span>: void</span><br></pre></td></tr></table></figure><ul><li>结束：observer 取消对 observable 的订阅</li></ul></li></ul><p>这么概括下来，我们发现，pull 模型也可以进行类似的概括：</p><p><strong>Consumer</strong>：</p><ul><li><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">consumer</span><span class="params">(<span class="number">0</span>, producer)</span></span>: void</span><br></pre></td></tr></table></figure><ul><li>问好：<strong> 在 pull 模型中，producer 需要向 consumer 问好，告诉 consumer 有需要时，从哪里取值 </strong></li></ul></li><li><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">consumer</span><span class="params">(<span class="number">1</span>, data)</span></span>: void</span><br></pre></td></tr></table></figure><ul><li>数据交付：producer 将数据交付给 consumer</li></ul></li><li><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">consumer</span><span class="params">(<span class="number">2</span>, err)</span></span>: void</span><br></pre></td></tr></table></figure><ul><li>出错：producer 将错误告知 consumer</li></ul></li><li><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">consumer</span><span class="params">(<span class="number">2</span>)</span></span>: void</span><br></pre></td></tr></table></figure><ul><li>完成：producer 告知 consumer 任务已完成</li></ul></li></ul><p><strong>Producer</strong>：</p><ul><li><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">producer</span><span class="params">(<span class="number">0</span>, consumer)</span></span>: void</span><br></pre></td></tr></table></figure><ul><li>问好：consumer 确定和哪个 producer 交互</li></ul></li><li><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">producer</span><span class="params">(<span class="number">1</span>, data)</span></span>: void</span><br></pre></td></tr></table></figure><ul><li>数据交付：<strong> 在 pull 模型中，consumer 需要主动向 producer 取值 </strong></li></ul></li><li><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">producer</span><span class="params">(<span class="number">2</span>)</span></span>: void</span><br></pre></td></tr></table></figure><ul><li>结束：consumer 结束了和 producer 的交互</li></ul></li></ul><p>综上，我们发现，push 和 pull 模型是同型的（具有一样的角色和函数签名），因此，可以通过一个规范同时定义二者。</p><h2 id="callbag"><a href="#callbag" class="headerlink" title="callbag"></a>callbag</h2><p>staltz 为 push 和 pull 模型创建了一个名为 callbag 的 <a href="https://github.com/callbag/callbag" target="_blank" rel="noopener">规范</a>，这个规范的内容如下：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">type</span>: <span class="built_in">number</span>, payload?: <span class="built_in">any</span>) =&gt; <span class="built_in">void</span></span><br></pre></td></tr></table></figure><h3 id="定义（Defination）"><a href="#定义（Defination）" class="headerlink" title="定义（Defination）"></a>定义（Defination）</h3><ul><li>Callbag：一个函数，函数签名为： <code>(type: 0 | 1 | 2, payload?: any) =&gt; void</code></li><li>Greet：如果一个 callbag 以 <code>0</code> 为第一个参数被调用，我们就说 <code>该 callbag 被问好了</code>。此时函数执行的操作是： “向这个 callbag 问好”。</li><li>Deliver：如果一个 callbag 以 <code>1</code> 为第一个参数被调用，我们就说 “这个 callbag 正被交付数据”。此时函数执行的操作是：“交付数据给这个 callbag”。</li><li>Terminate：如果一个 callbag 以 <code>2</code> 为第一个参数被调用，我们就说 “这个 callbag 被终止了”。此时函数执行的操作是：“终止这个 callbag”。</li><li>Source：一个负责交付数据的 callbag。</li><li>Sink：一个负责接收（消费）数据的 callbag。</li></ul><h3 id="协议（Protocal）"><a href="#协议（Protocal）" class="headerlink" title="协议（Protocal）"></a>协议（Protocal）</h3><p><strong> 问好（Greets）</strong>: <code>(type: 0, cb: Callbag) =&gt; void</code></p><p>当第一个参数是 <code>0</code>，而第二个参数是另外一个 callbag（即一个函数）的时候，这个 callbag 就被问好了。</p><p><strong> 握手（Handshake）</strong></p><p>当一个 source 被问好，并被作为 payload 传递给了某个 sink，sink <strong> 必须 </strong> 使用一个 callbag payload 进行问好，这个 callbag 可以是他自己，也可以是另外的 callbag。换言之，问好是相互的。相互间的问好被称为 <strong> 握手 </strong>。</p><p><strong> 终止（Termination）</strong>: <code>(type: 2, err?: any) =&gt; void</code></p><p>当第一个参数是 <code>0</code>，而第二个参数要么是 undefined（由于成功引起的终止），要么是任何的真实值（由于失败引起的终止），这个 callbag 就被终止了。</p><p>在握手之后，source <strong> 可能 </strong> 终止掉 sink，sink 也 <strong> 可能 </strong> 会终止掉 source。如果 source 终止了 sink，则 sink <strong> 不应当 </strong> 终止 source，反之亦然。换言之，终止行为 <strong> 不应该 </strong> 是相互的。</p><p><strong> 数据交付（Data delivery）</strong> <code>(type: 1, data: any) =&gt; void</code></p><p>交付次数：</p><ul><li>一个 callbag（source 或者 sink）<strong> 可能 </strong> 会被一次或多次交付数据</li></ul><p>有效交付的窗口：</p><ul><li>一个 callbag <strong> 一定不能 </strong> 在被问好之前被交付数据</li><li>一个 callbag <strong> 一定不能 </strong> 在终止后被交付数据</li><li>一个 sink <strong> 一定不能 </strong> 在其终止了它的 source 后被交付数据</li></ul><h2 id="创建自己的-callbag"><a href="#创建自己的-callbag" class="headerlink" title="创建自己的 callbag"></a>创建自己的 callbag</h2><p>callbag 的组成可以简单归纳为：</p><ul><li>handshake：一次握手过程，source 和 sink 如何握手</li><li>talkback：对讲对象，sink 和 source 正在和谁沟通</li></ul><h3 id="listener（observer）sink"><a href="#listener（observer）sink" class="headerlink" title="listener（observer）sink"></a>listener（observer）sink</h3><ul><li><p><strong> 定义问好过程 </strong>：在问好阶段，可以知道在和谁对讲：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sink</span>(<span class="params">type, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (type === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// sink 收到了来自 source 的问好 </span></span><br><span class="line">    <span class="comment">// 问好的时候确定 source 和 sink 的对讲方式 </span></span><br><span class="line">    <span class="keyword">const</span> talkback = data;</span><br><span class="line">    <span class="comment">// 3s 后，sink 终止和 source 的对讲 </span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> talkback(<span class="number">2</span>), <span class="number">3000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong> 定义数据处理过程 </strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sink</span>(<span class="params">type, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (type === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> talkback = data;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> talkback(<span class="number">2</span>), <span class="number">3000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (type === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong> 定义结束过程 </strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> handle;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sink</span>(<span class="params">type, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (type === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> talkback = data;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> talkback(<span class="number">2</span>), <span class="number">3000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (type === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (type === <span class="number">2</span>) &#123;</span><br><span class="line">        clearTimeout(handle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以再用工厂函数让代码干净一些：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeSink</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> handle;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">sink</span>(<span class="params">type, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (type === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> talkback = data;</span><br><span class="line">      handle = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> talkback(<span class="number">2</span>), <span class="number">3000</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (type === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (type === <span class="number">2</span>) &#123;</span><br><span class="line">      clearTimeout(handle);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="puller（consumer）sink"><a href="#puller（consumer）sink" class="headerlink" title="puller（consumer）sink"></a>puller（consumer）sink</h3><p>puller sink 则可以向 source 主动请求数据：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> handle;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sink</span>(<span class="params">type, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (type === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> talkback = data;</span><br><span class="line">        setInterval(<span class="function"><span class="params">()</span> =&gt;</span> talkback(<span class="number">1</span>), <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (type === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (type === <span class="number">2</span>) &#123;</span><br><span class="line">        clearTimeout(handle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="listenable（observable）source"><a href="#listenable（observable）source" class="headerlink" title="listenable（observable）source"></a>listenable（observable）source</h3><ul><li><p>定义问好过程：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">source</span>(<span class="params">type, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (type === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果 source 收到 sink 的问好，</span></span><br><span class="line">    <span class="comment">// 则 payload 即为 sink，source 可以向 sink 发送数据了 </span></span><br><span class="line">    <span class="keyword">const</span> sink = data;</span><br><span class="line">    setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      sink(<span class="number">1</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 让 source 也和 sink 问好，完成一次握手 </span></span><br><span class="line">  sink(<span class="number">0</span>, <span class="comment">/* talkback callbag here */</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当 sink 想要停止观察，需要让 source 有处理停止的能力，另外，listenable 的 source 不会理会 sink 主动的数据索取。因此，我们这么告知 sink 沟通方式：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">source</span>(<span class="params">type, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (type === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> sink = data;</span><br><span class="line">        <span class="keyword">let</span> handle = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            sink(<span class="number">1</span>, <span class="literal">null</span>);</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> talkback = <span class="function">(<span class="params">type, data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (type === <span class="number">2</span>) &#123;</span><br><span class="line">            clearInterval(handle);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    sink(<span class="number">0</span>, talkback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>优化一下代码可读性：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">source</span>(<span class="params">start, sink</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (start !== <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">let</span> handle = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    sink(<span class="number">1</span>, <span class="literal">null</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">const</span> talkback = <span class="function">(<span class="params">t, d</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (t === <span class="number">2</span>) clearInterval(handle);</span><br><span class="line">  &#125;;</span><br><span class="line">  sink(<span class="number">0</span>, talkback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="pullable（iterable）source"><a href="#pullable（iterable）source" class="headerlink" title="pullable（iterable）source"></a>pullable（iterable）source</h3><p>pullable source 中，值时按照 sink 的需要获取的，因此，只有在 sink 索取值时，source 才需要交付数据：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">source</span>(<span class="params">start, sink</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start !== <span class="number">0</span>) retrun;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">const</span> talkback = <span class="function">(<span class="params">t, d</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= <span class="number">20</span>) sink(<span class="number">1</span>, i++);</span><br><span class="line">            <span class="keyword">else</span> sink(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sink(<span class="number">0</span>, talkback)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建运算子"><a href="#创建运算子" class="headerlink" title="创建运算子"></a>创建运算子</h2><p>借助于 operator，能够不断的构建新的 source，operator 的一般范式为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myOperator = <span class="function"><span class="params">args</span> =&gt;</span> inputSource =&gt; outputSource</span><br></pre></td></tr></table></figure><p>借助于管道技术，我们能一步步的声明新的 source：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">pipe(</span><br><span class="line">  source,</span><br><span class="line">  myOperator(args),</span><br><span class="line">  iterate(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x))</span><br><span class="line">)</span><br><span class="line"><span class="comment">// same as...</span></span><br><span class="line">pipe(</span><br><span class="line">  source,</span><br><span class="line">  inputSource =&gt; outputSource,</span><br><span class="line">  iterate(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x))</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>下面我们创建了一个乘法 operator：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> multiplyBy = <span class="function"><span class="params">factor</span> =&gt;</span> inputSource =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">outputSource</span>(<span class="params">start, outputSink</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start !== <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        inputSource(start, (type, data) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (type === <span class="number">1</span>) &#123;</span><br><span class="line">                outputSink(<span class="number">1</span>, data * factor);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                outputSink(<span class="number">1</span>, data * factor);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">source</span>(<span class="params">start, sink</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start !== <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> handle = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> sink(<span class="number">1</span>, i++), <span class="number">3000</span>);</span><br><span class="line">    <span class="keyword">const</span> talkback = <span class="function">(<span class="params">type, data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (type === <span class="number">2</span>) &#123;</span><br><span class="line">            clearInterval(handle);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sink(<span class="number">0</span>, talkback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> timeout;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sink</span>(<span class="params">type, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (type === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> talkback = data;</span><br><span class="line">        timetout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> talback(<span class="number">2</span>), <span class="number">9000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (type === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'data is'</span>, data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (type === <span class="number">2</span>) &#123;</span><br><span class="line">        clearTimeout(handle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newSource = multiplyBy(<span class="number">3</span>)(source);</span><br><span class="line">newSource(<span class="number">0</span>, sink);</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过 callbag ，我们可以近乎一致的处理 <strong> 数据源和数据源的消费 </strong>：</p><p>例如，下面是 listenable 数据源，我们用 <code>forEach</code> 消费：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;forEach, fromEvent, map, filter, pipe&#125; = <span class="built_in">require</span>(<span class="string">'callbag-basics'</span>);</span><br><span class="line"></span><br><span class="line">pipe(</span><br><span class="line">  fromEvent(<span class="built_in">document</span>, <span class="string">'click'</span>),</span><br><span class="line">  filter(<span class="function"><span class="params">ev</span> =&gt;</span> ev.target.tagName === <span class="string">'BUTTON'</span>),</span><br><span class="line">  map(<span class="function"><span class="params">ev</span> =&gt;</span> (&#123;<span class="attr">x</span>: ev.clientX, <span class="attr">y</span>: ev.clientY&#125;)),</span><br><span class="line">  forEach(<span class="function"><span class="params">coords</span> =&gt;</span> <span class="built_in">console</span>.log(coords))</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>下面则是 pullable 数据源，我们仍可以用 <code>forEach</code> 进行消费：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;forEach, fromIter, take, map, pipe&#125; = <span class="built_in">require</span>(<span class="string">'callbag-basics'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">getRandom</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="built_in">Math</span>.random();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pipe(</span><br><span class="line">  fromIter(getRandom()),</span><br><span class="line">  take(<span class="number">5</span>),</span><br><span class="line">  forEach(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x))</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://staltz.com/why-we-need-callbags.html" target="_blank" rel="noopener">WHY WE NEED CALLBAGS</a></li><li><a href="https://github.com/callbag/callbag" target="_blank" rel="noopener">callbag</a></li><li><a href="https://github.com/callbag/callbag/blob/master/getting-started.md" target="_blank" rel="noopener">Creating your own utilities</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;push-和-pull-模型&quot;&gt;&lt;a href=&quot;#push-和-pull-模型&quot; class=&quot;headerlink&quot; title=&quot;push 和 pull 模型&quot;&gt;&lt;/a&gt;push 和 pull 模型&lt;/h2&gt;&lt;p&gt;如果你了解 RxJs，在响应式编程中，Observable 和 Obsever 是 push 模型，与之对应的，还有一个 pull 模型：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.stack.imgur.com/HwvQv.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Pull（&lt;code&gt;f(): B&lt;/code&gt;）&lt;/strong&gt;：返回一个值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Push（&lt;code&gt;f(x: A): void&lt;/code&gt;）&lt;/strong&gt;：响应式的，当有值产生时，会发出一个事件，并携带上这个值。订阅了该事件的观察者（Observer）将获得反馈。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;JavaScript 中的 &lt;code&gt;Math.random()&lt;/code&gt;、&lt;code&gt;window.outerHeight&lt;/code&gt; 等都是 pull 模型：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; height = &lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.outerHeight();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 或者是迭代器写法 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;* &lt;span class=&quot;title&quot;&gt;getWindowHeight&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.outerHeight;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; iter = getWindowHeight()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;iter.next()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;pull 模型包含两个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt; 生产者 &lt;/strong&gt;：负责生产数据，是数据源&lt;/li&gt;
&lt;li&gt;&lt;strong&gt; 消费者 &lt;/strong&gt;：负责消费数据，是数据的使用方&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 pull 模型中，数据是 &lt;strong&gt; 按需索取 &lt;/strong&gt; 的。&lt;/p&gt;
&lt;p&gt;再通过 RxJs 看一个 push 模型的例子：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Rx.Observable&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    .fromEvent(&lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;click&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  .map(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;event&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;`Event time: &lt;span class=&quot;subst&quot;&gt;$&amp;#123;event.timeStamp&amp;#125;&lt;/span&gt;`&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    .subscribe(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;observer&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;val&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(val);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;push 模型的组成包含了两个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt; 可观察（可监听）对象 &lt;/strong&gt;：是数据来源&lt;/li&gt;
&lt;li&gt;&lt;strong&gt; 观察者（监听者）&lt;/strong&gt;：是数据的使用方&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;与 pull 模型不同，观察者 &lt;strong&gt; 不能主动索取数据 &lt;/strong&gt;，而是观察数据源，当数据源有数据时，才可消费和使用。&lt;/p&gt;
&lt;p&gt;push 模型有这么一些优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt; 高度复用的可观察对象 &lt;/strong&gt;：通过对源可观察对象使用不同的运算子，可构建出新的可观察对象。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt; 延迟执行 &lt;/strong&gt;：可观察对象只有被观察者订阅，才会派发数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt; 声明式、描述未来的代码 &lt;/strong&gt;：我们只用声明数据源和数据消费方式，而不用关心数据交付时的细节。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://cycle.js.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Cycle.js&lt;/a&gt; 的作者 Andre Staltz 长久以来面对一个问题，Cycle.js 及其推荐使用的响应式编程库 &lt;a href=&quot;https://github.com/staltz/xstream&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;xstream&lt;/a&gt; 都是 push 模型的，这让框架的模型和业务代码都受益于 push 模型的优点。但是，实际项目中，我们还是有不少 pull 模型下的需求，Andre Staltz 也开了一个 &lt;a href=&quot;https://github.com/cyclejs/cyclejs/issues/581&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;issue&lt;/a&gt; ，讨论如何更好的使用代码描述 pull 模型。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript 函数式编程" scheme="http://yoyoyohamapi.me/categories/JavaScript-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="JavaScript" scheme="http://yoyoyohamapi.me/tags/JavaScript/"/>
    
      <category term="函数式编程" scheme="http://yoyoyohamapi.me/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Cycle.js 基础 21 讲</title>
    <link href="http://yoyoyohamapi.me/2017/07/30/Cycle.js%20%E5%9F%BA%E7%A1%80%2021%20%E8%AE%B2/"/>
    <id>http://yoyoyohamapi.me/2017/07/30/Cycle.js 基础 21 讲/</id>
    <published>2017-07-30T05:43:00.000Z</published>
    <updated>2018-08-24T16:07:38.206Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.gitbook.com/book/fepatients/cycle-js-21/details" target="_blank" rel="noopener">Gitbook</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.gitbook.com/book/fepatients/cycle-js-21/details&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Gitbook&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="Cycle.js" scheme="http://yoyoyohamapi.me/categories/Cycle-js/"/>
    
    
      <category term="JavaScript" scheme="http://yoyoyohamapi.me/tags/JavaScript/"/>
    
      <category term="函数式编程" scheme="http://yoyoyohamapi.me/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Cycle.js" scheme="http://yoyoyohamapi.me/tags/Cycle-js/"/>
    
  </entry>
  
  <entry>
    <title>2017.03 - 2017.08 的学习总结</title>
    <link href="http://yoyoyohamapi.me/2017/07/27/2017_03-2017_08%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>http://yoyoyohamapi.me/2017/07/27/2017_03-2017_08学习总结/</id>
    <published>2017-07-27T02:48:00.000Z</published>
    <updated>2018-02-14T17:00:29.237Z</updated>
    
    <content type="html"><![CDATA[<p>从今年三月份开始，我在前端的学习路径是：</p><ol><li>JavaScript 函数式编程（Lisp、Haskell 开发者轻喷）</li><li>函数响应式编程：FRP，这一块主要是以学习 Rxjs 为主</li><li>函数式编程和函数响应式编程的应用：这一块主要是以学习 Cycle.js 为主</li></ol><a id="more"></a><p>期间完成过、或者正在完成的一些内容有，这当中有一部分是和我所在前端学习小组 –<a href="https://github.com/FEPatients" target="_blank" rel="noopener">前端病人</a> 一起完成的：</p><ol><li><a href="https://github.com/FEPatients/js-functional-programming-minibook" target="_blank" rel="noopener">JavaScript 函数式编程手札（未完）</a></li><li><a href="https://github.com/FEPatients/with-or-without-fp" target="_blank" rel="noopener">With or without fp – 用函数式编程重构代码</a></li><li><a href="https://www.gitbook.com/book/fepatients/cycle-js-21" target="_blank" rel="noopener">Cycle.js 基础 21 讲</a></li><li><a href="https://fepatients.gitbooks.io/-rxjs-subject/content/" target="_blank" rel="noopener">深入 RxJS 的 Subject</a></li><li><a href="https://github.com/yoyoyohamapi/cyclejs-modal-demo" target="_blank" rel="noopener">Cycle.js 实现一个 Modal</a></li><li><a href="https://github.com/yoyoyohamapi/cyclejs-todomvc" target="_blank" rel="noopener">Cycle.js 实现一个 TodoMvc</a></li><li>使用 Cycle.js 完成了鹅厂封陪 Mini 项目中 Web 前端部分，算是一个有体积的应用了</li></ol><p>这五个月的产出的内容达到了我预设的目标，毕竟在此期间，我还要照顾自己的硕士毕业论文，以及填坑自己的另外一本 Gitbook：<a href="https://www.gitbook.com/book/yoyoyohamapi/mit-ml/details" target="_blank" rel="noopener">斯坦福机器学习笔记</a></p><p>去年分析 underscore 源码、redux 源码，算是把我带入了 JavaScript 函数式编程的大门。函数式编程起码从语法风格来说，会是大势，它未必需要深入的 <a href="https://www.gitbook.com/book/drboolean/mostly-adequate-guide" target="_blank" rel="noopener">mostly-adequate-guide</a> 中的定义各个 Functor 或者 Monad，但是 pure function，pointfree，curring，compose 这些优良特性带来了 Eric Elliot 大神提出的 <strong> 组合式软件编写 </strong>。在目前的一些工程中，我都受益于组合式软件编写，逻辑和副作用开始分离，更多的函数通过基本的函数线性组合产生，我的业务代码，我的工具函数包都变得更加可靠和易于测试。逐渐，我开始用 pointfree 的 ramda 替换掉 pointful 的 lodash。</p><p>七月份最大的兴奋除了正式入职，就是看到了 Cycle.js 中文社区的建立，自己也能加入进去。我一直都更喜欢团队作战，一方面，团队能够约束我个人，不浮躁，另一方面，团队的技术圈子可以带来交流，可以带来目标。技术本就不应该冷静，因为团队，它会变得像人一样火热，即便它会遭受潮水般的质疑，那也胜过人变得冷漠，技术被不闻不问，在冷静中死掉。</p><p>接下来，会首先总结一下这次 Cycle.js 在 Mini 项目中的实战记录，不同于从 jQuery 过渡到 Vue 或者 React 时的小激动，Cycle.js 给了我更多的兴奋点，在使用 Cycle.js 构建前端应用的时候，思路和实现都可以说是颠覆式的。我需要记录下这次过程，希望能分享给他人，也防止记性不好的我再踩一些同样的坑。</p><p>之后，会一直跟进 Cycle.js，跟进 stalz 的动作，跟进 Cycle 中文社区其他的小伙伴，加油。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从今年三月份开始，我在前端的学习路径是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;JavaScript 函数式编程（Lisp、Haskell 开发者轻喷）&lt;/li&gt;
&lt;li&gt;函数响应式编程：FRP，这一块主要是以学习 Rxjs 为主&lt;/li&gt;
&lt;li&gt;函数式编程和函数响应式编程的应用：这一块主要是以学习 Cycle.js 为主&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="JavaScript 函数式编程" scheme="http://yoyoyohamapi.me/categories/JavaScript-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="JavaScript" scheme="http://yoyoyohamapi.me/tags/JavaScript/"/>
    
      <category term="函数式编程" scheme="http://yoyoyohamapi.me/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>斯坦福机器学习笔记</title>
    <link href="http://yoyoyohamapi.me/2017/04/29/%E6%96%AF%E5%9D%A6%E7%A6%8F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoyoyohamapi.me/2017/04/29/斯坦福机器学习笔记/</id>
    <published>2017-04-29T03:45:13.000Z</published>
    <updated>2018-02-14T17:01:25.708Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>系列文章已发布至 <a href="https://www.gitbook.com/book/yoyoyohamapi/mit-ml" target="_blank" rel="noopener">Gitbook</a></p></blockquote><p>本书为斯坦福吴恩达教授的在 coursera 上的 <a href="https://zh.coursera.org/learn/machine-learning" target="_blank" rel="noopener">机器学习公开课</a> 的知识笔记，涵盖了大部分课上涉及到的知识点和内容，因为篇幅有限，部分公式的推导没有记录在案，但推荐大家还是在草稿本上演算一遍，加深印象，知其然还要知其所以然。</p><p>本书涉及到的程序代码均放在了我个人的 <a href="https://github.com/yoyoyohamapi/mit-ml" target="_blank" rel="noopener">github</a> 上，采用了 python 实现，大部分代码都是相关学习算法的完整实现和测试。我没有放这门课程的 homework 代码，原因是 homework 布置的编程作业是填空式的作业，而完整实现一个算法虽然历经更多坎坷，但更有助于检验自己对算法理解和掌握程度。</p><div style="text-align:center"><br><img src="https://yoyoyohamapi.gitbooks.io/mit-ml/content/%E8%AF%81%E4%B9%A6.jpg" width="350"><br></div><a id="more"></a><p>本书的章节安排与课程对应关系为：</p><table><thead><tr><th style="text-align:left">斯坦福课程</th><th style="text-align:left">本书章节</th></tr></thead><tbody><tr><td style="text-align:left">Week 2</td><td style="text-align:left">线性回归</td></tr><tr><td style="text-align:left">Week 3</td><td style="text-align:left">逻辑回归</td></tr><tr><td style="text-align:left">Week 4-5</td><td style="text-align:left">神经网络</td></tr><tr><td style="text-align:left">Week 6</td><td style="text-align:left">算法分析与优化</td></tr><tr><td style="text-align:left">Week 7</td><td style="text-align:left">SVM（支持向量机）</td></tr><tr><td style="text-align:left">Week 8</td><td style="text-align:left">K-Means、特征降维</td></tr><tr><td style="text-align:left">Week 9</td><td style="text-align:left">异常检测、推荐系统</td></tr><tr><td style="text-align:left">Week 10</td><td style="text-align:left">大规模机器学习</td></tr><tr><td style="text-align:left">Week 11</td><td style="text-align:left">案例 – 光学字符识别</td></tr></tbody></table><p>学生我才疏学浅，对机器学习也只是刚刚入门，文中难免不少纰漏甚至严重错误，希望大家指正，这是对我最大的帮助。本书最大的目的也在于交流学习，而不在 star 和传播。任重而道远，你我共勉。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;系列文章已发布至 &lt;a href=&quot;https://www.gitbook.com/book/yoyoyohamapi/mit-ml&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Gitbook&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本书为斯坦福吴恩达教授的在 coursera 上的 &lt;a href=&quot;https://zh.coursera.org/learn/machine-learning&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;机器学习公开课&lt;/a&gt; 的知识笔记，涵盖了大部分课上涉及到的知识点和内容，因为篇幅有限，部分公式的推导没有记录在案，但推荐大家还是在草稿本上演算一遍，加深印象，知其然还要知其所以然。&lt;/p&gt;
&lt;p&gt;本书涉及到的程序代码均放在了我个人的 &lt;a href=&quot;https://github.com/yoyoyohamapi/mit-ml&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;github&lt;/a&gt; 上，采用了 python 实现，大部分代码都是相关学习算法的完整实现和测试。我没有放这门课程的 homework 代码，原因是 homework 布置的编程作业是填空式的作业，而完整实现一个算法虽然历经更多坎坷，但更有助于检验自己对算法理解和掌握程度。&lt;/p&gt;
&lt;div style=&quot;text-align:center&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://yoyoyohamapi.gitbooks.io/mit-ml/content/%E8%AF%81%E4%B9%A6.jpg&quot; width=&quot;350&quot;&gt;&lt;br&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://yoyoyohamapi.me/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://yoyoyohamapi.me/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>一步步写一个 co</title>
    <link href="http://yoyoyohamapi.me/2017/02/03/%E4%B8%80%E6%AD%A5%E6%AD%A5%E5%86%99%E4%B8%80%E4%B8%AA-co/"/>
    <id>http://yoyoyohamapi.me/2017/02/03/一步步写一个-co/</id>
    <published>2017-02-03T11:29:34.000Z</published>
    <updated>2018-02-14T17:01:30.865Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>文章已发布至 <a href="https://www.gitbook.com/book/yoyoyohamapi/-co/details" target="_blank" rel="noopener">GitBook</a></p></blockquote><p>现在，我们有三个 markdown 文件 file1.md,file2.md,file3.md，我们想要统计这三个文件的大小信息，并输出为以下格式：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">file1</span>: <span class="number">5384</span>, <span class="attr">file2</span>: <span class="number">2712</span>, <span class="attr">file3</span>: <span class="number">13942</span>&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>从最传统的回调开始，我们不断优化解决该问题的方式，最后完成了一个简化版的 <a href="https://github.com/tj/co/tree/2.0.0" target="_blank" rel="noopener">co V2</a>，实现了用更优雅地方式来组织和编写异步流程。</p><blockquote><p>本文对应的项目地址，包含了文中所有涉及到的代码片: <a href="https://github.com/yoyoyohamapi/write-a-co" target="_blank" rel="noopener">戳我</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;文章已发布至 &lt;a href=&quot;https://www.gitbook.com/book/yoyoyohamapi/-co/details&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitBook&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在，我们有三个 markdown 文件 file1.md,file2.md,file3.md，我们想要统计这三个文件的大小信息，并输出为以下格式：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;span class=&quot;attr&quot;&gt;file1&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;5384&lt;/span&gt;, &lt;span class=&quot;attr&quot;&gt;file2&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;2712&lt;/span&gt;, &lt;span class=&quot;attr&quot;&gt;file3&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;13942&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="一步步写一个 co" scheme="http://yoyoyohamapi.me/categories/%E4%B8%80%E6%AD%A5%E6%AD%A5%E5%86%99%E4%B8%80%E4%B8%AA-co/"/>
    
    
      <category term="JavaScript" scheme="http://yoyoyohamapi.me/tags/JavaScript/"/>
    
      <category term="co" scheme="http://yoyoyohamapi.me/tags/co/"/>
    
      <category term="ES6" scheme="http://yoyoyohamapi.me/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>underscore 源码分析</title>
    <link href="http://yoyoyohamapi.me/2017/01/01/underscore-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoyoyohamapi.me/2017/01/01/underscore-源码分析/</id>
    <published>2017-01-01T01:19:53.000Z</published>
    <updated>2018-02-14T17:02:24.123Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>文章已发布至 <a href="https://www.gitbook.com/book/yoyoyohamapi/undersercore-analysis" target="_blank" rel="noopener">GitBook</a></p></blockquote><h2 id="写作意图"><a href="#写作意图" class="headerlink" title="写作意图"></a>写作意图</h2><p>起初，我分析 underscore 的源码只是想更深入的了解 <strong> 函数式编程（Functional Programming）</strong>，但分析结束后，我就觉得单纯的源码注释不足以记录我的收获、理解和感悟，所以我想把这些写下来，我粗略地将写作意图概括如下：</p><ul><li><p>函数式编程近些年非常火爆，诸如 haskwell 这样的纯函数式编程语言获得了非常高的社区活跃度。JavaScript 支持多范式编程，抛开 underscore 和 lodash 这样的生来为了函数编程的库不谈，诸如 <a href="https://github.com/reactjs/redux" target="_blank" rel="noopener">redux</a> 这样的库也大量运用了函数式编程，即便作为一个 react+redux 的业务开发者，想要深入理解的 redux 的实现机制，也不得不学习函数式编程。因此，学习函数式编程，将会成为 JavaScript 开发者的必须。</p><p>   在阅读 underscore 的源码期间，被作者 jashkenas（他同时也是 backbone 和 coffee 的作者）的功力深深折服，一些功能可能我也能写出，但绝对写不了如此健壮。所以，深入学习 underscore 源码，不仅有助于我们认识函数式编程，也能深化我们对于 JavaScript 中一些基础知识的理解和掌握。</p><p>   随着 backbone 的衰落和 lodash 的崛起，underscore 的热度已经不及当年，但是截止这篇文章的开始前的一个月，underscore 仍然有最新的 bug 修复，可见作者 jashkenas 仍然没有放弃 underscore 的维护。所以现在分析 underscore 的源码仍然不显得过时。相较于 lodash，underscore 的源码更加短小，也不太涉及 JavaScript 中的一些奇淫巧技，所以，分析 underscore 更加适合 JavaScript 开发者的进阶。在完成了 underscore 的源码分析后，希望我自己有时间，也希望读者有意愿再去分析 lodash 的源码，后者在性能和功能上都已经超越了 underscore，并且长时间霸占了 npm 了最热 package 的位置。</p></li></ul><a id="more"></a><h2 id="章节安排"><a href="#章节安排" class="headerlink" title="章节安排"></a>章节安排</h2><h3 id="underscore-基础篇"><a href="#underscore-基础篇" class="headerlink" title="underscore 基础篇"></a><a href="https://yoyoyohamapi.gitbooks.io/undersercore-analysis/content/base/" target="_blank" rel="noopener">underscore 基础篇</a></h3><p>在基础部分，将会阐述 underscore 的大致结构及一些广泛用到的内部函数（internal function），这些函数被大量用到了 underscore 的 API 实现中，是我们之后理解 underscore 源码的必须途径。</p><p>之后，我们按照官方 API 文档的顺序来阐述 underscore 的源码实现，由于很多 API 的实现可以举一反三，所以，本书并不会啰嗦的阐述每个 API 的实现，如果真的由此需求，可以配合我写的 <a href="https://github.com/yoyoyohamAPI/underscore/blob/master/underscore.analysis.js" target="_blank" rel="noopener">underscore 中文注释</a> 辅助阅读。</p><h3 id="underscore-集合篇"><a href="#underscore-集合篇" class="headerlink" title="underscore 集合篇"></a><a href="https://yoyoyohamapi.gitbooks.io/undersercore-analysis/content/collection/" target="_blank" rel="noopener">underscore 集合篇</a></h3><p>不同于数学当中的集合，在 underscore 中，简单地定义集合为 <strong> 一个可迭代的序列 </strong>，相较于原生的 ES5 提供的迭代方法，underscore 不仅能够对数组进行迭代，还能够对对象进行迭代。</p><h3 id="underscore-数组篇"><a href="#underscore-数组篇" class="headerlink" title="underscore 数组篇"></a><a href="https://yoyoyohamapi.gitbooks.io/undersercore-analysis/content/array/" target="_blank" rel="noopener">underscore 数组篇</a></h3><p>这一章节我们将介绍 underscore 中提供的针对数组的操作，部分 API 已经在集合篇中有过阐述，不再赘述。</p><h3 id="underscore-函数篇"><a href="#underscore-函数篇" class="headerlink" title="underscore 函数篇"></a><a href="https://yoyoyohamapi.gitbooks.io/undersercore-analysis/content/function/" target="_blank" rel="noopener">underscore 函数篇</a></h3><p>在 JavaScript 中，函数是第一型的对象，函数在 JavaScript 中的地位因此可见一斑。这一章节也是我认为最为重要的一章，在本章中，能够见到许多实用的针对函数的操作，以及函数式编程中的重要概念。</p><h3 id="underscore-对象篇"><a href="#underscore-对象篇" class="headerlink" title="underscore 对象篇"></a><a href="https://yoyoyohamapi.gitbooks.io/undersercore-analysis/content/object/" target="_blank" rel="noopener">underscore 对象篇</a></h3><p>本章中，将介绍 underscore 中操作对象的 API。</p><h3 id="underscore-实用工具篇"><a href="#underscore-实用工具篇" class="headerlink" title="underscore 实用工具篇"></a><a href="https://yoyoyohamapi.gitbooks.io/undersercore-analysis/content/utils/" target="_blank" rel="noopener">underscore 实用工具篇</a></h3><p>underscore 还提供了不少工具函数，来提供一些周边功能，如字符逃逸等。但其中最重要的是其提供的模板引擎工具，我将会花费很大笔墨对其进行描述。</p><h3 id="underscore-内容拾遗"><a href="#underscore-内容拾遗" class="headerlink" title="underscore 内容拾遗"></a><a href="https://yoyoyohamapi.gitbooks.io/undersercore-analysis/content/supply/" target="_blank" rel="noopener">underscore 内容拾遗</a></h3><p>最后，在收尾阶段，我们还会介绍 underscore 提供的面向对象风格（OOP Style），链式调用（Chain）等内容。</p><h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><p>本文基于 underscore 的 <a href="https://github.com/jashkenas/underscore/tree/1.8.3" target="_blank" rel="noopener">1.8.3 版本</a> 进行分析, 在阅读官方文档时遇到的困难时，特别感谢 <a href="http://www.css88.com/doc/underscore/" target="_blank" rel="noopener">underscore 中文教程</a> 提供的帮助。</p><blockquote><p>欢迎转载或者引用，但请注明出处，这算是对我工作成果的认可和尊重。也欢迎拍砖，相应问题可以发到 <a href="https://www.gitbook.com/book/yoyoyohamAPI/undersercore-analysis/discussions" target="_blank" rel="noopener">discussion</a>，我会最快时间进行更正或者解答。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;文章已发布至 &lt;a href=&quot;https://www.gitbook.com/book/yoyoyohamapi/undersercore-analysis&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitBook&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;写作意图&quot;&gt;&lt;a href=&quot;#写作意图&quot; class=&quot;headerlink&quot; title=&quot;写作意图&quot;&gt;&lt;/a&gt;写作意图&lt;/h2&gt;&lt;p&gt;起初，我分析 underscore 的源码只是想更深入的了解 &lt;strong&gt; 函数式编程（Functional Programming）&lt;/strong&gt;，但分析结束后，我就觉得单纯的源码注释不足以记录我的收获、理解和感悟，所以我想把这些写下来，我粗略地将写作意图概括如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;函数式编程近些年非常火爆，诸如 haskwell 这样的纯函数式编程语言获得了非常高的社区活跃度。JavaScript 支持多范式编程，抛开 underscore 和 lodash 这样的生来为了函数编程的库不谈，诸如 &lt;a href=&quot;https://github.com/reactjs/redux&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;redux&lt;/a&gt; 这样的库也大量运用了函数式编程，即便作为一个 react+redux 的业务开发者，想要深入理解的 redux 的实现机制，也不得不学习函数式编程。因此，学习函数式编程，将会成为 JavaScript 开发者的必须。&lt;/p&gt;
&lt;p&gt;   在阅读 underscore 的源码期间，被作者 jashkenas（他同时也是 backbone 和 coffee 的作者）的功力深深折服，一些功能可能我也能写出，但绝对写不了如此健壮。所以，深入学习 underscore 源码，不仅有助于我们认识函数式编程，也能深化我们对于 JavaScript 中一些基础知识的理解和掌握。&lt;/p&gt;
&lt;p&gt;   随着 backbone 的衰落和 lodash 的崛起，underscore 的热度已经不及当年，但是截止这篇文章的开始前的一个月，underscore 仍然有最新的 bug 修复，可见作者 jashkenas 仍然没有放弃 underscore 的维护。所以现在分析 underscore 的源码仍然不显得过时。相较于 lodash，underscore 的源码更加短小，也不太涉及 JavaScript 中的一些奇淫巧技，所以，分析 underscore 更加适合 JavaScript 开发者的进阶。在完成了 underscore 的源码分析后，希望我自己有时间，也希望读者有意愿再去分析 lodash 的源码，后者在性能和功能上都已经超越了 underscore，并且长时间霸占了 npm 了最热 package 的位置。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="underscore 源码分析" scheme="http://yoyoyohamapi.me/categories/underscore-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="JavaScript" scheme="http://yoyoyohamapi.me/tags/JavaScript/"/>
    
      <category term="函数式编程" scheme="http://yoyoyohamapi.me/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>thunkify</title>
    <link href="http://yoyoyohamapi.me/2016/08/02/thunkify/"/>
    <id>http://yoyoyohamapi.me/2016/08/02/thunkify/</id>
    <published>2016-08-02T03:03:08.000Z</published>
    <updated>2018-02-14T17:02:19.476Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>自己之前曾经撸过一个验证库，代码大致如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">validate</span>(<span class="params">data, rules, cb</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ....</span></span><br><span class="line">  <span class="comment">// 一切完成后会触发回调函数</span></span><br><span class="line">  cb(<span class="literal">null</span>, errMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>出于性能上的考虑，该库被封装为了一个异步函数，需要提供一个回调函数 <code>cb</code> 来获得验证结果，该回调函数是一个满足 node 规范的 <strong>error-first callback</strong>。在其他系统中，该库使用良好，但是，新项目使用了 koa，我在中间件中使用这个库提供的 <code>validate</code> 方法， 却连编译期都没有通过：</p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> validator = <span class="built_in">require</span>(<span class="string">'../libs/validator'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> *(<span class="params">next</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 获得请求体</span></span><br><span class="line">        <span class="keyword">const</span> body = <span class="keyword">this</span>.request.body;</span><br><span class="line">        <span class="comment">// 获得规则</span></span><br><span class="line">        <span class="keyword">const</span> rules = getRules(<span class="keyword">this</span>.request.url);</span><br><span class="line">        <span class="keyword">if</span> (rules) &#123;</span><br><span class="line">          validator.validate(body, rules, (error, errMap) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> errors = <span class="built_in">Object</span>.keys(errMap).reduce(<span class="function">(<span class="params">errors, key</span>) =&gt;</span> &#123;</span><br><span class="line">                  <span class="keyword">const</span> value = errMap 连[key];</span><br><span class="line">                  <span class="keyword">if</span> (value.error) &#123;</span><br><span class="line">                      errors.push(<span class="string">` 参数 [<span class="subst">$&#123;key&#125;</span>] 的规则 [\'<span class="subst">$&#123;value.msg&#125;</span>\'] 不通过 `</span>);</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">return</span> errors;</span><br><span class="line">              &#125;, []);</span><br><span class="line">              <span class="keyword">if</span> (errors.length) &#123;</span><br><span class="line">                  logger.error(<span class="string">` 参数校验失败:<span class="subst">$&#123;errors.toString()&#125;</span>`</span>);</span><br><span class="line">                  <span class="keyword">const</span> error = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">` 参数校验失败:<span class="subst">$&#123;errors.toString()&#125;</span>`</span>);</span><br><span class="line">                  error.status = <span class="number">400</span>;</span><br><span class="line">                  <span class="keyword">this</span>.throw(error);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// ！注意，我在回调函数中使用了 yield</span></span><br><span class="line">                  <span class="keyword">yield</span> next;</span><br><span class="line">              &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">yield</span> next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>查阅了 <a href="http://tc39wiki.calculist.org/es6/arrow-functions/" target="_blank" rel="noopener"> ECMAScript Wiki </a> 知道，<code>yield</code> 关键字并不能在箭头函数中使用。一再探索解决渠道的时候，我有两个考虑，一方面，<code>yield</code> 是使用 koa 中间件时绕不开的。另一方面，我也不想去改造库，这样必然会影响到其他系统。</p><h2 id="thunk"><a href="#thunk" class="headerlink" title="thunk"></a>thunk</h2><p>解决该问题的方法就是将我们原有库的 API 包装成一个 thunk，该 thunk 大致形态如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">thunk</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    cb(err, data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>thunk</code> 返回的函数接收一个回调函数 <code>cb(error, data)</code>。同样地，该函数是一个 <strong>error-first callback</strong>。现在，在 koa 中间件中，我们就能这样使用 <code>thunk</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// data 源于回调的第二个参数 `data`</span></span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">yield</span> thunk();</span><br><span class="line">&#125; <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">  <span class="comment">// error handling: 其中错误来源于回调的第一个参数 `error`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>所以，我们可以这样包装我们的 <code>validate</code> 方法，使 <code>validate</code> 方法 thunk 化：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> thunkedValidate = <span class="function"><span class="keyword">function</span>(<span class="params">data, rules</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> validator.validate(data, rules, cb);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们能在中间件顺畅的使用 API 了，并且代码更加直观：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 获得请求体</span></span><br><span class="line"><span class="keyword">const</span> body = <span class="keyword">this</span>.request.body;</span><br><span class="line"><span class="comment">// 获得规则</span></span><br><span class="line"><span class="keyword">const</span> rules = getRules(<span class="keyword">this</span>.request.url);</span><br><span class="line"><span class="keyword">if</span> (rules) &#123;</span><br><span class="line">  <span class="keyword">const</span> errMap = <span class="keyword">yield</span> thunkedValidate(body, rules);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>上面我们改造 <code>validate</code> 的做法并不通用，如果我们还想改造其他 API，逐个封装显然容易让人疲惫不堪。借助于高阶函数，我们能够封装一个通用的方法用来 thunk 化一个函数，我们将其命名为 <code>thunkify</code>，他的大致结构如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接受一个函数, 返回一个 thunk</span></span><br><span class="line"><span class="comment"> * @param func 原函数</span></span><br><span class="line"><span class="comment"> * @return Function thunk</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">thunkify</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回一个 thunk</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再分析下，将一个函数改造为返回一个 thunk 的过程：</p><ol><li>获得原函数的参数，比如上例中的 <code>data</code>、<code>rules</code></li><li>新建一个高阶函数，该函数以这些参数作为参数，并且返回一个 thunk，在 thunk 中，才是我们运行 API 的过程：</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">data, rules</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> thunk(done)&#123;</span><br><span class="line">    <span class="comment">// 通常，回调函数是最后一个传入的函数</span></span><br><span class="line">    validator.validate(rules, data, ()=&gt; &#123;&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了更加通用，在 <code>thunkify</code> 中，我们创建的高阶函数不再显式声明需要的参数，而是借助于 <code>arguments</code> 来捕获参数：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">thunkify</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 获得参数，借助闭包保存</span></span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 thunk</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 追加 `cb` 到 args 中</span></span><br><span class="line">      args.push(<span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>)</span>&#123;</span><br><span class="line">        cb.call(<span class="keyword">this</span>, err, data);</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">// 调用 api， 完成逻辑</span></span><br><span class="line">      func.apply(<span class="keyword">this</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试一下，用例我参考的<a href="https://github.com/tj/node-thunkify" target="_blank" rel="noopener"> node-thunkify </a>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params">name, fn</span>) </span>&#123;</span><br><span class="line">  fn(<span class="literal">null</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">thunked = thunkify(load);</span><br><span class="line"></span><br><span class="line">thunked(<span class="string">'wxj'</span>)(<span class="function"><span class="keyword">function</span>(<span class="params">err, name</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;); <span class="comment">// 'wxj'</span></span><br></pre></td></tr></table></figure><h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><p>再看下面的一个测试 ：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  fn(<span class="literal">null</span>, <span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> user = &#123;</span><br><span class="line">  name: <span class="string">'wxj'</span>,</span><br><span class="line">  load: thunkify(load)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user.load()(<span class="function"><span class="keyword">function</span>(<span class="params">err, name</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></p><p>没有按照预期的输出 <code>&#39;wxj&#39;</code>，因为我们的 <code>thunkify</code> 忘记考虑绑定执行上下文了，在原始的 API 执行时：</p><figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span>;</span></span><br></pre></td></tr></table></figure><p>其对应的 <code>this</code> 应该是 <code>func()</code> 执行时所处的上下文。所以，我们优化 <code>thunkify</code>，让 thunk 化 的 API 能获得正确的执行上下文：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">thunkify</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 获得参数，借助闭包保存</span></span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 缓存上下文</span></span><br><span class="line">    <span class="keyword">var</span> ctx = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 返回 thunk</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 追加 `cb` 到 args 中</span></span><br><span class="line">      args.push(<span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>)</span>&#123;</span><br><span class="line">        cb.call(<span class="keyword">this</span>, err, data);</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">// 调用 API，使用缓存了的上下文</span></span><br><span class="line">      func.apply(ctx, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再跑一下上面的用例， 成功输出了 <code>&#39;wxj&#39;</code>。</p><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><hr><p>假定，我们 API 是会抛出错误的，那么在 API 的执行过程中捕获到错误时，我们就应当向 <code>cb</code> 中注入该错误：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">thunkify</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 获得参数，借助闭包保存</span></span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 缓存上下文</span></span><br><span class="line">    <span class="keyword">var</span> ctx = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 返回 thunk</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 追加 `cb` 到 args 中</span></span><br><span class="line">      args.push(<span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>)</span>&#123;</span><br><span class="line">        cb.call(<span class="keyword">this</span>, err, data);</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">// 调用 API，完成逻辑</span></span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">        func.apply(ctx, args);</span><br><span class="line">      &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        cb(e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试一下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'boom'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">load = thunkify(load);</span><br><span class="line"></span><br><span class="line">load()(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们封装了一个大致可用的 thunkify 函数，也再次体会了 JavaScript 多范式编程的魅力和高阶函数的强大。不过，在实际生产环境中，还是推荐使用更健壮的<a href="https://github.com/tj/node-thunkify" target="_blank" rel="noopener"> node-thunkify </a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h2&gt;&lt;p&gt;自己之前曾经撸过一个验证库，代码大致如下：&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;validate&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;data, rules, cb&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// ....&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 一切完成后会触发回调函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  cb(&lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;, errMap);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;出于性能上的考虑，该库被封装为了一个异步函数，需要提供一个回调函数 &lt;code&gt;cb&lt;/code&gt; 来获得验证结果，该回调函数是一个满足 node 规范的 &lt;strong&gt;error-first callback&lt;/strong&gt;。在其他系统中，该库使用良好，但是，新项目使用了 koa，我在中间件中使用这个库提供的 &lt;code&gt;validate&lt;/code&gt; 方法， 却连编译期都没有通过：&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript 学习笔记" scheme="http://yoyoyohamapi.me/categories/JavaScript-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="http://yoyoyohamapi.me/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>使用 ES6 中的 generator 来优化异步过程</title>
    <link href="http://yoyoyohamapi.me/2016/08/01/%E4%BD%BF%E7%94%A8-ES6-%E4%B8%AD%E7%9A%84-generator-%E6%9D%A5%E4%BC%98%E5%8C%96%E5%BC%82%E6%AD%A5%E8%BF%87%E7%A8%8B%EF%BC%88%E7%BF%BB%E8%AF%91%E5%8F%8A%E8%A1%A5%E5%85%85%EF%BC%89/"/>
    <id>http://yoyoyohamapi.me/2016/08/01/使用-ES6-中的-generator-来优化异步过程（翻译及补充）/</id>
    <published>2016-08-01T11:58:27.000Z</published>
    <updated>2018-02-14T17:01:21.492Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文：<a href="https://davidwalsh.name/async-generators" target="_blank" rel="noopener">Going Async With ES6 Generators</a> 本文在作者文章的基础上，适当补充了一些代码及说明</p></blockquote><p>ES6 中的 generator 能够帮助我们提供一种类似同步一样的代码风格，来将异步过程的具体实现隐藏。这样的好处就是我们能够更加自然的表达自己的业务流程（work flow），而避免陷入异步的麻烦中。换言之，借助于 generator，我们既拥有了异步执行的能力，又不用再绞尽脑汁的去维护异步代码。</p><p>继续阅读本文，你会发现这么做的结果简直太美妙了，以前那些糟糕的异步代码现在讲会向同步代码那样变得 <strong> 易于阅读 </strong> 和 <strong> 可维护 </strong>。需要知道的是，这个同步只是代码风格上的同步，他的执行过程仍然是异步的。</p><p>说了那么多，仍然有些抽象，现在我们由浅入深地看看到底怎么通过 ES6 来优化异步过程。</p><a id="more"></a><h2 id="一个最简单的异步"><a href="#一个最简单的异步" class="headerlink" title="一个最简单的异步"></a>一个最简单的异步</h2><p>假设我们的程序原来拥有这样的异步代码，这是最为朴实和原始的 JavaScript 异步流程控制：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeAjaxCall</span>(<span class="params">url,cb</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do some ajax fun</span></span><br><span class="line">    <span class="comment">// call `cb(result)` when complete</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">makeAjaxCall( <span class="string">"http://some.url.1"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">result1</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse( result1 );</span><br><span class="line"></span><br><span class="line">    makeAjaxCall( <span class="string">"http://some.url.2/?id="</span> + data.id, <span class="function"><span class="keyword">function</span>(<span class="params">result2</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> resp = <span class="built_in">JSON</span>.parse( result2 );</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">"The value you asked for:"</span> + resp.value );</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以看到，对于一次异步请求，我们获取异步结果的过程放到了回调当中。然而，借助 generator 来完成相同的任务：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 我们将真正的异步功能掩藏在 `request` 中，这样我们在 generator 中能专注同步写法</span></span><br><span class="line">    <span class="comment">// 通过 `it.next(..)` 来获得异步结果，并让 generator 的流程继续</span></span><br><span class="line">  makeAjaxCall(url, (result)=&gt;&#123;</span><br><span class="line">    it.next(result);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 注意，这里没有返回任何值，也就是说 `request()` 的执行结果会返回 `undefined`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 在 generator 中，我们的异步处理流程摇身一变成了同步执行过程</span></span><br><span class="line">  <span class="keyword">const</span> result1 = <span class="keyword">yield</span> request(<span class="string">'http://some.url.1'</span>);</span><br><span class="line">  <span class="keyword">const</span> data =  <span class="built_in">JSON</span>.parse(result1);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> result2 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.2?id="</span> + data.id );</span><br><span class="line">    <span class="keyword">const</span> resp = <span class="built_in">JSON</span>.parse( result2 );</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">"The value you asked for:"</span> + resp.value );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `main()` 方法执行后，generator 进入暂态，当 `makAjaxCall` 异步任务完成后，会让 `main()` 继续</span></span><br><span class="line">it = main();</span><br><span class="line">it.next();</span><br></pre></td></tr></table></figure><p>可以看到，generator 函数 <code>*main(..)</code> 自身非常纯净，我们在其中撰写业务流程就像我们在 PHP 或者 Java 等语言撰写业务流程，看不到任何的回调。</p><p>下面解释一下以上代码片是如何工作的：</p><p>helper 函数 <code>request(..)</code> 简单的包裹了异步任务 <code>makeAjaxCall(..)</code>，一旦 <code>makeAjaxCall(..)</code> 取得了结果，就调用 generator 迭代器的 <code>next(..)</code> 方法使 generator 继续运行。</p><p>当 <code>*main</code> 运行到 <code>yield ..</code> 后，他会被暂停在 <code>yield</code> 发生的位置，直到遇到了在 <code>makeAjaxCall(..)</code> 的回调中声明的 <code>it.next(..)</code> 才会继续执行。注意到，我们把 Ajax 请求到的结果 <code>result</code> 传递给了 <code>it.next(..)</code>，那么之后，<code>result</code> 就会被返回到的 <code>*main</code> 暂停了的位置，作为 <code>yield ..</code> 表达式的输出，所以，<code>result1</code> 不会是 <code>undefined</code>（默认情况下，<code>yield</code> 返回 <code>undefined</code>），而是拿到的异步结果。</p><p>这就是真正牛逼的地方。语句 <code>result1 = yield request(..)</code> 所表达的意图是要去请求一个值，但是，这个请求过程却被隐藏了。利用 <code>yield</code> 实现 <strong> 暂停 </strong> 功能，然后将 <strong> 继续 </strong> 功能放到 generator 函数以外地方，更准确地说，是放到了 generator 以外的异步回调中，从而保证了我们能够在 generator 中利用 <strong> 同步 </strong> 方式撰写业务流程。</p><blockquote><p><strong> 暂停 - 继续 </strong> 这样串行执行的过程模拟了 <strong> 同步 </strong> 的过程，使得这条语句在语法风格上实现了同步，但其内部实现又是异步的。</p></blockquote><p>别高兴的太早，上面的代码还存在一些问题。在上面的代码中，我们总是执行一个异步 Ajax 调用，但是，如果我们之后将 Ajax 的返回结果缓存到了内存来提升性能，这意味着我们下一次请求不再需要去服务端获得数据，而可以立即从内存上获取。为了满足这个需求，我们可能就会将代码改成如下形式:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cache = &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(cache[url]) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      it.next(cacheUrl);</span><br><span class="line">    &#125;,<span class="number">0</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    makeAjaxCall(url, (resp)=&gt;&#123;</span><br><span class="line">      it.next(resp);</span><br><span class="line">      cache[url] = resp;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：这里用到了 <code>setTimeout(..0)</code> 这个小技巧来强行进入异步过程，如果我们直接调用 <code>it.next(cacheUrl)</code>，就会出错，原因在于执行语句 <code>yield request(..)</code> 时，我们先执行 <code>request(..)</code>，之后 generator 函数才会暂停（后执行 <code>yield</code> ）。所以，如果我们直接调用 <code>it.next(cacheUrl)</code>，则流程如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">next()-&gt;request()-&gt;next()</span><br></pre></td></tr></table></figure><p>由于此时 generator 已经运行了，程序会抛出错误 <code>Generator is already running</code>。而通过 <code>setTimeout(..0)</code> 包裹后，我们的执行流程如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">next()-&gt;request()-&gt;yield-&gt;next()-&gt; 继续</span><br></pre></td></tr></table></figure><p>整个业务才能继续执行。</p><p>现在，我们的 generator 是这样的:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> result1 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.1"</span> );</span><br><span class="line"><span class="keyword">const</span> data = <span class="built_in">JSON</span>.parse( result1 );</span><br></pre></td></tr></table></figure><p>牛逼吧？尽管我们新添加了缓存的逻辑，但丝毫不影响我们的 generator 函数，仍旧是在专心的写业务。在 <code>*main()</code> 中，其过程仍然是非常清晰的业务流：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">请求值 --&gt; 暂停（等待请求完成）--&gt; 获得值 --&gt; 继续</span><br></pre></td></tr></table></figure><blockquote><p>在该场景下，暂停的持续时间变得很微妙，他可能很长（比如向服务器请求值），也可能很短（比如从内存缓存中请求值），但在我们的 <code>*main()</code> 中，还是只关注工作流（flow），无论异步过程的实现细节是否变得复杂。</p></blockquote><h2 id="更好的异步流程控制"><a href="#更好的异步流程控制" class="headerlink" title="更好的异步流程控制"></a>更好的异步流程控制</h2><p>上面的代码已经满足了一些简单的异步场景。但是很快，他的功能就会显得捉襟见肘，我们需要一个更加强大的异步机制来结合我们的 generator 去满足更大的业务场景。这个机制就是 <strong>Promises</strong>。</p><blockquote><p>对于 ES6 中 Promise 尚存疑惑的读者可以看下作者关于此的<a href="http://blog.getify.com/promises-part-1/" target="_blank" rel="noopener">博客</a>。</p></blockquote><p>首先，我们反思一下之前的设计缺陷：</p><ul><li>缺乏清晰的错误处理</li></ul><p>在 <a href="https://davidwalsh.name/es6-generators-dive#error-handling" target="_blank" rel="noopener">作者之前撰写的文章</a> 中，我们能够知道一些在 Ajax 调用过程中检测错误的手段：通过 <code>it.throw(..)</code> 将错误返回的 generator 中，而在 generator 中，我们又通过 <code>try..catch</code> 来俘获错误，进行错误处理:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  makeAjaxCall(url, (err,result)=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) it.throw(err);</span><br><span class="line">    <span class="keyword">else</span> it.next(result);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> result1 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.1"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">"Error:"</span> + err );</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="built_in">JSON</span>.parse( result1 );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> result2 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.2?id="</span> + data.id );</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">"Error:"</span> + err );</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> resp = <span class="built_in">JSON</span>.parse( result2 );</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">"The value you asked for:"</span> + resp.value );</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure><p>这样做的坏处就是，我们把错误抛出耦合到了 Ajax 流程中，设想，我们有还有其他的 generator 也用到了 <code>request(..)</code>，我们的错误控制就会变成这样：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    makeAjaxCall(url, (err,result)=&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span>(err) &#123;</span><br><span class="line">            it1.throw(err);</span><br><span class="line">            it2.throw(err);</span><br><span class="line">            it3.throw(err);</span><br><span class="line">            <span class="comment">// ..</span></span><br><span class="line">            itn.throw(err);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这使得 <code>request(..)</code> 难以复用。</p><ul><li>如果 <code>makeAjaxCall(..)</code> 是一个并不受我们的控制的第三方库</li></ul><p>我们如果要在其中做诸如 <code>it.next(..)</code> 这样对 generator 的控制，就不得不修改这个库的实现，耗费人力不说，随意破坏第三方库也会使得代码难以移植。</p><ul><li>并行任务。</li></ul><p>由于 generator 中的 <code>yield</code> 是一个单步暂停点，同一时刻就只能跑一个任务。所以，我们渴望一个新的方式去执行并行任务，并且不需要太多的人工介入。</p><p>要解决上述的问题就需要我们探索新的设计模式了，结合这个新的设计模式，能让我们的基于 generator 的异步过程变得更加优雅。这个新的设计模式将会引入 <strong>Promise</strong>，其流程大致如下：</p><p><code>yield</code> 一个 Promise 对象后暂停，直至这些 Promise 对象被 <strong> 履行（fulfill）</strong> 的时候才继续我们的 generator。由于并行的 <code>Promise.all([..])</code> 也是一个 Promise 对象，所以在这种设计模式下，也能执行并行任务。</p><p>让我们对之前的 <code>request(..)</code> 函数加以修改，使之基于 Promise：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">      <span class="comment">// 现在，`makeAjaxCall(..)` 不再耦合 `it.next(..)`</span></span><br><span class="line">        makeAjaxCall( url, (result)=&gt;resolve(result));</span><br><span class="line">    &#125; );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>request(..)</code> 构造了一个 Promise 对象并返回，该 Promise 对象将会在 Ajax 请求完成后被 resolved。现在，generator 中的 <code>yield</code> 最终也将产出这个 Promise 对象。我们还需要一个工具函数来控制我们的 generator 的迭代器，完成我们 generator 函数的自动执行。我们暂且将这个工具函数称之为 <code>runGenerator(..)</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// `runGenerator` 函数将运行一个 generator 函数 `g` 直至其完成</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runGenerator</span>(<span class="params">g</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> it = g(), ret;</span><br><span class="line">    <span class="comment">// 执行迭代过程的函数，首次立即执行的目的是为了启动 generator</span></span><br><span class="line">    (<span class="function"><span class="keyword">function</span> <span class="title">iterate</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 获得最近迭代结果, 启动时 val 是 undefined</span></span><br><span class="line">        ret = it.next( val );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 generator 没有执行完毕</span></span><br><span class="line">        <span class="keyword">if</span> (!ret.done) &#123;</span><br><span class="line">            <span class="comment">// 是否 `ret` 仍然是一个 Promise 对象，如果是，意味着 generator 还在不断 yield</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"then"</span> <span class="keyword">in</span> ret.value) &#123;</span><br><span class="line">                <span class="comment">// 将 `iterate(val)` 注册为该 Promise 的 `then(..)` 的回调，</span></span><br><span class="line">                <span class="comment">// 借此，获得一个 Promise 链</span></span><br><span class="line">                ret.value.then( iterate );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果不是 Promise 对象，而是立即数, 将该结果返回</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// avoid synchronous recursion</span></span><br><span class="line">                setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                    iterate( ret.value ); <span class="comment">// 相当于 `it.next(立即数)`</span></span><br><span class="line">                &#125;, <span class="number">0</span> );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以分析一下该工具函数的执行过程： 1. 我们首先初始化了传入的 generator 的迭代器 <code>it</code>，并且创建了一个迭代函数 <code>iterate</code>，该迭代函数用来 <strong> 继续 </strong> generator 的流程，从而让 generator 的自动执行至完毕。 2. 每次我们执行 <code>iterator(val)</code>，就会调用 <code>it.next(val)</code>，并且获得结果 <code>ret</code>。假设我们 generator 中的执行语句是 <code>yield request( &quot;http://some.url.1&quot; )</code>，<code>request(..)</code> 会返回一个 Promise 对象，此时，<code>ret</code> 也就是该 Promise 对象，我们向其 <code>then(..)</code> 方法注册 <code>iterator</code>，使得该 Promise 对象完成后能够进入下一个 Promise 对象的流程，并且每次完成都会继续 generator。 3. 当 <code>iterator(val)</code> 不停流转，直至 <code>val</code> 是一个立即数时，暗示 Promise 链执行完毕，获得了结果，将其返回到 generator 使 generator 得以继续执行。</p><blockquote><p>简言之，结合了 Promise 的 generator 异步流程就是：每次 <code>yield</code> 一个 Promise 进入暂停态，在 Promise 完成后 generator 得以继续执行。</p></blockquote><p>下面我们看看怎么使用 <code>runGenerator</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">runGenerator( <span class="function"><span class="keyword">function</span> *<span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result1 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.1"</span> );</span><br><span class="line">    <span class="keyword">const</span> data = <span class="built_in">JSON</span>.parse( result1 );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> result2 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.2?id="</span> + data.id );</span><br><span class="line">    <span class="keyword">const</span> resp = <span class="built_in">JSON</span>.parse( result2 );</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">"The value you asked for:"</span> + resp.value );</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure><p>简直碉堡了，有没有！我们的业务逻辑仍然没什么变化！</p><p>设想，如果我们不做 <code>runGenerator</code> 函数，就需要手动控制 generator 的流程：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> it = main(); <span class="comment">// 获得 generator 的迭代器</span></span><br><span class="line"><span class="comment">// 不断用 `then(..)` 修饰 Promise</span></span><br><span class="line">it.next().value.then(<span class="function">(<span class="params">result1</span>)=&gt;</span>&#123;</span><br><span class="line">  it.next(result1).value.then(<span class="function">(<span class="params">result2</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 最终的结果返回</span></span><br><span class="line">    it.next(result2);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果业务流非常漫长，则撰写的嵌套是非常恐怖的。</p><p>现在，我们已经使用了 Promise 来管理基于 generator 的异步流程，它将我们从充满了诸如回调陷阱（callback hell）中解放了出来。通过 generators+promise 这个设计模式，我们阐述一下如何解决上面提到的三个问题： 1. 现在，我们拥有内置的错误处理。虽然这点没有在上面的 <code>runGenerator(..)</code> 进行揭示，但是，后文会讲到，在新的设计模式下，从 Promise 中监听所有的错误并不困难。最终通过将错误绑定到 <code>it.throw(..)</code>，我们就可以放心的在 generator 中使用 <code>try..catch</code> 语句来捕获和处理错误。 2. 我们拥有了 Promise 提供的 <a href="https://blog.getify.com/promises-part-2/#uninversion" target="_blank" rel="noopener">control/trustability</a>。 3. Promise 已经做了大量抽象帮助我们方便的操纵多个 “并行的” 任务。</p><p>例如，<code>yield Promise.all([..])</code> 将会利用传入的并行的任务数组（数组元素都是 Promise 对象），产出单一的 Promise 对象供 generator 操纵，generator 会等待所有的子 Promise 对象完成（无论完成顺序是怎样的）才继续进行。最后，我们真正返回给 generator 流程的是所有子 Promise 的响应构成的数组，数组元素的顺序会与请求顺序一致。</p><h2 id="generators-promise-下的错误处理"><a href="#generators-promise-下的错误处理" class="headerlink" title="generators+promise 下的错误处理"></a>generators+promise 下的错误处理</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        makeAjaxCall( url, (err,text)=&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span> (err) reject( err );</span><br><span class="line">            <span class="keyword">else</span> resolve( text );</span><br><span class="line">        &#125; );</span><br><span class="line">    &#125; );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runGenerator</span>(<span class="params">g</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> it = g(), ret;</span><br><span class="line">    <span class="comment">// 现在，传入了 `err` 作为第一个参数</span></span><br><span class="line">    (<span class="function"><span class="keyword">function</span> <span class="title">iterate</span>(<span class="params">err, val</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// generator 迭代过程中遇到错误就 `throw`</span></span><br><span class="line">        <span class="keyword">if</span>(err) &#123;</span><br><span class="line">          setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            it.throw(err);</span><br><span class="line">          &#125;,<span class="number">0</span>);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">        ret = it.next( val );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 generator 没有执行完毕</span></span><br><span class="line">        <span class="keyword">if</span> (!ret.done) &#123;</span><br><span class="line">            <span class="comment">// 是否 `ret` 仍然是一个 Promise 对象，如果是，意味着 generator 还在不断 `yield`</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"then"</span> <span class="keyword">in</span> ret.value) &#123;</span><br><span class="line">                <span class="comment">// 将 `iterate(val)` 注册为该 Promise 的 `then(..)` 的回调，</span></span><br><span class="line">                <span class="comment">// 借此，获得一个 Promise 链</span></span><br><span class="line">                ret.value.then( iterate );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果不是 Promise 对象，而是立即数，暗示 Promise 链已经获得最终结果，将该结果返回</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// avoid synchronous recursion</span></span><br><span class="line">                setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                    iterate( ret.value ); <span class="comment">// 相当于 it.next(立即数)</span></span><br><span class="line">                &#125;, <span class="number">0</span> );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">runGenerator(<span class="function"><span class="keyword">function</span> *<span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> result1 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.1"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">"Error:"</span> + err );</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="built_in">JSON</span>.parse( result1 );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> result2 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.2?id="</span> + data.id );</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">"Error:"</span> + err );</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> resp = <span class="built_in">JSON</span>.parse( result2 );</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">"The value you asked for:"</span> + resp.value );</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure><p>如果一个 Promise 的 reject 发生，那么该 reject 对应到的错误会映射到 generator 中的能够捕获的一个错误，这个映射过程是通过 <code>runGenerator(..)</code> 中声明的 <code>it.throw(..)</code> 来完成的。</p><h2 id="generators-promise-下的并行任务"><a href="#generators-promise-下的并行任务" class="headerlink" title="generators+promise 下的并行任务"></a>generators+promise 下的并行任务</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        makeAjaxCall( url, resolve );</span><br><span class="line">    &#125; )</span><br><span class="line">    <span class="comment">// 当获得返回的 `text`，可以做一些后置处理</span></span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">text</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// did we just get a (redirect) URL back?</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="regexp">/^https?:\/\/.+/</span>.test( text )) &#123;</span><br><span class="line">            <span class="comment">// make another sub-request to the new URL</span></span><br><span class="line">            <span class="keyword">return</span> request( text );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// otherwise, assume text is what we expected to get back</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> text;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">runGenerator( <span class="function"><span class="keyword">function</span> *<span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> search_terms = <span class="keyword">yield</span> <span class="built_in">Promise</span>.all( [</span><br><span class="line">        request( <span class="string">"http://some.url.1"</span> ), <span class="comment">// 每个元素也是 promise 对象</span></span><br><span class="line">        request( <span class="string">"http://some.url.2"</span> ),</span><br><span class="line">        request( <span class="string">"http://some.url.3"</span> )</span><br><span class="line">    ] );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> search_results = <span class="keyword">yield</span> request(</span><br><span class="line">        <span class="string">"http://some.url.4?search="</span> + search_terms.join( <span class="string">"+"</span> )</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">const</span> resp = <span class="built_in">JSON</span>.parse( search_results );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">"Search results:"</span> + resp.value );</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure><p>在上面代码中，<code>Promise.all([ .. ])</code> 创建了一个 Promise 对象，该对象会等待三个子 Promise 对象完成。最终，返回的到 generator 的，恢复 generator 执行的，会是该 Promise 对象的执行结果。</p><h3 id="ES7-中的-async"><a href="#ES7-中的-async" class="headerlink" title="ES7 中的 async"></a>ES7 中的 <code>async</code></h3><p>尚未发布的 ES7 标准中提出了一个 <code>async</code> 函数，该函数就像我们上面撰写被 <code>runGenerator(..)</code> 所包裹的 generator。通过 <code>await</code> 关键字，你能够发出 Promise 对象，他会等待这些对象完成后才继续下去（我们甚至都不再需要借助迭代器了）。</p><p>aysnc 函数的大致使用过程如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result1 = <span class="keyword">await</span> request( <span class="string">"http://some.url.1"</span> );</span><br><span class="line">    <span class="keyword">const</span> data = <span class="built_in">JSON</span>.parse( result1 );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> result2 = <span class="keyword">await</span> request( <span class="string">"http://some.url.2?id="</span> + data.id );</span><br><span class="line">    <span class="keyword">const</span> resp = <span class="built_in">JSON</span>.parse( result2 );</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">"The value you asked for:"</span> + resp.value );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main();</span><br></pre></td></tr></table></figure><p>正如你所看到的那样，一个 <code>async function</code> 能够被直接调用，而不需要再包裹上 <code>runGenerator(..)</code>。其次，我们将用新的关键字 <code>await</code> 来替代 <code>yield</code> 告诉 <code>async function</code> 在继续前需要等待当前的 Promise 处理完成。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>generator+promise 的设计模式集成了强大而优雅的同步式的异步流程控制的优势。通过简单的 wrapper 函数，我们能够自动地运行我们的 generator 直至完成，包括清晰明了的同步式的错误控制。</p><p>而在 ES7 以上的版本，我们还能有 <code>async function</code> 来完成同样的任务。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文：&lt;a href=&quot;https://davidwalsh.name/async-generators&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Going Async With ES6 Generators&lt;/a&gt; 本文在作者文章的基础上，适当补充了一些代码及说明&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ES6 中的 generator 能够帮助我们提供一种类似同步一样的代码风格，来将异步过程的具体实现隐藏。这样的好处就是我们能够更加自然的表达自己的业务流程（work flow），而避免陷入异步的麻烦中。换言之，借助于 generator，我们既拥有了异步执行的能力，又不用再绞尽脑汁的去维护异步代码。&lt;/p&gt;
&lt;p&gt;继续阅读本文，你会发现这么做的结果简直太美妙了，以前那些糟糕的异步代码现在讲会向同步代码那样变得 &lt;strong&gt; 易于阅读 &lt;/strong&gt; 和 &lt;strong&gt; 可维护 &lt;/strong&gt;。需要知道的是，这个同步只是代码风格上的同步，他的执行过程仍然是异步的。&lt;/p&gt;
&lt;p&gt;说了那么多，仍然有些抽象，现在我们由浅入深地看看到底怎么通过 ES6 来优化异步过程。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript 学习笔记" scheme="http://yoyoyohamapi.me/categories/JavaScript-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript - ES6" scheme="http://yoyoyohamapi.me/tags/JavaScript-ES6/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 中的递归优化</title>
    <link href="http://yoyoyohamapi.me/2016/06/28/JavaScript-%E4%B8%AD%E7%9A%84%E9%80%92%E5%BD%92%E4%BC%98%E5%8C%96/"/>
    <id>http://yoyoyohamapi.me/2016/06/28/JavaScript-中的递归优化/</id>
    <published>2016-06-28T14:45:04.000Z</published>
    <updated>2018-02-14T17:02:05.633Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>说到递归，我们先来看一个最常见的递归用例：<strong> 计算阶乘 </strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> n*factorial(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试一下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">factorial(<span class="number">5</span>); <span class="comment">// =&gt; 120</span></span><br></pre></td></tr></table></figure><p>似乎一切正常，5 的阶乘 120 被正确计算出来了，我们试着把数字调大一些：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">factorial(<span class="number">70000</span>);</span><br><span class="line"><span class="comment">// Uncaught RangeError:Maximum call stack size exceeded(…)</span></span><br></pre></td></tr></table></figure><p>浏览器提示我们 <strong> 栈溢出 </strong> 了（测试环境：chrome 51），究竟发生了什么呢?</p><a id="more"></a><h2 id="尾调用"><a href="#尾调用" class="headerlink" title="尾调用"></a>尾调用</h2><p>其实，上面的 <code>factorial</code> 的实现等同于下面这个形式：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> total = factorial(n<span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">return</span> n*total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数有个什么特点呢，就是该函数中的调用 <code>factorial(n-1)</code> 并没有发生在函数最后。因此，为了在执行完该调用还能返回到函数中执行后续操作:</p><ol><li>赋值给局部变量 <code>total</code>：<code>var total = factorial(n-1)</code><br>.    计算 <code>n*total</code> 并返回。</li></ol><p>那么，当前的运行环境在进入这个调用前，会先将 <strong> 调用位置 </strong> 以及周围的一些环境保存成一个 <strong> 调用帧（call frame）</strong> ，并将该调用帧 <strong> 压入（push）</strong> 一个栈空间中，这个栈被称为 <strong> 调用栈（call stack）</strong>。当再无调用帧入栈时，就开始逐个 <strong> 压出（pop）</strong> 调用帧，调用取值。比如上面的 <code>factorial(5)</code> 的执行过程就是一个呈 <strong> 金字塔形 </strong> 的过程，金字塔的峰值就反应了 <code>factorial</code> 对栈空间需求的峰值：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">push factorial(<span class="number">5</span>)</span><br><span class="line">push <span class="number">5</span>*factorial(<span class="number">4</span>)</span><br><span class="line">push <span class="number">5</span>*(<span class="number">4</span>*factorial(<span class="number">3</span>) )</span><br><span class="line">push <span class="number">5</span>*(<span class="number">4</span>* (<span class="number">3</span>*factorial(<span class="number">2</span>)) )</span><br><span class="line">push <span class="number">5</span>*(<span class="number">4</span>*( <span class="number">3</span>* (<span class="number">2</span>*factorial(<span class="number">1</span>)) ) )</span><br><span class="line">pop  <span class="number">5</span>*<span class="number">4</span>*<span class="number">3</span>*(<span class="number">2</span>*<span class="number">1</span>)</span><br><span class="line">pop  <span class="number">5</span>*<span class="number">4</span>*(<span class="number">3</span>*<span class="number">2</span>)</span><br><span class="line">pop  <span class="number">5</span>*(<span class="number">4</span>*<span class="number">6</span>)</span><br><span class="line">pop  <span class="number">5</span>*<span class="number">24</span></span><br><span class="line">pop  <span class="number">120</span></span><br></pre></td></tr></table></figure><p>很明显，这次调用之于调用栈的空间复杂度是 <code>O(n)</code>，亦即，随着我们 <code>n</code> 取值的不断变大，栈空间不断被消耗，当 <code>n</code> 很大时，栈溢出就发生了，毕竟内存总是有限的，不允许我们这么无节制的消耗栈空间。</p><p>那么要如何优化，才能不发生栈溢出呢？我们来看另外一个非常简单的函数：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> n = <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">return</span> b(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数有个什么特点？就是其内部的函数调用 <code>b(100)</code> 发生在了函数末尾，也就是说，该函数调用之后不再有任何后续操作，通常，把这样的调用形式称之为 <a href="https://zh.wikipedia.org/wiki/%E5%B0%BE%E8%B0%83%E7%94%A8" target="_blank" rel="noopener">尾调用</a>。尾调用因为脱离对后续操作的依赖，也就没有必要再去创建更多的调用帧消耗宝贵的栈空间了。</p><p>那么我们尝试着把之前的 <code>factorial</code> 改写成尾调用的形式，再次分析 <code>factorial</code> 的执行过程，可以发现，它能够被简化成如下形式：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>*factorial(<span class="number">5</span>)</span><br><span class="line"><span class="number">5</span>*factorial(<span class="number">4</span>)</span><br><span class="line"><span class="number">20</span>*factorial(<span class="number">3</span>)</span><br><span class="line"><span class="number">60</span>*factorial(<span class="number">2</span>)</span><br><span class="line"><span class="number">120</span>*factorial(<span class="number">1</span>)</span><br><span class="line"><span class="number">120</span>*<span class="number">1</span></span><br><span class="line"><span class="number">120</span></span><br></pre></td></tr></table></figure><p>即每次的执行过程总是：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">total*factorial(n)</span><br></pre></td></tr></table></figure><p>进一步，我们将 <code>total</code> 当做 <code>factorial</code> 的参数，这样就将后续过程也融入到了函数调用中，最终获得了一个尾调用形式的 <code>factorial</code> ：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, total</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">  <span class="keyword">return</span> factorial(n<span class="number">-1</span>, n*total);</span><br><span class="line">  <span class="comment">// 不再有后续操作 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>factorial</code> 的执行过程就会变成：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">factorial(<span class="number">5</span>,<span class="number">1</span>)</span><br><span class="line">factorial(<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">factorial(<span class="number">3</span>,<span class="number">20</span>)</span><br><span class="line">factorial(<span class="number">2</span>,<span class="number">60</span>)</span><br><span class="line">factorial(<span class="number">1</span>,<span class="number">120</span>)</span><br><span class="line"><span class="number">120</span></span><br></pre></td></tr></table></figure><p>已经不是金字塔形了，栈的空间复杂度由 <code>O(n)</code> 减少到了 <code>O(1)</code> ，仅最外层的函数需要一个调用帧，因为外层函数执行完成后需要返回到外部空间进行后续操作。这种优化方式被称为 *<em> 尾调用优化（Tail Call Optimization）*<em> ，简称 **TCO</em></em> 。</p><h2 id="现实却很残酷"><a href="#现实却很残酷" class="headerlink" title="现实却很残酷"></a>现实却很残酷</h2><p>我们再来测试一下被优化过 <code>factorial</code> 函数：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">factorial(<span class="number">70000</span>,<span class="number">1</span>);</span><br><span class="line"><span class="comment">// =&gt; VM16052:1 Uncaught RangeError: Maximum call stack size exceeded(…)</span></span><br></pre></td></tr></table></figure><p>悲剧！还是栈溢出了，这是为什么呢？原因就在于尾调用优化虽然在其他语言里面的得到了支持，但在 <strong>ES5</strong> 中还没有得到支持，换言之，<strong>ES5</strong> 根本不管你函数调用是否发生在函数末尾都不会作出优化。那么还有没有其他的解决方式？难道我们永远无法在 <strong>ES5</strong> 中实现一个大的阶乘运算？目前来说，我们可能想到的办法会是：干脆不要递归了，以非递归形式来重写 <code>factorial</code> 函数。</p><p>对于阶乘来说，非递归的实现复杂度也不高，但试想，如果面对一个更加复杂的业务，难道也得替换成冗长的非递归形式吗？</p><h2 id="救星：Trampoline（蹦床）"><a href="#救星：Trampoline（蹦床）" class="headerlink" title="救星：Trampoline（蹦床）"></a>救星：Trampoline（蹦床）</h2><p>救星来了，它就是 <strong>Trampoline</strong>，翻译过来就是 <strong> 蹦床 </strong>，先看一下利用蹦床解决栈溢出的递归的代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 阶乘函数 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, total</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">  <span class="comment">// 返回一个 thunk，避免函数调用 </span></span><br><span class="line">  <span class="keyword">return</span> factorial.bind(<span class="literal">null</span>, n<span class="number">-1</span>, n*total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tramponline 函数 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trampoline</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(fn &amp;&amp; <span class="keyword">typeof</span> fn === <span class="string">'function'</span>)&#123;</span><br><span class="line">    fn = fn();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fac</span>(<span class="params">n,total</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> trampoline(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> factorial(n, total);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上代码我们可以看到，Trampoline 的核心在于通过 <strong> 循环（loop）</strong> 来替换 <strong> 递归（recursion）</strong> 过程，从而规避递归过程中占空间的申请和消耗。实现这一目标的步骤如下：</p><ol><li>改造原来的递归，迫使他不再返回一个函数调用，而只返回一个 <a href="https://en.wikipedia.org/wiki/Thunk" target="_blank" rel="noopener">thunk</a>，以备调用：</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原来的阶乘函数 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n,total</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> factorial(n<span class="number">-1</span>, n*total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在的阶乘函数 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> factorial.bind(<span class="literal">null</span>, n<span class="number">-1</span>, n*total);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>一个蹦床函数，由他来通过循环控制原递归函数的执行过程：接受一个参数 <code>fn</code> ，若 <code>fn</code> 是一个 <strong>thunk</strong> ，执行 <code>fn</code> ，直至 <code>fn</code> 不再需要被执行，就获得了最后的结果。该过程相当于抑制了递归函数的执行，我们仅只是一次次抽出子过程进行执行：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trampoline</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(fn &amp;&amp; <span class="keyword">typeof</span> fn === <span class="string">'function'</span>)&#123;</span><br><span class="line">    fn = fn();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>一个 wrapper ，用来创建新的执行过程：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fac</span>(<span class="params">n,total</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> trampoline(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> factorial(n, total);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>现在，这个 wrapper 将是我们最终的调用对象，之后求取阶乘我们将调用 <code>fac</code> ，而不再是 <code>factorial</code> ：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fac(<span class="number">70000</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// =&gt; Infinity</span></span><br></pre></td></tr></table></figure></li></ol><p>可以看到，现在不再出现栈溢出的情况了。另外，为了避免混淆，更好的一种方式是将 <code>factorial</code> 封装到 <code>fac</code> 内部:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fac</span>(<span class="params">n,total</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, total</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">    <span class="comment">// 返回一个 thunk，避免函数调用 </span></span><br><span class="line">    <span class="keyword">return</span> factorial.bind(<span class="literal">null</span>, n<span class="number">-1</span>, n*total);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> trampoline(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> factorial(n, total);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ES6-中的尾递归优化"><a href="#ES6-中的尾递归优化" class="headerlink" title="ES6 中的尾递归优化"></a>ES6 中的尾递归优化</h2><p>在 <strong>ES6</strong> 下，尾递归优化获得了支持，但是在 Babel 最新的 v6 版本中，去掉了对于尾递归函数的 transform，Babel 官方给出了理由如下：</p><blockquote><p>Only explicit self referencing tail recursion was supported due to the complexity and performance impact of supporting tail calls globally. Removed due to other bugs and will be re-implemented.</p></blockquote><p>早先版本的 Babel 对于尾递归的优化可以参看这篇文章：<a href="https://taylodl.wordpress.com/2015/08/09/functional-javascript-tail-call-optimization-and-babel/" target="_blank" rel="noopener">Functional JavaScript – Tail Call Optimization and Babel</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://raganwald.com/2013/03/28/trampolines-in-javascript.html" target="_blank" rel="noopener">Tramponline in Javascript</a><br>   <a href="https://zh.wikipedia.org/wiki/%E5%B0%BE%E8%B0%83%E7%94%A8" target="_blank" rel="noopener">Wiki 尾调用</a><br>   <a href="https://zh.wikipedia.org/wiki/%E5%B0%BE%E8%B0%83%E7%94%A8" target="_blank" rel="noopener">阮一峰 - 尾调用优化</a><br>   <a href="http://www.integralist.co.uk/posts/js-recursion.html" target="_blank" rel="noopener">Understanding recursion in functional JavaScript programming</a><br>   <a href="https://taylodl.wordpress.com/2015/08/09/functional-javascript-tail-call-optimization-and-babel/" target="_blank" rel="noopener">Functional JavaScript – Tail Call Optimization and Babel</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h2&gt;&lt;p&gt;说到递归，我们先来看一个最常见的递归用例：&lt;strong&gt; 计算阶乘 &lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;factorial&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;n&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(n==&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; n*factorial(n&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;测试一下：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;factorial(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// =&amp;gt; 120&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;似乎一切正常，5 的阶乘 120 被正确计算出来了，我们试着把数字调大一些：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;factorial(&lt;span class=&quot;number&quot;&gt;70000&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Uncaught RangeError:Maximum call stack size exceeded(…)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;浏览器提示我们 &lt;strong&gt; 栈溢出 &lt;/strong&gt; 了（测试环境：chrome 51），究竟发生了什么呢?&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript 函数式编程" scheme="http://yoyoyohamapi.me/categories/JavaScript-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="JavaScript" scheme="http://yoyoyohamapi.me/tags/JavaScript/"/>
    
      <category term="函数式编程" scheme="http://yoyoyohamapi.me/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Redux 中间件的实现</title>
    <link href="http://yoyoyohamapi.me/2016/06/23/Redux-%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <id>http://yoyoyohamapi.me/2016/06/23/Redux-的中间件/</id>
    <published>2016-06-23T10:26:18.000Z</published>
    <updated>2018-02-14T17:02:10.260Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>我们知道在 Redux 中，dispatch 的作用在于派发一个 action，该 action 会被 reducer 收到，reducer 根据 action 的类型进行相应的状态（state）维护：</p><div style="text-align:center"><br><img src="https://www.lucidchart.com/publicSegments/view/bc695af5-28c4-432d-ba5f-270905ce996e/image.png" width="500"><br></div><a id="more"></a><p>Redux 的 dispatch 方法被设计得非常轻量，我们不妨查看 Redux 中的 <strong>createStore.js</strong> 源码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 需要 action 是一个纯对象 </span></span><br><span class="line">   <span class="keyword">if</span> (!isPlainObject(action)) &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">       <span class="string">'Actions must be plain objects.'</span> +</span><br><span class="line">       <span class="string">'Use custom middleware for async actions.'</span></span><br><span class="line">     )</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// action 需要声明类型</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">typeof</span> action.type === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">       <span class="string">'Actions may not have an undefined"type"property.'</span> +</span><br><span class="line">       <span class="string">'Have you misspelled a constant?'</span></span><br><span class="line">     )</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 检查是否正在 dispatch 中</span></span><br><span class="line">   <span class="keyword">if</span> (isDispatching) &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Reducers may not dispatch actions.'</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 开始 dispatch, 倘若 dispatch 遇到阻碍(exception), 允许再次 dispatch</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     isDispatching = <span class="literal">true</span></span><br><span class="line">     <span class="comment">// 通过 reducer 来刷新状态</span></span><br><span class="line">     currentState = currentReducer(currentState, action)</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     <span class="comment">// 修复 dispatch 状态, 以便再次发送</span></span><br><span class="line">     isDispatching = <span class="literal">false</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取最新一次(next) 的监听列表, 逐个响应该 dispatch</span></span><br><span class="line">   <span class="keyword">var</span> listeners = currentListeners = nextListeners</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; listeners.length; i++) &#123;</span><br><span class="line">     listeners[i]()</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> action</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现，在 dispatch 实现中，仅能接受和返回一个 plain action 对象：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  type: CLICK</span><br><span class="line">  text: <span class="string">'submit'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><p>在开发环境下，我们要在 dispatch 过程中输出一些日志，比如 dispatch 前后的系统状态变动，可以有如下方式：</p><ul><li>直接在业务代码中添加日志打印：</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> action = addTodo(<span class="string">'Use Redux'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'dispatching'</span>, action)</span><br><span class="line">store.dispatch(action)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'next state'</span>, store.getState())</span><br></pre></td></tr></table></figure><p>目的是达到了，但是并不智慧（代码侵入性太强），我们每需要一个日志打印，就得手动在业务代码中添加，这会使我们业务代码变得肮脏（到处是重复的 <code>console.log</code> ）而难以阅读。</p><ul><li>重新构造一个经过包裹的 dispatch</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatchAndLog</span>(<span class="params">store, action</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'dispatching'</span>, action)</span><br><span class="line">  store.dispatch(action)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'next state'</span>, store.getState())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后，在有日志需求的地方，我们用该 <code>dispatchAndLog</code> 方法替换原有的 <code>dispatch</code> 方法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">dispatchAndLog(store, addTodo(<span class="string">'Use Redux'</span>))</span><br></pre></td></tr></table></figure><p>看起来这样做不错，代码也清爽简洁，但设想这样一种情况，团队的其他人交给我们了一份老旧的代码片，使用的全是 <code>dispatch</code> 方法，为了日志需求，我们不得不定位到每一个 <code>dispatch</code> 进行替换，这口锅你愿意不愿意背？当然还得背，否则 KPI 就要捉急，为了背着不是那么累，还得往下思考。</p><ul><li>Monkey Patching</li></ul><p>在上一种解决方式中，壁垒就是我们得 <strong> 重复 </strong> 替换每一个 <code>dispatch</code> 调用。<code>dispatch</code> 作为 <code>store</code> 的一个方法，保存的是一个方法引用，所以我们可以让 <code>store</code> 的 <code>dispatch</code> 属性重新指向包裹后的引用：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先暂存老的业务逻辑</span></span><br><span class="line"><span class="keyword">let</span> next = store.dispatch</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatchAndLog</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 为老的业务逻辑打上补丁 patching</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'dispatching'</span>, action)</span><br><span class="line">  <span class="keyword">let</span> result = next(action)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'next state'</span>, store.getState())</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 新的逻辑替换掉老的逻辑</span></span><br><span class="line">store.dispatch = dispatchAndLog</span><br></pre></td></tr></table></figure><blockquote><p>Monkey Patching 是一个很常见的技术手段，先在老的业务逻辑上打补丁（patching）形成新的逻辑，再用新的逻辑替换掉老的逻辑，而几乎不影响代码变动。</p></blockquote><p>好像天亮了，在你充满希望的等着上级褒奖时，新的需求来了：在一些场景下，为了保证性能（如惰性求值），我们不想 action 是一个 plain object，而希望它是一个<a href="http://www.ruanyifeng.com/blog/2015/05/thunk.html" target="_blank" rel="noopener"> thunk </a>，为此，我们包裹一个新的 <code>dispatch</code>:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此时，`store.dispatch` 已经拥有了日志功能</span></span><br><span class="line"><span class="keyword">let</span> next = store.dispatch <span class="comment">// 快照老的 `dispatch`</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatchThunk</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> action === <span class="string">'function'</span>)</span><br><span class="line">    <span class="keyword">return</span> action(store)</span><br><span class="line">  <span class="keyword">return</span> next(action) <span class="comment">// 调用老的 `dispatch`</span></span><br><span class="line">&#125;</span><br><span class="line">store.dispatch = dispatchThunk <span class="comment">// 刷新 `dispatch`</span></span><br></pre></td></tr></table></figure><p>此时，我们验证 Monkey Patching 的解决策略在新的需求到来时依然能够从容应对，通过不断的打补丁，我们使得原有的 <code>dispatch</code> 方法不断强大，这个强大体现在两个方面：</p><ol><li>在 <code>dispatch</code> 的执行过程中注入了新的逻辑，例如日志打印</li><li>支持更广泛的 action 类型，不仅可以是 plain object，还可以是 thunk，甚至是 promise</li></ol><p>但是，我们也发现了，代码仍然在这些方面有所重复：</p><ol><li>缓存老的 <code>dispatch</code> 逻辑：</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> next = store.dispatch</span><br></pre></td></tr></table></figure><ol><li>替换 <code>store.dispatch</code>：</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">store.dispatch = dispatchThunk</span><br></pre></td></tr></table></figure><p>对于第一个问题， 我们可以通过参数传递来 <strong> 隐式地 </strong> 缓存老逻辑：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatchAndLog</span>(<span class="params">store, next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">action</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'dispatching'</span>, action)</span><br><span class="line">    <span class="keyword">let</span> result = next(action)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'next state'</span>, store.getState())</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们新的业务代码会变成如下形式：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">store.dispatch = dispatchAndLog(store, store.dispatch)</span><br><span class="line">store.disptach = dispatchThunk(store, store.dispatch)</span><br></pre></td></tr></table></figure><p>如果熟悉函数式编程，我们还可以通过 <a href="https://zh.wikipedia.org/wiki/%E6%9F%AF%E9%87%8C%E5%8C%96" target="_blank" rel="noopener"> curry 化</a> 优化上述代码片:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logger</span>(<span class="params">store</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">next</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'dispatching'</span>, action)</span><br><span class="line">      <span class="keyword">let</span> result = next(action)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'next state'</span>, store.getState())</span><br><span class="line">      <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，代码变成了：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> dispatch = store.dispatch</span><br><span class="line">dispatch = logger(store)(dispatch)</span><br><span class="line">dispatch = thunk(store)(dispatch)</span><br><span class="line">store.dispatch = dispatch</span><br></pre></td></tr></table></figure><p>我们发现，对于 <code>dispatch</code> 的构造，是一个 <strong> 链式（chain）</strong> 的修饰过程，每一个对于现有 <code>dispatch</code> 的改造都可以视为一个 <strong> 中间件（middleware）</strong>， 我们现在封装一个函数表示上述过程：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为 store 设置中间件</span></span><br><span class="line"><span class="comment"> * @param store</span></span><br><span class="line"><span class="comment"> * @paran middlewares &#123;Array&#125; 中间件列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">applyMiddleware</span>(<span class="params">store, middlewares</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 保证 `middlewares` 是一个数组</span></span><br><span class="line">  middlewares = middlewares.slice()</span><br><span class="line">  <span class="comment">// 我们声明的中间件序列最靠外的应当被最后响应</span></span><br><span class="line">  <span class="comment">// 所以最靠外的中间件应当最接近原生的 `dispatch`</span></span><br><span class="line">  middlewares.reverse()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化 `dispatch`</span></span><br><span class="line">  <span class="keyword">let</span> dispatch = store.dispatch</span><br><span class="line">  <span class="comment">// 迭代装饰 `dispatch`</span></span><br><span class="line">  middlewares.forEach(<span class="function"><span class="params">middleware</span> =&gt;</span></span><br><span class="line">    dispatch = middleware(store)(dispatch)</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, store, &#123; dispatch &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK，业务代码现在变成如下形式：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">store = applyMiddleware(store, [thunk, logger])</span><br></pre></td></tr></table></figure><p>这已经是一个非常干练的解决方式了，也非常接近于 Redux 自身提供的 <code>applyMiddleware</code> 的函数实现，但是该函数存在如下两个缺陷：</p><ol><li>将整个 <code>store</code> 暴露给中间件是过剩的，因为这些中间件仅有（1）<strong> 改造 dispatch 方法 </strong>、（2）<strong> 读取当前状态 </strong> 的需求， 所以仅需要暴露给他们 <code>dispatch(action)</code> 及 <code>getState()</code> 就够了，这形成了 Redux 对中间件的约定。</li><li>该方法存在这样一个隐患：可以无休止的应用中间件，如果开发者使用不当，将会产生对 <code>store.dispatch</code> 的重复包装：</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">store = applyMiddleware(store, [thunk, logger])</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">store = applyMiddleware(store, [thunk, logger])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时，日志会被嵌套且重复地打印</span></span><br><span class="line">store.dispatch(action)</span><br></pre></td></tr></table></figure><p>所以，更合理的一种做法是，把应用中间件到 <code>store</code> 的过程放到第一次返回 <code>store</code> 之前， 亦即，在用户拿到 <code>store</code> 对象前，<code>store.disptach</code> 已经被中间件序列包装完毕。</p><p>官方实现的 <code>applyMiddleware</code> 解决了这些问题：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">applyMiddleware</span>(<span class="params">...middlewares</span>) </span>&#123;</span><br><span class="line"> <span class="comment">// 重构了 `createStore` 方法， 保证用户在拿到 `store` 对象前，</span></span><br><span class="line"> <span class="comment">// `store` 对象的 `dispatch` 已经被中间件序列包装完毕</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">createStore</span>) =&gt;</span> (reducer, initialState, enhancer) =&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> store = createStore(reducer, initialState, enhancer)</span><br><span class="line">    <span class="comment">// 原始的 `dispatch`</span></span><br><span class="line">    <span class="keyword">var</span> dispatch = store.dispatch</span><br><span class="line">    <span class="keyword">var</span> chain = []</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 暴露有限的 API 给中间件</span></span><br><span class="line">    <span class="keyword">var</span> middlewareAPI = &#123;</span><br><span class="line">      getState: store.getState,</span><br><span class="line">      <span class="comment">// 通过闭包，每个中间件仅调用最新的 `dispatch`</span></span><br><span class="line">      dispatch: <span class="function">(<span class="params">action</span>) =&gt;</span> dispatch(action)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 利用 curry 化，初始化中间件链</span></span><br><span class="line">    chain = middlewares.map(<span class="function"><span class="params">middleware</span> =&gt;</span> middleware(middlewareAPI))</span><br><span class="line">    <span class="comment">// 利用函数组合，组合各个中间件至最终的 `dispatch` 形态</span></span><br><span class="line">    dispatch = compose(...chain)(store.dispatch)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个通过中间件重构了 `dispatch` 的 `store` 对象</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      ...store,</span><br><span class="line">      dispatch</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到， 该方法实际上是重构了 <code>createStore()</code>, 在官方的 <code>createStore</code> 实现中，我们观察到如下源码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// createStore.js</span></span><br><span class="line"><span class="comment">// 如果传递了 `enhancer`, 就必须保证 `enhancer` 是一个函数</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">'function'</span>) &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected the enhancer to be a function.'</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 如果 `enhancer` 合法, 那么创建 `store` 的行为就放到 `enhancer` 中完成</span></span><br><span class="line">   <span class="keyword">return</span> enhancer(createStore)(reducer, initialState)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们得知，一旦遇到 <code>enhancer</code>（在这里是 <code>applyMiddleware</code>），那么创建 <code>store</code> 的行为就放到 <code>enhancer</code> 中完成，这样就解决了对 <code>store.dispatch</code> 的重复包装问题。</p><p>此外，在 <code>applyMiddleware</code> 中有如下一段代码片很重要：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">dispatch = compose(...chain)(store.dispatch)</span><br></pre></td></tr></table></figure><p>这段代码片中利用了函数式编程中函数组合（composing）的概念，从中间件链中不断抽出函数进行组合（一个 reduce 过程）， 组合方向为从右向左。为什么要进行函数组合呢，回顾之前的代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> dispatch = store.dispatch</span><br><span class="line">dispatch = logger(store)(dispatch)</span><br><span class="line">dispatch = thunk(store)(dispatch)</span><br><span class="line">store.dispatch = dispatch</span><br></pre></td></tr></table></figure><p>该构造过程可以简化为：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">store.dispatch = thunk(store)(logger(store)(dispatch))</span><br></pre></td></tr></table></figure><p>如果了解函数式编程（学习 Redux 必须了解），这样的形式就暗示了我们可以进行函数组合（composing）来组合各个中间件构造最终的 dispatch， 官方的 compose 实现如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// compose.js</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 组合函数</span></span><br><span class="line"><span class="comment"> * @param funcs 待组合函数列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...funcs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (funcs.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">arg</span> =&gt;</span> arg</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 获得起始函数</span></span><br><span class="line">    <span class="keyword">const</span> last = funcs[funcs.length - <span class="number">1</span>]</span><br><span class="line">    <span class="comment">// 获得其余函数</span></span><br><span class="line">    <span class="keyword">const</span> rest = funcs.slice(<span class="number">0</span>, <span class="number">-1</span>)</span><br><span class="line">    <span class="comment">// 通过 `reduceRight`, 从右向左组合函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> rest.reduceRight(<span class="function">(<span class="params">composed, f</span>) =&gt;</span> f(composed), last(...args))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如我们的中间件序列为：<code>[mid1, mid2, mid3]</code>, 那么最终组合成的函数即为：<code>mid1(mid2(mid3(...args)))</code>。 在 <code>dispatch</code> 时，中间件的响应顺序也为 <code>[mid1,mid2,mid3]</code></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们整理一下通过中间件机制增强 dispatch 的过程：</p><h3 id="1-撰写中间件"><a href="#1-撰写中间件" class="headerlink" title="1. 撰写中间件"></a>1. 撰写中间件</h3><p>打补丁，包裹老的业务逻辑到新的业务逻辑形成一个新的中间件，同时将各个中间件按序进行存储，形成一个中间件链。</p><h3 id="2-组合中间件"><a href="#2-组合中间件" class="headerlink" title="2. 组合中间件"></a>2. 组合中间件</h3><p>通过函数组合，新的业务逻辑不断装饰老的业务逻辑。</p><h3 id="3-pipeline"><a href="#3-pipeline" class="headerlink" title="3. pipeline"></a>3. pipeline</h3><p>action 将在各个中间件间流动, 每次流动，都有可能产生新的 action。使用了中间件技术的 dispatch 将会成为一个流通 action 的管道</p><p>现在，具有中间件参与的 dispatch 如下图所示：</p><div style="text-align:center"><br><img src="https://www.lucidchart.com/publicSegments/view/b1fe65ad-1d2f-4bbe-a35e-f287fce57267/image.png" width="500"><br></div><h2 id="举个栗子-–-计数器"><a href="#举个栗子-–-计数器" class="headerlink" title="举个栗子 – 计数器"></a>举个栗子 – 计数器</h2><p>现在，完整的看一个在 Redux 使用中间件的例子 – 一个<a href="https://github.com/yoyoyohamapi/redux-middleware-example" target="_blank" rel="noopener">简单的计数器</a></p><p>首先，我们定义两个中间件：</p><ol><li>日志中间件：输出 dispatch 过程中的一些信息</li><li>thunk 中间件：允许 action 是一个 thunk</li></ol><h3 id="middlewares-js"><a href="#middlewares-js" class="headerlink" title="middlewares.js"></a>middlewares.js</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 日志中间件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> logger = <span class="function">(<span class="params">&#123;dispatch, getState&#125;</span>) =&gt;</span> next =&gt; <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'current state'</span>, getState())</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'dispatching...'</span>, action)</span><br><span class="line">    <span class="keyword">let</span> result = next(action)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'next state'</span>, getState())</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'.........'</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * thunk 中间件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> thunk = <span class="function">(<span class="params">&#123;dispatch, getState&#125;</span>) =&gt;</span> next =&gt; <span class="function"><span class="params">action</span>=&gt;</span></span><br><span class="line">    <span class="keyword">typeof</span> action === <span class="string">'function'</span>?action(dispatch, getState):next(action)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;thunk,logger&#125;</span><br></pre></td></tr></table></figure><h3 id="actions-js"><a href="#actions-js" class="headerlink" title="actions.js"></a>actions.js</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> INCREMENT = <span class="string">'INCREMENT'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> DECREMENT = <span class="string">'DECREMENT'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">increment</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        type: INCREMENT</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">decrement</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        type: DECREMENT</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">incrementIfOdd</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">dispatch, getState</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; counter &#125; = getState();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (counter % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dispatch(increment());</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="reducers-js"><a href="#reducers-js" class="headerlink" title="reducers.js"></a>reducers.js</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; INCREMENT, DECREMENT &#125; <span class="keyword">from</span> <span class="string">'./actions'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">countReducer</span>(<span class="params">state=&#123;counter:<span class="number">0</span>&#125;, action</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> INCREMENT:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123;</span><br><span class="line">                counter: state.counter + <span class="number">1</span></span><br><span class="line">            &#125;)</span><br><span class="line">        <span class="keyword">case</span> DECREMENT:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123;</span><br><span class="line">                counter: state.counter - <span class="number">1</span></span><br><span class="line">            &#125;)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> state</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="index-js"><a href="#index-js" class="headerlink" title="index.js"></a>index.js</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'babel-polyfill'</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"><span class="keyword">import</span>  &#123; increment, decrement, incrementIfOdd &#125; <span class="keyword">from</span> <span class="string">'./actions'</span></span><br><span class="line"><span class="keyword">import</span> &#123; logger, thunk&#125; <span class="keyword">from</span> <span class="string">'./middlerwares'</span></span><br><span class="line"><span class="keyword">import</span> rootReducer <span class="keyword">from</span> <span class="string">'./reducers'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(</span><br><span class="line">    rootReducer,</span><br><span class="line">    applyMiddleware(</span><br><span class="line">        thunk,</span><br><span class="line">        logger</span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">store.dispatch(increment())</span><br><span class="line">store.dispatch(increment())</span><br><span class="line">store.dispatch(decrement())</span><br><span class="line">store.dispatch(incrementIfOdd())</span><br></pre></td></tr></table></figure><p>程序运行结果如下图所示：</p><div style="text-align:center"><br><img src="http://yoyoyohamapi.qiniudn.com/redux-middleware-middleware.png" width="200"><br></div><p>我们用图描述 <code>store.dispatch(incrementIfOdd())</code> 这一过程, 假设当前的 <code>counter</code> 为奇数：</p><div style="text-align:center"><br><img src="https://www.lucidchart.com/publicSegments/view/46caf1d5-08b1-4adf-9016-65461f32a717/image.png" width="500"><br></div><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://redux.js.org/docs/advanced/Middleware.html" target="_blank" rel="noopener">Middlewares</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h2&gt;&lt;p&gt;我们知道在 Redux 中，dispatch 的作用在于派发一个 action，该 action 会被 reducer 收到，reducer 根据 action 的类型进行相应的状态（state）维护：&lt;/p&gt;
&lt;div style=&quot;text-align:center&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://www.lucidchart.com/publicSegments/view/bc695af5-28c4-432d-ba5f-270905ce996e/image.png&quot; width=&quot;500&quot;&gt;&lt;br&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="React" scheme="http://yoyoyohamapi.me/categories/React/"/>
    
    
      <category term="React" scheme="http://yoyoyohamapi.me/tags/React/"/>
    
      <category term="Redux" scheme="http://yoyoyohamapi.me/tags/Redux/"/>
    
  </entry>
  
  <entry>
    <title>Flux 下的组件化开发</title>
    <link href="http://yoyoyohamapi.me/2016/06/20/Flux%E4%B8%8B%E7%9A%84%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/"/>
    <id>http://yoyoyohamapi.me/2016/06/20/Flux下的组件化开发/</id>
    <published>2016-06-20T13:20:30.000Z</published>
    <updated>2018-02-14T17:01:59.662Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Flux-构成"><a href="#Flux-构成" class="headerlink" title="Flux 构成"></a>Flux 构成</h2><p>首先要明确的是，Flux 并不是一个前端框架，而是前端的一个设计模式，一个状态管理机制，其把前端的一个交互流程简单的模拟成了一个单向数据流。</p><div style="text-align:center"><br><img src="http://facebook.github.io/flux/img/flux-simple-f8-diagram-1300w.png" width="500"><br></div><p>在上图中，我们可以看到 Flux 的四个核心构成：</p><a id="more"></a><h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p>一个交互动作, 更多的时候代表一个时间，比如用户在页面组件上的点击（click），失焦（blur），双击（doubleclick）等等。一个 Action 往往由如下两个部分组成：</p><ul><li>交互类型（type）：例如创建、删除、更新等</li><li>交互体（payload）：或者说交互的携带信息，例如创建的文本</li></ul><h3 id="Dispatcher"><a href="#Dispatcher" class="headerlink" title="Dispatcher"></a>Dispatcher</h3><p>Action 分发器。从上图的数据流中，我们可以看到，用户每次产生的 Action 将被送入 Dispatcher，Dispatcher 对 Action 进行简单的包裹之后将其派发到 <strong> 所有 </strong> Store 中。</p><blockquote><p>注意！Dispatcher 的这种广播行为有别于 <strong>Pub/Sub</strong> 模型，在 Pub/Sub 模型中，需要声明订阅的消息类型，然后发布者会像订阅者广播特定类型的消息。而在 Dispatcher 中，Store 向其注册的任意回调接口都不要声明订阅的 Action 类型，即 Store 只告诉 Dispatcher “如果 Action 到来，请你把它发送给我”。当 Dispatcher 派发 Action 时，所有注册到 Dispatcher 的 callback 都会得到响应。回调可以通过简单的 switch-case 来针对不对类型的 Action 做出不同的响应。</p></blockquote><h2 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h2><p>数据仓库，保存了我们某个前端 App 的数据以及对数据的操作。Store 会向 Dispatcher 注册一个回调函数，该回调函数接受一个 Action 作为参数。当 Action 被派发到 Store 时，该回调函数被调用，借由 Action 中描述的 <strong> 交互类型（type）</strong>，Store 进行不同处理，这些处理都将被持久化到 Store 维护的数据对象上。</p><p>Store 完成数据的变更后，由于 Flux 并不是双向数据绑定的，因而即便我们已经持久化了 Store 中的数据，但组件的数据并未得到更新，组件也不会重新渲染。所以，每次数据变动后，为了告知组件去更新数据，Store 会 emit 一个 change 事件。当监听到 change 事件发生，注册到监听器上的回调去完成各个组件的状态更新。</p><h2 id="View"><a href="#View" class="headerlink" title="View"></a>View</h2><p>顾名思义，这就是用户所能看到的视图。有别于传统的 MVC，在 Flux 中，View 并不会和数据模型（Model）产生交互，其只会产生各种交互行为（Actions），这些行为将会被送到 Dispatcher 中，如下图所示：</p><div style="text-align:center"><br><img src="http://facebook.github.io/flux/img/flux-simple-f8-diagram-with-client-action-1300w.png" width="500"><br></div><p>当 View 中维护的状态变动时，View 需要被重新渲染。</p><h2 id="Todo-栗子"><a href="#Todo-栗子" class="headerlink" title="Todo 栗子"></a>Todo 栗子</h2><p>下面我们分析一个用 React+Flux 实现的一个 Flux 栗子，其源码托管在 <a href="https://github.com/facebook/flux/tree/master/examples/flux-todomvc" target="_blank" rel="noopener">github</a>上。</p><p>在项目实践中，面向组件化开发的最佳场景我认为是 <strong> 交互驱动型的开发 </strong>，该定义可能不够准确，其描述的是一旦一个完善的交互设计稿产生后，我们就可以从交互稿中 <strong> 分割 </strong> 出组件，并进行组件的状态 <strong> 分析 </strong>。假设我们得到了 Todo 的交互原型：</p><div style="text-align:center"><br><img src="http://7pulhb.com2.z0.glb.clouddn.com/Flux-Todo%E4%BA%A4%E4%BA%92%E5%8E%9F%E5%9E%8B.png" width="800"><br></div><blockquote><p>这是交互设计师的给我们的原稿，并且，原稿可能远不止这样一幅简单的图像，可能还包括更多的交互效果</p></blockquote><p>我们将会把这个应用拆分为如下组件：</p><h3 id="TodoApp"><a href="#TodoApp" class="headerlink" title="TodoApp"></a>TodoApp</h3><div style="text-align:center"><br><img src="http://7pulhb.com2.z0.glb.clouddn.com/Flux-TodoApp.png" width="500"><br></div><p>通常，在前端面向组件化的开发过程中，我们往往需要一个顶部容器包裹住我们的组件，一个页面可以存在若干个这样的顶部容器，这个容器类似一个集装箱或者盒子，封装了某个页面应用的所有组件和状态。例如，在某视频网站中，视频播放窗口可以作为一个顶部容器，其包裹了播放窗口，进度条，播放选项等各个组件，同时，评论部分也可以作为一个顶部容器，其包裹了评论列表，评论框等组件。</p><p>在 Todo 中，TodoApp 作为一个顶部容器，包裹了所有 Todo 应用需要的组件，这样，我们在应用入口只需要从 TodoApp 开始渲染，进而逐个渲染其子组件。但更为重要的是，TodoApp 将会封装其下各个组件需要用到的状态，通过数据流，各个组件将会收到状态，并且在状态改变时，重新开始渲染自己，最终更新页面内容。</p><h3 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h3><div style="text-align:center"><br><img src="http://7pulhb.com2.z0.glb.clouddn.com/Flux-TodoHeader.png" width="500"><br></div><p>这是一个头部组件，根据交互设计，他除了将保有静态的 “todos” 文字标题以外，还将会具有如下行为：</p><ul><li>右侧输入框失焦或者按下回车键：创建新的 todo 任务</li></ul><p>可以看到，由于 Header 不维护任何状态，所以 Header 是一个 <strong> 无状态（Stateless）</strong> 的组件</p><h3 id="Footer"><a href="#Footer" class="headerlink" title="Footer"></a>Footer</h3><div style="text-align:center"><br><img src="http://7pulhb.com2.z0.glb.clouddn.com/Flux-TodoFooter.png" width="500"><br></div><p>这是一个底部组件，它将显示未完成 todo 数，并能删除所有已完成 todo。首先他需要维护这些 <strong> 状态 </strong>:</p><ul><li><p>所有任务：</p><ul><li>通过遍历任务的完成情况，能获得未完成 todo 任务数</li><li>通过遍历任务的完成情况，统计已完成 todo 任务的信息</li><li>如果当前无任务，隐藏 Footer</li></ul></li></ul><p>因此，在初步的设计中，Footer 是一个 <strong> 有状态（Stateful）</strong> 的组件。后面我们会谈到该做法的不恰当。</p><p>并且，他具有如下行为：</p><ul><li>单击右侧按钮（Clear completed）: 清除所有已完成 todo 任务</li></ul><h3 id="MainSection"><a href="#MainSection" class="headerlink" title="MainSection"></a>MainSection</h3><div style="text-align:center"><br><img src="http://7pulhb.com2.z0.glb.clouddn.com/TodoMainSection.png" width="500"><br></div><p>该组件将会负责渲染所有的以创建任务，因而他需要维护的状态为：</p><ul><li>所有任务</li></ul><p>其具有的行为：</p><ul><li>点击顶部左侧图标按钮：完成 / 取消完成所有任务，具体根据 <strong> 所有任务 </strong> 是否都完成了决定</li></ul><p>因此， MainSection 也是一个有状态的组件。</p><h3 id="TodoItem"><a href="#TodoItem" class="headerlink" title="TodoItem"></a>TodoItem</h3><div style="text-align:center"><br><img src="http://7pulhb.com2.z0.glb.clouddn.com/TodoItem.png" width="500"><br></div><p>这是 todo 项目，每个项目来源于 MainSection 中的迭代，并且该组件具有如下行为：</p><ul><li>单击左侧按钮：完成 / 取消完成该任务</li><li>单击右侧按钮：删除该 todo</li><li>双击 todo 文本：进入下面的编辑模式</li></ul><div style="text-align:center"><br><img src="http://7pulhb.com2.z0.glb.clouddn.com/%E5%8F%8C%E5%87%BB%E8%BF%9B%E5%85%A5%E7%BC%96%E8%BE%91.png" width="500"><br></div><p>我们不难发现，“是否处于编辑模式” 实际上可作为该组件的一个状态，该状态的切换直接影响了该组件的展示和行为，所以，TodoItem 组件应当维护一个状态：</p><ul><li>是否编辑模式</li></ul><p>在编辑模式中，具有如下行为：</p><ul><li>输入框失焦或者按下回车键：更新任务</li></ul><p>可以看到，Header 组件及 TodoItem 组件的中的输入框具有一致的交互行为，所以，我们可以将该输入框提出来作为单独的组件，这也侧面体现了，一份完善的交互设计原型将预测到实现过程中的复用和抽象，避免了一些代码重构的时间。</p><h3 id="TodoTextInput"><a href="#TodoTextInput" class="headerlink" title="TodoTextInput"></a>TodoTextInput</h3><p>现在，我们抽象出一个可复用的输入组件 TodoTextInput 供 Header 和 TodoItem 使用，他需要维护如下状态：</p><ul><li>输入值</li></ul><p>他具有如下行为：</p><ul><li>输入框失焦或者按下回车键：调用存储过程（创建，更新等等）</li></ul><h3 id="组件结构"><a href="#组件结构" class="headerlink" title="组件结构"></a>组件结构</h3><div style="text-align:center"><br><img src="https://www.lucidchart.com/publicSegments/view/0f5014ca-ef30-4eac-8e6a-74a76dfc18d6/image.png" width="500"><br></div><h3 id="状态维护"><a href="#状态维护" class="headerlink" title="状态维护"></a>状态维护</h3><div style="text-align:center"><br><img src="https://www.lucidchart.com/publicSegments/view/1c6988eb-cb2c-4092-8f7f-2cbc11e07c9e/image.png" width="500"><br></div><p>我们发现在 MainSection 和 Footer 组件中都需要维护 <strong>allTodos</strong> 这一状态。由于 MainSection 与 Footer 属于平级的组件，所以，当 MainSection 中的 allTodos 这一状态发生改变时，为使 Footer 中的状态也发生改变，MainSection 中需要保存有 Footer 的引用才能更新到 Footer 的状态，同理，Footer 中也需要保存有 MainSection 的引用。这样，两个组件将会是强耦合的，如下图所示：</p><div style="text-align:center"><br><img src="https://www.lucidchart.com/publicSegments/view/210b9a7b-f8db-4642-bee0-62b8a62dbb33/image.png" width="500"><br></div><p>设想，如果以后还有更多的组件需要 allTodos 这一状态，这一设计模式将会是十分糟糕的，任何一个组件的脱离将可能导致整个引用网络的崩溃。</p><p>既然 allTodos 被多个组件共享，那么我们可以将该状态提升到更上一次的组件中，然后通过 <code>props</code> 传递给子组件。所以，在本例中，最终将 allTodos 提到了顶部容器 TodoApp 中进行维护，这样，通过 TodoApp 的 <code>setState()</code> 方法，所有绑定到 TodoApp 的组件都获得了状态更新，避免了组件间的相互引用，如下图所示：</p><div style="text-align:center"><br><img src="https://www.lucidchart.com/publicSegments/view/0140d060-b037-4ab8-9357-61029d6a14ef/image.png" width="500"><br></div><p>在 React 中，我们应当尽量创建多的无状态（Stateless）的组件，而把共享状态放到上层组件中，使上层组件成为一个有状态（Stateful）的组件。这样，有状态组件封装了交互行为以及与行为互动的状态，子组件通过 <code>props</code> 共享状态并进行数据渲染。更多 <code>state</code> 与 <code>props</code> 的关系和区别可以参看<a href="https://facebook.github.io/react/docs/interactivity-and-dynamic-uis-zh-CN.html" target="_blank" rel="noopener">官方文档</a></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><div style="text-align:center"><br><img src="http://7pulhb.com2.z0.glb.clouddn.com/Flux-%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" width="500"><br></div><p>其中 app.js 为应用的入口文件，从入口开始，逐步构造我们的 App。</p><h4 id="Dispatcher-1"><a href="#Dispatcher-1" class="headerlink" title="Dispatcher"></a>Dispatcher</h4><p><strong>js/AppDispatcher.js</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Dispatcher = <span class="built_in">require</span>(<span class="string">'flux'</span>).Dispatcher;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">new</span> Dispatcher();</span><br></pre></td></tr></table></figure><p>可以看到，TodoMVC 中的 Dispatcher 实现来自于于官方的<a href="https://www.npmjs.com/package/flux" target="_blank" rel="noopener">实现</a>。我们可以看下 Flux 中的 Dispatcher 源码，首先看到 <code>Dispatcher()</code> 构造函数：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dispatcher</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    _classCallCheck(<span class="keyword">this</span>, Dispatcher);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>._callbacks = &#123;&#125;; <span class="comment">// 保存向 Dispatcher 注册回调函数</span></span><br><span class="line">    <span class="keyword">this</span>._isDispatching = <span class="literal">false</span>; <span class="comment">// 是否正在分派 Action</span></span><br><span class="line">    <span class="keyword">this</span>._isHandled = &#123;&#125;; <span class="comment">// 已经完成执行的回调列表</span></span><br><span class="line">    <span class="keyword">this</span>._isPending = &#123;&#125;; <span class="comment">// 正在执行中的回调列表</span></span><br><span class="line">    <span class="keyword">this</span>._lastID = <span class="number">1</span>; <span class="comment">// 回调 Id 的起始标志</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看注册方法 <code>register(callback)</code> , 每个向 Dispatcher 的注册的回调（callback）都拥有唯一 Id 进行标识：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向 Dispatcher 注册回调函数, 每个回调函数都有唯一 id 进行标识</span></span><br><span class="line"><span class="comment"> * @param callback</span></span><br><span class="line"><span class="comment"> * @returns &#123;string&#125; 注册回调的 id</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">Dispatcher.prototype.register = <span class="function"><span class="keyword">function</span> <span class="title">register</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> id = _prefix + <span class="keyword">this</span>._lastID++;</span><br><span class="line">    <span class="keyword">this</span>._callbacks[id] = callback;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据 id 删除回调</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">Dispatcher.prototype.unregister = <span class="function"><span class="keyword">function</span> <span class="title">unregister</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    !<span class="keyword">this</span>._callbacks[id] ? process.env.NODE_ENV !== <span class="string">'production'</span> ? invariant(<span class="literal">false</span>, <span class="string">'Dispatcher.unregister(...): `%s` does not map to a registered callback.'</span>, id) : invariant(<span class="literal">false</span>) : <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>._callbacks[id];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>执行一个注册了的回调函数将经历如下过程：</p><ol><li>标识当前正在执行的回调为进行中（Pending）状态</li><li>将当前待处理的用户行为（payload）送至回调执行</li><li>执行完成，标识该回调已经完成（Handled）</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行回调函数, 该过程为:</span></span><br><span class="line"><span class="comment"> * 1. 标识当前正在执行的回调为 Pending 状态</span></span><br><span class="line"><span class="comment"> * 2. 将 payload 送入回调执行</span></span><br><span class="line"><span class="comment"> * 3. 执行完成, 标识该回调已经完成</span></span><br><span class="line"><span class="comment"> * @internal</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">Dispatcher.prototype._invokeCallback = <span class="function"><span class="keyword">function</span> <span class="title">_invokeCallback</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>._isPending[id] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">this</span>._callbacks[id](<span class="keyword">this</span>._pendingPayload);</span><br><span class="line">    <span class="keyword">this</span>._isHandled[id] = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>派发 <code>dispatch(payload)</code> 指定的用户行为 <code>payload</code> 到所有的 callback 将经历如下过程：</p><p>首先，需要明确的是能够进行派发的前提是当前 Dispatcher 为空闲状态，接下来</p><ol><li>派发前的预处理 <code>startDispatching()</code><ul><li>初始化所有回调的状态</li><li>设置当前正在分发的 <code>payload</code><ul><li>标识当前的 Dispatcher 状态为 “正在进行派发”</li></ul></li></ul></li><li>根据注册顺序依次执行回调 <code>invokeCallback(id)</code></li><li>派发结束后的收尾工作 <code>stopDispatching()</code><ul><li>清除派发对象</li><li>标识当前的 Dispatcher 状态为 “结束派发”</li></ul></li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 派发一个 payload 到所以已注册的 callback 中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">Dispatcher.prototype.dispatch = <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">payload</span>) </span>&#123;</span><br><span class="line">    !!<span class="keyword">this</span>._isDispatching ? process.env.NODE_ENV !== <span class="string">'production'</span> ? invariant(<span class="literal">false</span>, <span class="string">'Dispatch.dispatch(...): Cannot dispatch in the middle of a dispatch.'</span>) : invariant(<span class="literal">false</span>) : <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">this</span>._startDispatching(payload);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> id <span class="keyword">in</span> <span class="keyword">this</span>._callbacks) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>._isPending[id]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>._invokeCallback(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>._stopDispatching();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分发 payload 前的初始化:</span></span><br><span class="line"><span class="comment"> * 1. 初始化所有回调的状态</span></span><br><span class="line"><span class="comment"> * 2. 设置当前正在分发的 payload</span></span><br><span class="line"><span class="comment"> * 3. 标识当前 "正在进行派发"</span></span><br><span class="line"><span class="comment"> * @internal</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">Dispatcher.prototype._startDispatching = <span class="function"><span class="keyword">function</span> <span class="title">_startDispatching</span>(<span class="params">payload</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> id <span class="keyword">in</span> <span class="keyword">this</span>._callbacks) &#123;</span><br><span class="line">        <span class="keyword">this</span>._isPending[id] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">this</span>._isHandled[id] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>._pendingPayload = payload;</span><br><span class="line">    <span class="keyword">this</span>._isDispatching = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 结束派发时的收尾工作</span></span><br><span class="line"><span class="comment"> * 1. 清除派发对象</span></span><br><span class="line"><span class="comment"> * 2. 标识当前 "结束派发"</span></span><br><span class="line"><span class="comment"> * @internal</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">Dispatcher.prototype._stopDispatching = <span class="function"><span class="keyword">function</span> <span class="title">_stopDispatching</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>._pendingPayload;</span><br><span class="line">    <span class="keyword">this</span>._isDispatching = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>waitFor</strong></p><p>再看 Dispatcher 中一个很重要的方法: <code>waitFor(ids)</code>, 顾名思义，该方法的作用是：等待其他向 Dispatcher 注册了的回调执行完成。因而，该方法主要保证了 dispatch 时，待响应的回调函数的执行的 <strong> 顺序性 </strong>。</p><p>例如，在一个航班订票系统中，我们首先要选择完国家（Country），才能选择城市（City），所以，当一个类型为 “更新所选国家”的交互被送到 <code>CityStore</code> 所注册的回调时，为了保证能正确的选择更新后国家的城市，我们需要这样做：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">CityStore.dispatchToken = flightDispatcher.register(<span class="function"><span class="keyword">function</span>(<span class="params">payload</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (payload.actionType === <span class="string">'country-update'</span>) &#123;</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 如果不执行 waitFor(), 由于程序的异步性，那么可能 CityStore 的回调先于 ContryStore 的回调执行 </span></span><br><span class="line"><span class="comment">        * 此时的国家尚未更新，得到的默认城市是错误的，而并不是最新的</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">       flightDispatcher.waitFor([CountryStore.dispatchToken]);</span><br><span class="line">       <span class="comment">// waitFor() 保证了 ContryStore 先响应了'country-update'，即保证了国家更新先于城市更新</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 此时我们能正确的选择该国家的城市</span></span><br><span class="line">       CityStore.city = getDefaultCityForCountry(CountryStore.country);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>下面我们看 <code>waitFor()</code> 的源码实现：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 等待指定的回调完成</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">Dispatcher.prototype.waitFor = <span class="function"><span class="keyword">function</span> <span class="title">waitFor</span>(<span class="params">ids</span>) </span>&#123;</span><br><span class="line">    !<span class="keyword">this</span>._isDispatching ? process.env.NODE_ENV !== <span class="string">'production'</span> ? invariant(<span class="literal">false</span>, <span class="string">'Dispatcher.waitFor(...): Must be invoked while dispatching.'</span>) : invariant(<span class="literal">false</span>) : <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> ii = <span class="number">0</span>; ii &lt; ids.length; ii++) &#123;</span><br><span class="line">        <span class="keyword">var</span> id = ids[ii];</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>._isPending[id]) &#123;</span><br><span class="line">            !<span class="keyword">this</span>._isHandled[id] ? process.env.NODE_ENV !== <span class="string">'production'</span> ? invariant(<span class="literal">false</span>, <span class="string">'Dispatcher.waitFor(...): Circular dependency detected while'</span> + <span class="string">'waiting for `%s`.'</span>, id) : invariant(<span class="literal">false</span>) : <span class="literal">undefined</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        !<span class="keyword">this</span>._callbacks[id] ? process.env.NODE_ENV !== <span class="string">'production'</span> ? invariant(<span class="literal">false</span>, <span class="string">'Dispatcher.waitFor(...): `%s` does not map to a registered callback.'</span>, id) : invariant(<span class="literal">false</span>) : <span class="literal">undefined</span>;</span><br><span class="line">        <span class="keyword">this</span>._invokeCallback(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Store-1"><a href="#Store-1" class="headerlink" title="Store"></a>Store</h4><p>在 <strong>js/stores/TodoStore.js</strong> 中：</p><p>首先，我们维护我们的数据对象，并提供若干对于该数据的操作：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 保存 TODO 列表</span></span><br><span class="line"><span class="keyword">var</span> _todos = &#123;&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个 Todo</span></span><br><span class="line"><span class="comment"> * @param text &#123;string&#125; Todo 内容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 更新一个 TODO item</span></span><br><span class="line"><span class="comment"> * @param id &#123;string&#125;</span></span><br><span class="line"><span class="comment"> * @param updates &#123;object&#125; 待更新对象的属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params">id, updates</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据一个更新属性值对象更新所有 Todo</span></span><br><span class="line"><span class="comment"> * @param updates &#123;object&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateAll</span>(<span class="params">updates</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除 Todo</span></span><br><span class="line"><span class="comment"> * @param id &#123;string&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">destroy</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除所有的已完成的 TODO items</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">destroyCompleted</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后导出一个全局单例，该单例提供了常用的外部访问接口，并且通过 node 提供的 <code>EventEmitter</code> 来实现事件的派发和监听：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> TodoStore = assign(&#123;&#125;, EventEmitter.prototype, &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否所有 TODO 都已完成</span></span><br><span class="line"><span class="comment">     * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    areAllComplete: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得所有的 TODO</span></span><br><span class="line"><span class="comment">     * @returns &#123;object&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    getAll: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送变更事件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    emitChange: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加变更事件监听</span></span><br><span class="line"><span class="comment">     * @param callback</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    addChangeListener: <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 一旦受到变更事件, 触发回调</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         *   例如, 当我们创建一条 todo 时,</span></span><br><span class="line"><span class="comment">         *   TodoStore 将会发出一条变更事件,</span></span><br><span class="line"><span class="comment">         *   上游的状态维护器将会调用 callback 进行状态更新</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">this</span>.on(CHANGE_EVENT, callback);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除变更事件监听</span></span><br><span class="line"><span class="comment">     * @param callback</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    removeChangeListener: <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.removeListener(CHANGE_EVENT, callback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>最后，我们需要向 <code>AppDispatcher</code> 注册回调函数，以便在 <code>payload</code> 被分发到 TodoStore 时，TodoStore 能做出响应：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">AppDispatcher.register(<span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> text;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据不同的 action 类型(即不同的交互逻辑), 执行不同过程</span></span><br><span class="line">    <span class="keyword">switch</span> (action.actionType) &#123;</span><br><span class="line">        <span class="keyword">case</span> TodoConstants.TODO_CREATE:</span><br><span class="line">            text = action.text.trim();</span><br><span class="line">            <span class="keyword">if</span>( text!==<span class="string">''</span>) &#123;</span><br><span class="line">                create(text);</span><br><span class="line">                <span class="comment">// 一旦变更, 发出变更事件,</span></span><br><span class="line">                TodoStore.emitChange();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> TodoConstants.TODO_TOGGLE_COMPLETE_ALL:</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> TodoConstants.TODO_UNDO_COMPLETE:</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> TodoConstants.TODO_COMPLETE:</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> TodoConstants.TODO_UPDATE_TEXT:</span><br><span class="line">           <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> TodoConstants.TODO_DESTROY:</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> TodoConstants.TODO_DESTROY_COMPLETED:</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// no op</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>! 注意, 在回调执行过程中，如果发生状态的变动，需要抛出 change 事件，这样才能将组建的状态也更新（通过回调）。</p></blockquote><h4 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h4><p>我们将 TodoApp 中常见的 Action 都封装到了 <strong>js/TodoActions.js</strong> 中, 通过其中的 <code>AppDispatcher</code> 单例，我们可以将 Action 派发出去:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> TodoActions = &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建行为 </span></span><br><span class="line"><span class="comment">     * @param text &#123;string&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    create: <span class="function"><span class="keyword">function</span> (<span class="params">text</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 将创建行为送到 Dispatcher, Dispatcher 派发这个行为(action 对象) 到各个 Store</span></span><br><span class="line">        AppDispatcher.dispatch(&#123;</span><br><span class="line">            actionType: TodoConstants.TODO_CREATE,</span><br><span class="line">            text: text</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新行为</span></span><br><span class="line"><span class="comment">     * @param id &#123;string&#125;</span></span><br><span class="line"><span class="comment">     * @param text &#123;string&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    updateText: <span class="function"><span class="keyword">function</span> (<span class="params">id, text</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 全部设置为完成</span></span><br><span class="line"><span class="comment">     * @param todo</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    toggleComplete: <span class="function"><span class="keyword">function</span> (<span class="params">todo</span>) </span>&#123;</span><br><span class="line">       <span class="comment">// ...</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 标记所有的 Todo 为已完成</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    toggleCompleteAll: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    destroy: <span class="function"><span class="keyword">function</span> (<span class="params">id</span>) </span>&#123;</span><br><span class="line">       <span class="comment">// ...</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除所有已完成的 Todo</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    destroyCompleted: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Components"><a href="#Components" class="headerlink" title="Components"></a>Components</h4><p>下面开始实现各个组件，个人偏向的流程是先在组件目录下创建好各个空白组件，之后再依序进行装填：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> React = <span class="built_in">require</span>(<span class="string">'react'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Header = React.createClass(&#123;</span><br><span class="line"></span><br><span class="line">    render: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span>:render</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Header;</span><br></pre></td></tr></table></figure><p>装填顺序我会选择先装填顶部容器（此例中即为 TodoApp ），之后按照 DOM 树 <strong> 自底向上 </strong> 地进行装填:</p><p><strong>TodoApp.react.js</strong>:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Footer = <span class="built_in">require</span>(<span class="string">'./Footer.react'</span>);</span><br><span class="line"><span class="keyword">var</span> Header = <span class="built_in">require</span>(<span class="string">'./Header.react'</span>);</span><br><span class="line"><span class="keyword">var</span> MainSection = <span class="built_in">require</span>(<span class="string">'./MainSection.react'</span>);</span><br><span class="line"><span class="keyword">var</span> React = <span class="built_in">require</span>(<span class="string">'react'</span>);</span><br><span class="line"><span class="keyword">var</span> TodoStore = <span class="built_in">require</span>(<span class="string">'../stores/TodoStore'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在根 DOM 下维护状态,</span></span><br><span class="line"><span class="comment">// 这样的状态往往是共享状态(会向下传递的状态)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTodoState</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        allTodos: TodoStore.getAll(),</span><br><span class="line">        areAllComplete: TodoStore.areAllComplete()</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> TodoApp = React.createClass(&#123;</span><br><span class="line">    getInitialState: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getTodoState();</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定生命期 -- 挂载</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    componentDidMount: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 挂载时再为 TodoStore 添加监听器</span></span><br><span class="line">        TodoStore.addChangeListener(<span class="keyword">this</span>._onChange);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    componentWillUnmount: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        TodoStore.removeChangeListener(<span class="keyword">this</span>._onChange);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    render: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;Header /&gt;</span><br><span class="line">                &lt;MainSection</span><br><span class="line">                    allTodos=&#123;<span class="keyword">this</span>.state.allTodos&#125;</span><br><span class="line">                    areAllComplete=&#123;<span class="keyword">this</span>.state.areAllComplete&#125;</span><br><span class="line">                /&gt;</span><br><span class="line">                &lt;Footer allTodos=&#123;<span class="keyword">this</span>.state.allTodos&#125;/&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    /</span>**</span><br><span class="line">     * Event handler <span class="keyword">for</span> <span class="string">'change'</span> events coming <span class="keyword">from</span> the TodoStore</span><br><span class="line">     *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">    _onChange: function() &#123;</span></span><br><span class="line"><span class="regexp">        this.setState(getTodoState());</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">module.exports = TodoApp;</span></span><br></pre></td></tr></table></figure><blockquote><p>为了方便，TodoApp 不仅维护 allTodos 这个状态，还维护 areAllComplete，该状态主要服务于 MainSection 中的 “完成所有 / 取消完成所有任务” 这一用例，避免重复遍历 allTodos 的开销。</p></blockquote><p>我们可以看到，TodoApp 提供了一个 <code>onChange()</code> 方法作为 TodoStore 的 <code>change</code> 事件的回调，当 TodoStore 发出 change 事件时，TodoApp 将刷新状态，借此通知其下组件如 MainSection 等重新渲染。</p><p>更多组件的实现不再赘述。下面着重介绍 Flux 的工作流程</p><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>我们以 创建新的 Todo 这一工作流程为例展示 Flux 的工作过程。在 Flux 中，该流程如下图所示：</p><div style="text-align:center"><br><img src="https://www.lucidchart.com/publicSegments/view/49534565-8e62-4836-a6ca-e616269ba094/image.png" width="500"><br></div><p>（1） 我们在 TodoTextInput 中敲入数据，在输入框上，我们监听了 <strong> 失焦(onBlur)</strong> 和 <strong> 按下键盘按键(onKeyDown)</strong> 的事件：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js/components/TodoTextInput.react.js</span></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @return &#123;object&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) /*<span class="title">object</span>*/ </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;input</span><br><span class="line">        className=&#123;<span class="keyword">this</span>.props.className&#125;</span><br><span class="line">        id=&#123;<span class="keyword">this</span>.props.id&#125;</span><br><span class="line">        placeholder=&#123;<span class="keyword">this</span>.props.placeholder&#125;</span><br><span class="line">        onBlur=&#123;<span class="keyword">this</span>._save&#125;</span><br><span class="line">        onChange=&#123;<span class="keyword">this</span>._onChange&#125;</span><br><span class="line">        onKeyDown=&#123;<span class="keyword">this</span>._onKeyDown&#125;</span><br><span class="line">        value=&#123;<span class="keyword">this</span>.state.value&#125;</span><br><span class="line">        autoFocus=&#123;<span class="literal">true</span>&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>当事件发生时，调用 <code>save()</code> 方法进行处理：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_save: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.props.onSave(<span class="keyword">this</span>.state.value);</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      value: <span class="string">''</span></span><br><span class="line">    &#125;);</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><p>（2） 在 Header 组件中，我们通过为 TodoTextInput 指定 <code>onSave</code> 属性（props）来确定当输入域发生变化后的执行逻辑，使得我们在 TodoTextInput 的状态发生改变时，能够发出一个 “创建行为” 到 Dispatcher：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js/components/Header.react.js</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @return &#123;object&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;header id=<span class="string">"header"</span>&gt;</span><br><span class="line">        &lt;h1&gt;todos&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;TodoTextInput</span></span><br><span class="line"><span class="regexp">          id="new-todo"</span></span><br><span class="line"><span class="regexp">          placeholder="What needs to be done?"</span></span><br><span class="line"><span class="regexp">          onSave=&#123;this._onSave&#125;</span></span><br><span class="line"><span class="regexp">        /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/header&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  /</span>**</span><br><span class="line">   * Event handler called within TodoTextInput.</span><br><span class="line">   * Defining <span class="keyword">this</span> here allows TodoTextInput to be used <span class="keyword">in</span> multiple places</span><br><span class="line">   * <span class="keyword">in</span> different ways.</span><br><span class="line">   * @param &#123;string&#125; text</span><br><span class="line">   *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">  _onSave: function(text) &#123;</span></span><br><span class="line"><span class="regexp">    if (text.trim())&#123;</span></span><br><span class="line"><span class="regexp">      TodoActions.create(text);</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br></pre></td></tr></table></figure><p>我们之所以不在 TodoTextInput 中写死 <code>TodoActions.create(text)</code> 主要是考虑到组件的可扩展性。“输入域变动后的存储逻辑”更应当被设计为一种配置，通过在不同场景下指定其 <code>onSave</code> 属性（prop），使得 TodoTextInput 更加通用。</p><p>（3） 在 <code>TodoActions.create()</code> 中，我们将 Action 送到 Dispatcher，并由其派发一个 “创建 Action”到<br>TodoStore：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js/actions/TodoActions.js</span></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @param  &#123;string&#125; text</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  create: <span class="function"><span class="keyword">function</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">    AppDispatcher.dispatch(&#123;</span><br><span class="line">      actionType: TodoConstants.TODO_CREATE,</span><br><span class="line">      text: text</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>（4） TodoStore 在接收到 Dispatcher 派发来的 Action 之后，其向 Dispatcher 注册的回调被调用, 新的 todo 会被持久化，并因此引起了 TodoStore 维护的 todos 的改变，所以 TodoStore 会抛出一个 change 事件：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js/stores/TodoStore.js</span></span><br><span class="line">AppDispatcher.register(<span class="function"><span class="keyword">function</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> text;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span>(action.actionType) &#123;</span><br><span class="line">    <span class="keyword">case</span> TodoConstants.TODO_CREATE:</span><br><span class="line">      text = action.text.trim();</span><br><span class="line">      <span class="keyword">if</span> (text !== <span class="string">''</span>) &#123;</span><br><span class="line">        create(text);</span><br><span class="line">        TodoStore.emitChange();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...  </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="comment">// no op</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>（5）由于 TodoApp 向 TodoStore 订阅了 change 事件：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js/components/TodoApp.react.js</span></span><br><span class="line">componentDidMount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    TodoStore.addChangeListener(<span class="keyword">this</span>._onChange);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>此时，change 事件发生，回调 <code>onChange()</code> 被触发, TodoApp 维护的状态得到更新：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Event handler for 'change' events coming from the TodoStore</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> _onChange: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.setState(getTodoState());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>（6） 由于 MainSection 及 Footer 组件中的属性（prop）绑定了 TodoApp 维护的状态，所以在 TodoApp 刷新状态 <code>setState()</code> 后，二者将会被重新渲染。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Flux-构成&quot;&gt;&lt;a href=&quot;#Flux-构成&quot; class=&quot;headerlink&quot; title=&quot;Flux 构成&quot;&gt;&lt;/a&gt;Flux 构成&lt;/h2&gt;&lt;p&gt;首先要明确的是，Flux 并不是一个前端框架，而是前端的一个设计模式，一个状态管理机制，其把前端的一个交互流程简单的模拟成了一个单向数据流。&lt;/p&gt;
&lt;div style=&quot;text-align:center&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://facebook.github.io/flux/img/flux-simple-f8-diagram-1300w.png&quot; width=&quot;500&quot;&gt;&lt;br&gt;&lt;/div&gt;

&lt;p&gt;在上图中，我们可以看到 Flux 的四个核心构成：&lt;/p&gt;
    
    </summary>
    
      <category term="React" scheme="http://yoyoyohamapi.me/categories/React/"/>
    
    
      <category term="JavaScript" scheme="http://yoyoyohamapi.me/tags/JavaScript/"/>
    
      <category term="React" scheme="http://yoyoyohamapi.me/tags/React/"/>
    
      <category term="Flux" scheme="http://yoyoyohamapi.me/tags/Flux/"/>
    
  </entry>
  
  <entry>
    <title>深入理解 throttle 与 debounce</title>
    <link href="http://yoyoyohamapi.me/2016/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-throttle-%E4%B8%8E-debounce/"/>
    <id>http://yoyoyohamapi.me/2016/05/29/深入理解-throttle-与-debounce/</id>
    <published>2016-05-29T00:26:38.000Z</published>
    <updated>2018-08-11T14:20:10.016Z</updated>
    
    <content type="html"><![CDATA[<p>我们先来看一个前端开发中遇到的场景：</p><blockquote><p>在页面中，我们有一个 “查询” 按钮，单击该按钮，会通过 <strong>ajax</strong> 异步查询一些数据</p></blockquote><p>假设这个查询是耗时的，并且会给后端造成一定压力，那么如果短时间内我们频繁点击该按钮，请求就会不断发出，这样给后端造成的压力是难以想象的。因此，我们会想到控制我们的查询速率。</p><a id="more"></a><h2 id="独占型提交"><a href="#独占型提交" class="headerlink" title="独占型提交"></a>独占型提交</h2><p>通过设置一个 <code>flag</code> 来标识当前状态为正在请求中，如果已在请求中，则不允许再次请求，请求完成，刷新该 <code>flag</code> 来允许新的请求提交：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isQuerying = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sendQuery = <span class="function"><span class="keyword">function</span>(<span class="params">complete</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果已经在查询了，那么需要等待 </span></span><br><span class="line">  <span class="keyword">if</span>(isQuerying)&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"waiting"</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"send query"</span>);</span><br><span class="line">  <span class="comment">// 标识当前正在查询中 </span></span><br><span class="line">  isQuerying = <span class="literal">true</span>;</span><br><span class="line">  <span class="comment">// 我们模拟一个耗时操作 </span></span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   complete &amp;&amp; complete();    </span><br><span class="line">  &#125;,<span class="number">2000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> complete = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 在回调中， 我们刷新标记量 </span></span><br><span class="line">   isQuerying = <span class="literal">false</span>;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"completed"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$(<span class="string">"#queryBtn"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;sendQuery(complete);&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试一下， 可以看到新的请求不再立即被送出 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++) &#123;</span><br><span class="line">  $(<span class="string">"#queryBtn"</span>).click();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="节制型提交"><a href="#节制型提交" class="headerlink" title="节制型提交"></a>节制型提交</h2><p>在独占型提交中，如果一个请求已经在进行中，那么再多的点击都会被废弃。如果我们只是想限制请求速率，而不想废弃掉之后的点击，那我们得考虑新的提交方式。回归到限制提交的问题本质：</p><blockquote><p>控制回调发生的速率, 不需要回调发生那么快</p></blockquote><p>但是，如果我们新建一个 wrapper 来包裹一下 <code>sendQuery</code> 业务：在 <code>click</code> 事件后，不会直接调用 <code>sendQuery</code>，而是调用 wrapper，在 wrapper 的执行过程中，我们有选择地考虑是否执行 <code>sendQuery</code>，借此控制住 <code>sendQuery</code> 的调用频率。</p><p>假设我们想至少等待 1s 才能发出一次新的查询请求，即请求的调用频次不能超过 <strong>1 次 / 秒 </strong>，可以这样设计：</p><ol><li>开始：<code>click</code> 事件到来， wrapper 被调用<br>.    获得当前时间，比较当前时间距上次 <code>sendQuery</code> 执行的时间是否已经足够 <code>1s</code> 。<br>.    如果已经足够，那么这次查询请求可以立即被执行，否则计算应该等待的时间，延后执行该请求。</li></ol><p>看代码:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> previous = <span class="number">0</span>； <span class="comment">// 记录上次执行的时间点 </span></span><br><span class="line"><span class="keyword">var</span> waiting = <span class="number">1000</span>; <span class="comment">// 需要等待的时间 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sendQuery = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 执行的时候， 刷新 previous</span></span><br><span class="line">  previous = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"sending query"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获得当前时间 </span></span><br><span class="line">  <span class="keyword">var</span> now = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();</span><br><span class="line">  <span class="comment">// 获得需要等待的时间 </span></span><br><span class="line">  <span class="keyword">var</span> remain = waiting-(now-previous);</span><br><span class="line">  <span class="comment">// 判断是否立即执行 </span></span><br><span class="line">  <span class="keyword">if</span>(remain&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">    sendQuery();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    setTimeout(sendQuery, remain);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了防止变量的全局污染， 我们再用一个立即执行函数包裹下作用域：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> delayedQuery = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> previous = <span class="number">0</span>; <span class="comment">// 记录上次执行的时间点 </span></span><br><span class="line">  <span class="keyword">var</span> waiting = <span class="number">1000</span>; <span class="comment">// 需要等待的时间 </span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> sendQuery = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 执行的时候， 刷新 previous</span></span><br><span class="line">    previous = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"sending query"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获得当前时间 </span></span><br><span class="line">    <span class="keyword">var</span> now = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();</span><br><span class="line">    <span class="comment">// 获得需要等待的时间 </span></span><br><span class="line">    <span class="keyword">var</span> remain = waiting - (now - previous);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"need waiting"</span> + remain + <span class="string">"ms"</span>);</span><br><span class="line">    <span class="comment">// 判断是否立即执行 </span></span><br><span class="line">    <span class="keyword">if</span> (remain &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"immediately"</span>);</span><br><span class="line">      sendQuery();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"delayed"</span>);</span><br><span class="line">      setTimeout(sendQuery, remain);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">$(<span class="string">"#queryBtn"</span>).click(delayedQuery);</span><br></pre></td></tr></table></figure><p>但是，我们的业务代码 <code>sendQuery</code> 还是耦合了刷新 <code>previous</code> 的逻辑。其次，如果每个延迟执行的诉求都要去做这样一个包裹，样板代码就显得太多了。现在我们撰写一个通用函数，我们将（1）<strong> 需要控制调用频度的函数 </strong> 和（2）<strong> 对调用频度的限制平率 </strong> 告诉通用函数，它返回一个限制了执行频率的函数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * throttle</span></span><br><span class="line"><span class="comment"> * @param &#123;Function&#125; func 待控制频率的函数 </span></span><br><span class="line"><span class="comment"> * @param &#123;Number&#125; waiting 每次调用的最小等待周期 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func,waiting</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> previous = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个 func 的 wrapper，如要是解耦 func 与 previous 等变量 </span></span><br><span class="line">  <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 刷新 previous</span></span><br><span class="line">    previous = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();</span><br><span class="line">    <span class="comment">// 执行调用 </span></span><br><span class="line">    func();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回一个被控制了调用频率的 </span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获得当前时间 </span></span><br><span class="line">      <span class="keyword">var</span> now = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();</span><br><span class="line">      <span class="comment">// 获得需要等待的时间 </span></span><br><span class="line">      <span class="keyword">var</span> remain = waiting - (now - previous);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"need waiting"</span> + remain + <span class="string">"ms"</span>);</span><br><span class="line">      <span class="comment">// 判断是否立即执行 </span></span><br><span class="line">      <span class="keyword">if</span> (remain &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"immediately"</span>);</span><br><span class="line">        later();</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"delayed"</span>);</span><br><span class="line">        setTimeout(later, remain);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在，刷新 previous 不再需要耦合到 sendQuery 中 </span></span><br><span class="line"><span class="keyword">var</span> sendQuery = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"sending query"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">delayedQuery = throttle(sendQuery,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p><a href="https://jsfiddle.net/softshot/r6uh3xug/2/" target="_blank" rel="noopener">查看演示</a></p><h2 id="Underscore-中的-throttle"><a href="#Underscore-中的-throttle" class="headerlink" title="Underscore 中的 throttle"></a>Underscore 中的 throttle</h2><p>可以看出来， 这里我已经用了 <code>throttle</code> 来命名我们的函数了，<code>throttle</code>，也就是节流阀的意思，很形象是吧，通过这样一个阀门，我们限制函数的执行频次。</p><p>但是在上面的代码中，还有一点小问题，一些查询请求虽然被延迟执行了，但是在某个时间点，他们好像一起执行了，这是因为 <code>setTimeout(func, wait)</code> 并不能保证 <code>func</code> 的执行开始时间，只能保证 <code>func</code> 在不早于从现在起到 <code>wait</code> 毫秒后发生。所以被延后执行的那些查询在某个相近的时间点同时发生了。</p><p>出现这个错误的原因就是：</p><blockquote><p>我们只保障了 <strong> 第一次回调 </strong> 和 <strong> 接下来所有回调 </strong> 的间隔执行，而没有保障到各个回调间相互的间隔执行。</p></blockquote><p>下面可以看一下 Underscore 中 <code>throttle</code> 的实现，比刚才我们写的 throttle 函数健壮许多。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.throttle = <span class="function"><span class="keyword">function</span> (<span class="params">func, wait, options</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// timeout 标识最近一次被追踪的调用 </span></span><br><span class="line">    <span class="comment">// context 和 args 缓存 func 执行时需要的上下文，result 缓存 func 执行结果 </span></span><br><span class="line">    <span class="keyword">var</span> timeout, context, args, result;</span><br><span class="line">    <span class="comment">// 最近一次 func 被调用的时间点 </span></span><br><span class="line">    <span class="keyword">var</span> previous = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!options) options = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个延后执行的函数包裹住 func 的执行过程 </span></span><br><span class="line">    <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 执行时，刷新最近一次调用时间 </span></span><br><span class="line">        previous = options.leading === <span class="literal">false</span> ? <span class="number">0</span> : _.now();</span><br><span class="line">        <span class="comment">// 清空为此次执行设置的定时器 </span></span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">        result = func.apply(context, args);</span><br><span class="line">        <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个 throttle 化的函数 </span></span><br><span class="line">    <span class="keyword">var</span> throttled = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 我们尝试调用 func 时，会首先记录当前时间戳 </span></span><br><span class="line">        <span class="keyword">var</span> now = _.now();</span><br><span class="line">        <span class="comment">// 是否是第一次调用 </span></span><br><span class="line">        <span class="keyword">if</span> (!previous &amp;&amp; options.leading === <span class="literal">false</span>) previous = now;</span><br><span class="line">        <span class="comment">// func 还要等待多久才能被调用 = 预设的最小等待期 -（当前时间 - 上一次调用的时间）</span></span><br><span class="line">        <span class="keyword">var</span> remaining = wait - (now - previous);</span><br><span class="line">        <span class="comment">// 记录执行时需要的上下文和参数 </span></span><br><span class="line">        context = <span class="keyword">this</span>;</span><br><span class="line">        args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="comment">// 如果计算后能被立即执行 </span></span><br><span class="line">        <span class="keyword">if</span> (remaining &lt;= <span class="number">0</span> || remaining &gt; wait) &#123;</span><br><span class="line">            <span class="comment">// 清除之前的设置的延时执行，就不存在某些回调一同发生的情况了 </span></span><br><span class="line">            <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">                clearTimeout(timeout);</span><br><span class="line">                timeout = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 刷新最近一次 func 调用的时间点 </span></span><br><span class="line">            previous = now;</span><br><span class="line">            <span class="comment">// 执行 func 调用 </span></span><br><span class="line">            result = func.apply(context, args);</span><br><span class="line">            <span class="comment">// 再次检查 timeout，因为 func 执行期间可能有新的 timeout 被设置，如果 timeout 被清空了，代表不再有等待执行的 func，也清空 context 和 args</span></span><br><span class="line">            <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!timeout &amp;&amp; options.trailing !== <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果设置了 trailing edge，那么暂缓此次调用尝试的执行 </span></span><br><span class="line">            timeout = setTimeout(later, remaining);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不再控制函数执行调用频率 </span></span><br><span class="line">    throttled.cancel = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">        previous = <span class="number">0</span>;</span><br><span class="line">        timeout = context = args = <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> throttled;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>与我们所写的 <code>throttle</code> 不同的是，Underscore 中的 <code>throttle</code> 并不需要为每次回调都设置一个定时器来延后执行。他的定时器只记录最新一次的调用尝试。比如 <code>waiting</code> 为 <code>1s</code>，在 <code>1.5s</code> 内我们单击了查询按钮 <code>20</code> 次，真正会被送出的查询只有至多两次，分别是第一次和最后一次。这就不会出现上面延时中出现的 “某时刻一些延时函数同时发生” 的情况了。</p><p>在 Underscore 的 <code>throttle</code> 实现中，有个令人疑惑的判断条件：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (remaining &lt;= <span class="number">0</span> || remaining &gt; wait) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当该条件成立时， 可以立即执行 <code>func</code>，<code>remaining&lt;=0</code> 的条件很容易理解，就是 <strong> 不再需要等待时 </strong> 可以执行，那么如何理解 <code>remaining &gt; wait</code> 呢?</p><p>显然，<code>remaining&gt;wait</code> 等同于 <code>now&lt;previous</code>， 亦即：<code>previous</code> 的被刷新晚于 <code>now</code> 的被设置。</p><p>这种情况就发生在我们当前尝试调用时，并且设置了当前时间点 <code>now</code> 之后，上次延时的函数 <code>later</code> 开始了执行， 并刷新了 <code>previous</code>，此时出现了 <code>now</code> 早于 <code>previous</code> 的情况。举个栗子：</p><ol><li>开始时，我们 <code>click</code> 了一次查询按钮，我们将之命名为 <code>click1</code>，此时 <code>previous==0</code><br>.    在 <code>0.4s</code> 时我们 <code>click</code> 了一次查询按钮 <code>click2</code>，<code>now==0.4</code>, <code>previous==0</code>, 则这次点击的查询会至少等待 <code>0.6s</code> 才送出，也就是最快要在 <code>1s</code> 的时候 <code>click2</code> 的查询请求才送出。（由于 <code>setTimeout(func, wait)</code> 并不能保证 <code>func</code> 的执行开始时间，只能保证 <code>func</code> 不早于从现在起到 <code>wait</code> 毫秒后发生， 所以 <code>click2</code> 的查询请求并不一定在 <code>1s</code> 时就能够被送出）<br>.    在 <code>1.2s</code> 时，产生 <code>click3</code>，<code>now==1.2</code></li></ol><p>那么就会存在如下两种情况：</p><ul><li><code>click2</code> 的查询先于 <code>click3</code> 发生，比如在 <code>1.1s</code> 时 <code>click2</code> 的回调被执行，那么 <code>click3</code> 的回调要等 <code>1-(1.2-1.1)==0.9s</code> 才发生<br>   <code>1.3s</code> 时 <code>click2</code> 的查询请求开始执行，<code>previous==1.3</code>，<code>remaining=1-(1.2-1.3)==1.1&gt;1</code>，此时，Underscore 会让 <code>click3</code> 的查询请求也开始执行（既不会停止 <code>click</code> 的查询请求，也不会停止 <code>click3</code> 的查询请求），<code>click3</code> 和 <code>click2</code> 的返回结果取最近一次。</li></ul><h3 id="leading-edge-与-trailing-edge"><a href="#leading-edge-与-trailing-edge" class="headerlink" title="leading edge 与 trailing edge"></a>leading edge 与 trailing edge</h3><p>underscore 中的 <code>throttle</code> 函数提供了第三个参数 <code>options</code> 来进行选项配置，并且支持如下两个参数：</p><ol><li><code>leading</code>：是否设置 <strong> 节流前缘 </strong> – <code>leading edge</code>。前缘的作用是保证第一次尝试调用的 <code>func</code> 会被立即执行，否则第一次调用也必须等待 <code>wait</code> 时间，默认为 <code>true</code>。<br>.    <code>trailing</code>：是否设置 <strong> 节流后缘 </strong> – <code>trailing edge</code>。后缘的作用是：当最近一次尝试调用 <code>func</code> 时，如果 <code>func</code> 不能立即执行，会延后 <code>func</code> 的执行，默认为 <code>true</code>。</li></ol><p>这两个配置会带来总共四种组合，通过 <a href="https://jsfiddle.net/softshot/Lakgk99q/9/" target="_blank" rel="noopener">这个演示</a>，观察不同组合的效果。</p><h2 id="debounce"><a href="#debounce" class="headerlink" title="debounce"></a>debounce</h2><p>在实际项目中，我们还有一种需求，就是如果过于频繁的尝试调用某个函数时，只允许一次调用成功执行。仍然以点击查询按钮异步查询为例，假设我们每次点击的时间间隔都在 <code>1s</code> 内，那么所有的点击只有一次能送出请求，要么是第一次，要么是最后一次。显然，<code>throttle</code> 是做不到这点的，<code>throttle</code> 会至少送出两次请求。针对于此，Underscore 又撰写了 <code>debounce</code> 函数。</p><p>顾名思义， <code>debounce</code> – 防反跳，就是不再跳起，不再响应的意思。</p><blockquote><p><code>throttle</code> 和 <code>debounce</code> 并非 Underscore 独有，他们不仅仅是函数，也是解决问题的方式，诸如 jquery，lodash 等知名库都提供了这两个方法。</p></blockquote><p>从下面的 <code>debounce</code> 实现我们可以看到，不同于 <code>throttle</code>，<code>debounce</code> 不再计算 <code>remain</code> 时间，其提供的 <code>immediate</code> 参数类似于 <code>throttle</code> 中的对于 <code>leading-edge</code> 和 <code>trailing-edge</code> 的控制：</p><ul><li><code>immediate === true</code>，开启 <code>leading-edge</code>，可以执行时立即执行<br>   <code>immediate === false</code>（默认）开启 <code>trailing-edge</code>，可以执行时也必须延后至少 <code>wait</code> 个时间才能执行。</li></ul><p>因此，<code>debounce</code> 后的 <code>func</code> 要么立即获得响应，要么延迟一段时间才响应，<a href="https://jsfiddle.net/softshot/gamLjgcn/" target="_blank" rel="noopener">查看演示</a>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.debounce = <span class="function"><span class="keyword">function</span> (<span class="params">func, wait, immediate</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> timeout, result;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span> (<span class="params">context, args</span>) </span>&#123;</span><br><span class="line">            timeout = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (args) result = func.apply(context, args);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> debounced = restArgs(<span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 每次新的尝试调用 func，会使抛弃之前等待的 func</span></span><br><span class="line">            <span class="keyword">if</span> (timeout) clearTimeout(timeout);</span><br><span class="line">            <span class="comment">// 如果允许新的调用尝试立即执行，</span></span><br><span class="line">            <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">                <span class="comment">// 如果之前尚没有调用尝试，那么此次调用可以立马执行，否则就需要等待 </span></span><br><span class="line">                <span class="keyword">var</span> callNow = !timeout;</span><br><span class="line">                <span class="comment">// 刷新 timeout</span></span><br><span class="line">                timeout = setTimeout(later, wait);</span><br><span class="line">                <span class="comment">// 如果能被立即执行，立即执行 </span></span><br><span class="line">                <span class="keyword">if</span> (callNow) result = func.apply(<span class="keyword">this</span>, args);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 否则，这次尝试调用会延时 wait 个时间 </span></span><br><span class="line">                timeout = _.delay(later, wait, <span class="keyword">this</span>, args);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        debounced.cancel = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            clearTimeout(timeout);</span><br><span class="line">            timeout = <span class="literal">null</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> debounced;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="debounce-1"><a href="#debounce-1" class="headerlink" title="debounce"></a>debounce</h3><p>一定要记住，<code>debounce</code> 满足的是：</p><blockquote><p>高频下只响应一次</p></blockquote><ol><li>遇上疯狂打字员，在输入框快速输入文字（高频），但是我们只想在其完全停止输入时再对输入文字做出处理（一次）。<br>.    AJAX，多数场景下，每个异步请求在短时间只能响应一次。比如下拉刷新，不停的到底（高频），但只发送一次 ajax 请求（一次）。</li></ol><h3 id="throttle"><a href="#throttle" class="headerlink" title="throttle"></a>throttle</h3><p>相比 <code>debounce</code>，<code>throttle</code> 要更加宽松一些，其目的在于:</p><blockquote><p>按频率执行调用。</p></blockquote><ol><li>游戏中的按键响应，比如格斗，比如射击，需要控制出拳和射击的速率。<br>.    自动完成，按照一定频率分析输入，提示自动完成。<br>.    鼠标移动和窗口滚动，鼠标稍微移动一下，窗口稍微滚动一下会带来大量的事件，因而需要控制回调的发生频率。</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://drupalmotion.com/article/debounce-and-throttle-visual-explanation" target="_blank" rel="noopener">Debounce and Throttle: a visual explanation</a><br>   <a href="https://www.zhihu.com/question/19805411" target="_blank" rel="noopener">知乎 @长天之云的回答</a><br>   <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setTimeout" target="_blank" rel="noopener">MDN setTimeout</a><br>   <a href="https://blog.coding.net/blog/the-difference-between-throttle-and-debounce-in-underscorejs" target="_blank" rel="noopener">浅谈 Underscore.js 中 <em>.throttle 和 </em>.debounce 的差异</a><br>   <a href="http://www.easyui.info/archives/1853.html" target="_blank" rel="noopener">Underscore 之 throttle 函数源码分析以及使用注意事项</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们先来看一个前端开发中遇到的场景：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在页面中，我们有一个 “查询” 按钮，单击该按钮，会通过 &lt;strong&gt;ajax&lt;/strong&gt; 异步查询一些数据&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;假设这个查询是耗时的，并且会给后端造成一定压力，那么如果短时间内我们频繁点击该按钮，请求就会不断发出，这样给后端造成的压力是难以想象的。因此，我们会想到控制我们的查询速率。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript 函数式编程" scheme="http://yoyoyohamapi.me/categories/JavaScript-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="函数式编程" scheme="http://yoyoyohamapi.me/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>闭包的一个经典实例和认识误区</title>
    <link href="http://yoyoyohamapi.me/2016/03/18/%E9%97%AD%E5%8C%85%E7%9A%84%E4%B8%80%E4%B8%AA%E7%BB%8F%E5%85%B8%E5%AE%9E%E4%BE%8B%E5%92%8C%E8%AE%A4%E8%AF%86%E8%AF%AF%E5%8C%BA/"/>
    <id>http://yoyoyohamapi.me/2016/03/18/闭包的一个经典实例和认识误区/</id>
    <published>2016-03-18T01:28:54.000Z</published>
    <updated>2018-02-14T17:00:34.652Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>假定我们页面上有 5 个按钮，分别为 按钮 0，…， 按钮 4，如下图所示：</p><div style="text-align:center"><br><img src="http://7pulhb.com2.z0.glb.clouddn.com/%E9%97%AD%E5%8C%85-%E9%A1%B5%E9%9D%A2.png" width="500"><br></div><a id="more"></a><p>现在，我们想为该按钮绑定一个事件：当鼠标点击按钮时，弹出显示框展示按钮索引，对于一些 JavaScript 的初学者来说，不由分说地就写出了下面的代码：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span> 闭包经典例子 < span class="tag">&lt;/<span class="name">title</span>&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span>&gt;</span> 按钮 0<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span>&gt;</span> 按钮 1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span>&gt;</span> 按钮 2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span>&gt;</span> 按钮 3<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span>&gt;</span> 按钮 4<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> buttons = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'button'</span>);</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">for</span>(<span class="keyword">var</span> i= <span class="number">0</span>,length = buttons.length;i&lt;length;i++) &#123;</span></span><br><span class="line"><span class="actionscript">        buttons[i].onclick = <span class="function"><span class="keyword">function</span> <span class="title">click</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="undefined">            alert(i);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>事与愿违，当我们运行上述页面时，无论我们单击那个按钮，都会弹出如下信息，对的，他们全部都弹出一样的值：</p><div style="text-align:center"><br><img src="http://7pulhb.com2.z0.glb.clouddn.com/%E9%97%AD%E5%8C%85-alert%285%29.png" width="200"><br></div><p>我一直认为这是一个极好的关于的闭包的例子，因为这个问题：</p><blockquote><p>由闭包而起，也由闭包而消除</p></blockquote><p>现在，我们认识闭包，我最喜欢的对于闭包的解释是：</p><blockquote><p>“函数在当前词法作用域之外执行，就产生了闭包” – KYLE SIMPSON</p></blockquote><p>在 JavaScript 中，作用域大多只存在于 <strong> 函数作用域（try-catch 也可以模拟作用域）</strong>，而不存在诸如 Java 等语言中的块级作用域 <code>{}</code>。</p><p>现在，既然我们的点击事件能够发生，就说明各个按钮的 <code>onclick</code> 属性是成功绑定的，出错的位置应该发生在 <code>click()</code> 函数内部。进一步分析：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">click</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <a href="https://book.douban.com/subject/3590768/" target="_blank" rel="noopener">《JavaScript 语言精粹》</a> 中，描述到：</p><blockquote><p><code>click()</code> 绑定了变量 <code>i</code> 本身，而没有绑定变量 <code>i</code> 的值</p></blockquote><p>但作者 CrockFord 也并未对造成这样局面的原因多说一句。之所以这样，是因为在 JavaScript 中，对于引用指向的值的确定将会放在 <strong> 运行时 </strong> 确定，取值过程称之为 retrieve。在页面初始化过程中，由于 <code>click()</code> 函数没有调用，亦即 <code>click()</code> 的执行体并没有进入运行时环境，能够确定的仅只是 <code>alert()</code> 函数需要一个引用为 <code>i</code> 的参数，而并不知道对应的 <code>i</code> 的值。</p><p>当我们点击某个按钮时，发生如下的函数的调用，进入 <code>click()</code> 的 <code>运行时</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">click();</span><br></pre></td></tr></table></figure><p>然后我们会去执行：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert(i);</span><br></pre></td></tr></table></figure><p>为了执行 <code>alert()</code> 函数，需要为其提供参数 <code>i</code>（retrieve <code>i</code>）。更准确地说，就是设法找到 <code>i</code> 指向的值，在 <code>click</code> 函数作用域下，我们并不能找到 <code>i</code>。在 Firefox 下，我们可以利用 Firebug 看到，确实，在 <code>click</code> 函数作用域下，并没有参数 <code>i</code>。</p><div style="text-align:center"><br><img src="http://7pulhb.com2.z0.glb.clouddn.com/%E9%97%AD%E5%8C%85-click%E4%BD%9C%E7%94%A8%E5%9F%9F.png" width="600"><br></div><p>那么我们就回到 <code>click</code> 函数作用域的上一级作用域寻找，在 <code>load()</code> 函数作用域下成功找到 <code>i</code> 值：</p><div style="text-align:center"><br><img src="http://7pulhb.com2.z0.glb.clouddn.com/%E9%97%AD%E5%8C%85-load%E6%89%BE%E5%88%B0i.png" width="600"><br></div><p>基于其他语言的看法，我们可能会认为 <code>load()</code> 函数在执行完成后（页面加载），就会丢弃他自己的局部变量 <code>i</code>, 但是由于 <code>click()</code> 函数需要，所以 <code>i</code> 仍然会驻留在内存当中，以供给 <code>click()</code> 使用。</p><p>这就是一次跨作用域形成的闭包，所以我说该问题由闭包而引起（很多身边的朋友在看到接下来用闭包解决该问题，就以为闭包是个解决问题的 <strong> 警官 </strong>，而忽略了这个问题的 <strong> 凶手 </strong> 之一也是闭包）。</p><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>在很多 JavaScript 书籍中，一般就直接摆出了解决该问题的方法，并没有做更多解释，所以很多人 “大概记住了” 解决问题的代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">buttons[i].onclick = (<span class="function"><span class="keyword">function</span> <span class="title">exec</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> j = i;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">click</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>现在先抛开解决的代码片，我们想一下，如果我们还是要依赖于循环的索引去绑定按钮的弹出文字，应该怎么办，我想，解决方案的核心应当是：</p><blockquote><p>“快照” 我们的循环索引 <code>i</code>，让按钮的点击事件函数能够真正绑定到索引 <strong> 值 </strong>，而不仅只是 <strong> 引用 </strong>。</p></blockquote><p>基于之前的知识，我们知道，要想确定一个引用指向的值，我们需要到达运行时环境，并且我们可以通过 <strong> 执行一次函数调用来到达运行时环境 </strong>，在运行时环境，我们产出需要绑定的值。所以，我们通过一个 <strong> 立即执行函数（也称为即时函数）</strong> <code>exec()</code> 来到达运行时环境，快照了 <code>i</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">buttons[i].onclick = (<span class="function"><span class="keyword">function</span> <span class="title">exec</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> j = i;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">click</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><div style="text-align:center"><br><img src="http://7pulhb.com2.z0.glb.clouddn.com/%E9%97%AD%E5%8C%85-%E4%BF%9D%E7%95%99%E7%9A%84j.png" width="600"><br></div><p>所以，我们又通过闭包实现了快照，解决了这个恼人的绑定问题。我更愿意把这个问题的产生和解决归纳为如下过程</p><ol><li>我们犯错是因为我们并没有绑定到循环索引的值，而只是绑定了引用 <code>i</code></li><li>JavaScript 的作用域是函数级别的，我们虽然没有在绑定函数中找到引用 <code>i</code> 对应的值，但是通过 <strong> 闭包（凶手）</strong> 形成的作用域链，我们最后还是拿到了 <code>i</code> 的值，它是最近的一次 <code>i</code> 值：5，并不是我们期望的。</li><li>然后我们知道可以通过函数调用进入运行时取得循环的索引的值，所以我们就通过一个立即函数来进入运行时。</li><li>仅仅取得值是不够的，我们还要缓存这个值，因为我们的事件依赖于这个值。所以，能够达到此目的的仍然是闭包，让闭包去强行包住我们要的值，此时，闭包是 <strong> 解决问题的保护伞 </strong>。</li></ol><h2 id="误区"><a href="#误区" class="headerlink" title="误区"></a>误区</h2><p>之前，我发现周围一些同学在认识这个例子的解决策略的时候，只认识到了 “其形”，也就产生如下的几个误区。</p><h3 id="误区之一：-通过立即执行函数解决问题"><a href="#误区之一：-通过立即执行函数解决问题" class="headerlink" title="误区之一： 通过立即执行函数解决问题"></a>误区之一： 通过立即执行函数解决问题</h3><p>有些同学认为是 <strong> 立即执行函数 </strong> 解决了这个问题。隔了几天，当他回顾着想要再写一遍解决代码的时候，他尝试回顾着 <code>立即执行函数</code> 这个概念，并写出了这样的代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">buttons[i].onclick = (<span class="function"><span class="keyword">function</span> <span class="title">exec</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">click</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>在这样的执行体中，我们并未能 <strong> 快照 </strong> 到循环索引。即便不通过立即函数，我们也能解决问题：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">buttons[i].onclick = exec();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">exec</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">click</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>产生这个误区的原因是：没有看到立即执行函数只是为了产生一次函数调用，从而进入运行时去追溯循环索引 <code>i</code> 的值。</p><h3 id="误区之二：通过标记值解决问题"><a href="#误区之二：通过标记值解决问题" class="headerlink" title="误区之二：通过标记值解决问题"></a>误区之二：通过标记值解决问题</h3><p>同样的在看过解决代码后的几天，有的同学大概又只能依稀想起 <code>var j=i;</code>，然后仅用此去尝试解决问题：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">buttons[i].onclick = <span class="function"><span class="keyword">function</span> <span class="title">click</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> j = i;</span><br><span class="line">    alert(j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为没有进行运行时环境，所以我们并没有动态的对 <code>j</code> 进行赋值（ <code>var j=i</code> 并没有在循环内得到执行），所以最后当点击事件发生，执行到 <code>var j = i;</code> 时， 这一赋值操作需要去找到 <code>i</code>，我们仍然是在外层作用域找到了 <code>i</code>。</p><p>产生这种误区的原因是：忽略了函数体的逻辑只有在运行时才会发生，所以想要通过额外变量来记录循环索引，我们得想办法进入运行时。</p><p>同理，如下的代码片仍然不起作用，只是这次弹出显示的数字将永久为 4, 因为 <code>ii</code> 最后的一次赋值结果为 4;</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i= <span class="number">0</span>,length = buttons.length;i&lt;length;i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> ii = i;</span><br><span class="line">    buttons[i].onclick = <span class="function"><span class="keyword">function</span> <span class="title">click</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(ii);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h2&gt;&lt;p&gt;假定我们页面上有 5 个按钮，分别为 按钮 0，…， 按钮 4，如下图所示：&lt;/p&gt;
&lt;div style=&quot;text-align:center&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://7pulhb.com2.z0.glb.clouddn.com/%E9%97%AD%E5%8C%85-%E9%A1%B5%E9%9D%A2.png&quot; width=&quot;500&quot;&gt;&lt;br&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="JavaScript 学习笔记" scheme="http://yoyoyohamapi.me/categories/JavaScript-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="http://yoyoyohamapi.me/tags/JavaScript/"/>
    
      <category term="闭包" scheme="http://yoyoyohamapi.me/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
</feed>
